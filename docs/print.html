<!DOCTYPE HTML>
<html lang="zn_cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crystal 语言参考</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">2.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/on_debian_and_ubuntu.html"><strong aria-hidden="true">2.1.</strong> 在 Debian 和 Ubuntu</a></li><li class="chapter-item expanded "><a href="installation/on_redhat_and_centos.html"><strong aria-hidden="true">2.2.</strong> 在 RedHat 和 CentOS</a></li><li class="chapter-item expanded "><a href="installation/on_arch_linux.html"><strong aria-hidden="true">2.3.</strong> 在 Arch Linux</a></li><li class="chapter-item expanded "><a href="installation/on_gentoo_linux.html"><strong aria-hidden="true">2.4.</strong> 在 Gentoo Linux</a></li><li class="chapter-item expanded "><a href="installation/on_mac_osx_using_homebrew.html"><strong aria-hidden="true">2.5.</strong> 在 Mac OSX 使用 Homebrew</a></li><li class="chapter-item expanded "><a href="installation/on_linux_using_linuxbrew.html"><strong aria-hidden="true">2.6.</strong> 在 Linux 使用 Linuxbrew</a></li><li class="chapter-item expanded "><a href="installation/on_bash_on_ubuntu_on_windows.html"><strong aria-hidden="true">2.7.</strong> 在 Windows 的 Ubuntu 子系统使用 Bash</a></li><li class="chapter-item expanded "><a href="installation/on_native_windows.html"><strong aria-hidden="true">2.8.</strong> 在 Windows 原生环境</a></li><li class="chapter-item expanded "><a href="installation/from_a_targz.html"><strong aria-hidden="true">2.9.</strong> 从 tar.gz</a></li><li class="chapter-item expanded "><a href="installation/from_source_repository.html"><strong aria-hidden="true">2.10.</strong> 从源码编译</a></li></ol></li><li class="chapter-item expanded "><a href="using_the_compiler/index.html"><strong aria-hidden="true">3.</strong> 使用编译器</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">4.</strong> 概览和例子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/hello_world.html"><strong aria-hidden="true">4.1.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="overview/http_server.html"><strong aria-hidden="true">4.2.</strong> HTTP Server</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/index.html"><strong aria-hidden="true">5.</strong> 语法和语义</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/comments.html"><strong aria-hidden="true">5.1.</strong> 注释</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals.html"><strong aria-hidden="true">5.2.</strong> 字面量</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/nil.html"><strong aria-hidden="true">5.2.1.</strong> Nil</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/bool.html"><strong aria-hidden="true">5.2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/integers.html"><strong aria-hidden="true">5.2.3.</strong> 整数</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/floats.html"><strong aria-hidden="true">5.2.4.</strong> 浮点数</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/char.html"><strong aria-hidden="true">5.2.5.</strong> 字符</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/string.html"><strong aria-hidden="true">5.2.6.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/symbol.html"><strong aria-hidden="true">5.2.7.</strong> 符号</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/array.html"><strong aria-hidden="true">5.2.8.</strong> 数组</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/hash.html"><strong aria-hidden="true">5.2.9.</strong> 散列</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/range.html"><strong aria-hidden="true">5.2.10.</strong> 范围</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/regex.html"><strong aria-hidden="true">5.2.11.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/tuple.html"><strong aria-hidden="true">5.2.12.</strong> 元组</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/named_tuple.html"><strong aria-hidden="true">5.2.13.</strong> 命名元组</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/proc.html"><strong aria-hidden="true">5.2.14.</strong> 闭包</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/literals/command.html"><strong aria-hidden="true">5.2.15.</strong> 命令</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/assignment.html"><strong aria-hidden="true">5.3.</strong> 赋值</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/multiple_assignment.html"><strong aria-hidden="true">5.3.1.</strong> 多重赋值</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/local_variables.html"><strong aria-hidden="true">5.4.</strong> 局部变量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/control_expressions.html"><strong aria-hidden="true">5.5.</strong> 控制结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/truthy_and_falsey_values.html"><strong aria-hidden="true">5.5.1.</strong> “真”与“假”值</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/if.html"><strong aria-hidden="true">5.5.2.</strong> if</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/as_a_suffix.html"><strong aria-hidden="true">5.5.2.1.</strong> 作为后缀</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/as_an_expression.html"><strong aria-hidden="true">5.5.2.2.</strong> 作为表达式</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/ternary_if.html"><strong aria-hidden="true">5.5.2.3.</strong> 三元 if 表达式</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/if_var.html"><strong aria-hidden="true">5.5.2.4.</strong> if 变量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/if_varis_a.html"><strong aria-hidden="true">5.5.2.5.</strong> if var.is_a?(...)</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/if_varresponds_to.html"><strong aria-hidden="true">5.5.2.6.</strong> if var.responds_to?(...)</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/if_var_nil.html"><strong aria-hidden="true">5.5.2.7.</strong> if var.nil?</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/not.html"><strong aria-hidden="true">5.5.2.8.</strong> if !</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/unless.html"><strong aria-hidden="true">5.5.3.</strong> unless</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/case.html"><strong aria-hidden="true">5.5.4.</strong> case</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/while.html"><strong aria-hidden="true">5.5.5.</strong> while</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/break.html"><strong aria-hidden="true">5.5.5.1.</strong> break</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/next.html"><strong aria-hidden="true">5.5.5.2.</strong> next</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/until.html"><strong aria-hidden="true">5.5.6.</strong> until</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/and.html"><strong aria-hidden="true">5.5.7.</strong> &&</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/or.html"><strong aria-hidden="true">5.5.8.</strong> ||</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/requiring_files.html"><strong aria-hidden="true">5.6.</strong> 导入文件</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/types_and_methods.html"><strong aria-hidden="true">5.7.</strong> 类型和方法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/everything_is_an_object.html"><strong aria-hidden="true">5.7.1.</strong> 一切都是对象</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/the_program.html"><strong aria-hidden="true">5.7.2.</strong> Crystal 程序</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/classes_and_methods.html"><strong aria-hidden="true">5.7.3.</strong> 类和方法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/new,_initialize_and_allocate.html"><strong aria-hidden="true">5.7.3.1.</strong> 实例化，初始化和内存分配</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/methods_and_instance_variables.html"><strong aria-hidden="true">5.7.3.2.</strong> 方法和实例变量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/type_inference.html"><strong aria-hidden="true">5.7.3.3.</strong> 类型推导</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/union_types.html"><strong aria-hidden="true">5.7.3.4.</strong> 联合类型</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/overloading.html"><strong aria-hidden="true">5.7.3.5.</strong> 重载</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/default_and_named_arguments.html"><strong aria-hidden="true">5.7.3.6.</strong> 命名参数和默认值</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/splats_and_tuples.html"><strong aria-hidden="true">5.7.3.7.</strong> 不定数目参数和元组展开</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/type_restrictions.html"><strong aria-hidden="true">5.7.3.8.</strong> 类型限制</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/return_types.html"><strong aria-hidden="true">5.7.3.9.</strong> 返回类型</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html"><strong aria-hidden="true">5.7.3.10.</strong> 方法形参详述</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/operators.html"><strong aria-hidden="true">5.7.3.11.</strong> 运算符</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/visibility.html"><strong aria-hidden="true">5.7.3.12.</strong> 可见性</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/inheritance.html"><strong aria-hidden="true">5.7.3.13.</strong> 继承</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/virtual_and_abstract_types.html"><strong aria-hidden="true">5.7.3.13.1.</strong> 虚类型和抽象类型</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/class_methods.html"><strong aria-hidden="true">5.7.3.14.</strong> 类方法</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/class_variables.html"><strong aria-hidden="true">5.7.3.15.</strong> 类变量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/finalize.html"><strong aria-hidden="true">5.7.3.16.</strong> finalize</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/modules.html"><strong aria-hidden="true">5.7.4.</strong> 模块</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/generics.html"><strong aria-hidden="true">5.7.5.</strong> 泛型</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/structs.html"><strong aria-hidden="true">5.7.6.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/constants.html"><strong aria-hidden="true">5.7.7.</strong> 常量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/enum.html"><strong aria-hidden="true">5.7.8.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/blocks_and_procs.html"><strong aria-hidden="true">5.7.9.</strong> 块和闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/capturing_blocks.html"><strong aria-hidden="true">5.7.9.1.</strong> 捕获块</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/proc_literal.html"><strong aria-hidden="true">5.7.9.2.</strong> 闭包字面量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/block_forwarding.html"><strong aria-hidden="true">5.7.9.3.</strong> 传递块</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/closures.html"><strong aria-hidden="true">5.7.9.4.</strong> 闭包及其环境变量</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/alias.html"><strong aria-hidden="true">5.7.10.</strong> 别名</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/exception_handling.html"><strong aria-hidden="true">5.8.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/type_grammar.html"><strong aria-hidden="true">5.9.</strong> 类型语法</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/type_reflection.html"><strong aria-hidden="true">5.10.</strong> 类型反射</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/is_a.html"><strong aria-hidden="true">5.10.1.</strong> is_a?</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/nil_question.html"><strong aria-hidden="true">5.10.2.</strong> nil?</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/responds_to.html"><strong aria-hidden="true">5.10.3.</strong> responds_to?</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/as.html"><strong aria-hidden="true">5.10.4.</strong> as</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/as_question.html"><strong aria-hidden="true">5.10.5.</strong> as?</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/typeof.html"><strong aria-hidden="true">5.10.6.</strong> typeof</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/macros.html"><strong aria-hidden="true">5.11.</strong> 宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/macros/macro_methods.html"><strong aria-hidden="true">5.11.1.</strong> 宏方法</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/macros/hooks.html"><strong aria-hidden="true">5.11.2.</strong> 钩子</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/macros/fresh_variables.html"><strong aria-hidden="true">5.11.3.</strong> 宏内变量</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/attributes.html"><strong aria-hidden="true">5.12.</strong> 属性</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/low_level_primitives.html"><strong aria-hidden="true">5.13.</strong> 底层原语</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/pointerof.html"><strong aria-hidden="true">5.13.1.</strong> pointerof</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/sizeof.html"><strong aria-hidden="true">5.13.2.</strong> sizeof</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/instance_sizeof.html"><strong aria-hidden="true">5.13.3.</strong> instance_sizeof</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/declare_var.html"><strong aria-hidden="true">5.13.4.</strong> 声明未初始化的变量</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/compile_time_flags.html"><strong aria-hidden="true">5.14.</strong> 编译时标记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/cross-compilation.html"><strong aria-hidden="true">5.14.1.</strong> 交叉编译</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/index.html"><strong aria-hidden="true">5.15.</strong> C语言绑定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/lib.html"><strong aria-hidden="true">5.15.1.</strong> lib</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/fun.html"><strong aria-hidden="true">5.15.2.</strong> fun</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/out.html"><strong aria-hidden="true">5.15.2.1.</strong> out</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/to_unsafe.html"><strong aria-hidden="true">5.15.2.2.</strong> to_unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/struct.html"><strong aria-hidden="true">5.15.3.</strong> struct</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/union.html"><strong aria-hidden="true">5.15.4.</strong> union</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/enum.html"><strong aria-hidden="true">5.15.5.</strong> enum</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/variables.html"><strong aria-hidden="true">5.15.6.</strong> 变量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/constants.html"><strong aria-hidden="true">5.15.7.</strong> 常量</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/type.html"><strong aria-hidden="true">5.15.8.</strong> 类型</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/alias.html"><strong aria-hidden="true">5.15.9.</strong> 别名</a></li><li class="chapter-item expanded "><a href="syntax_and_semantics/c_bindings/callbacks.html"><strong aria-hidden="true">5.15.10.</strong> 回调</a></li></ol></li><li class="chapter-item expanded "><a href="syntax_and_semantics/unsafe.html"><strong aria-hidden="true">5.16.</strong> Unsafe 代码</a></li></ol></li><li class="chapter-item expanded "><a href="conventions/index.html"><strong aria-hidden="true">6.</strong> 约定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conventions/coding_style.html"><strong aria-hidden="true">6.1.</strong> 代码风格</a></li><li class="chapter-item expanded "><a href="conventions/documenting_code.html"><strong aria-hidden="true">6.2.</strong> 代码注释</a></li></ol></li><li class="chapter-item expanded "><a href="database/index.html"><strong aria-hidden="true">7.</strong> 数据库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="database/connection_pool.html"><strong aria-hidden="true">7.1.</strong> 连接池</a></li></ol></li><li class="chapter-item expanded "><a href="guides/index.html"><strong aria-hidden="true">8.</strong> 导引</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/performance.html"><strong aria-hidden="true">8.1.</strong> 性能</a></li><li class="chapter-item expanded "><a href="guides/concurrency.html"><strong aria-hidden="true">8.2.</strong> 并发</a></li><li class="chapter-item expanded "><a href="guides/testing.html"><strong aria-hidden="true">8.3.</strong> 测试</a></li><li class="chapter-item expanded "><a href="guides/writing_shards.html"><strong aria-hidden="true">8.4.</strong> 编写 Shards 包</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Crystal 语言参考</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="crystal-编程语言"><a class="header" href="#crystal-编程语言">Crystal 编程语言</a></h1>
<p>这是 Crystal 语言的参考文档。<a href="SUMMARY.html">目录</a></p>
<p>Crystal 语言的设计目标如下：</p>
<ul>
<li>语法与Ruby类似（但兼容性不是目标）。</li>
<li>静态类型检查，但不需要显式指定变量或参数类型。</li>
<li>可在Crystal内通过代码绑定调用C代码。</li>
<li>编译期进行代码评估和生成，避免了样板式的代码。</li>
<li>可编译为高效的本地机器码。</li>
</ul>
<h2 id="伟大的开源力量"><a class="header" href="#伟大的开源力量">伟大的开源力量</a></h2>
<p>欢迎提交 pull request ：</p>
<p>https://github.com/chinazhangchao/crystal-book-zh_CN</p>
<p>一起来翻译吧^_^！QQ交流群号：823109001。</p>
<h3 id="本地编译预览"><a class="header" href="#本地编译预览">本地编译预览</a></h3>
<h4 id="mdbook"><a class="header" href="#mdbook">mdbook</a></h4>
<p>鉴于gitbook 命令行版已经失去维护，我们可以用 <a href="https://rust-lang.github.io/mdBook">mdbook</a> 进行预览。</p>
<pre><code>$ mdbook serve
</code></pre>
<p>应该能看到</p>
<pre><code>2022-10-07 22:06:15 [WARN] (mdbook::book): It appears you are still using book.json for configuration.
2022-10-07 22:06:15 [WARN] (mdbook::book): This format is no longer used, so you should migrate to the
2022-10-07 22:06:15 [WARN] (mdbook::book): book.toml format.
2022-10-07 22:06:15 [WARN] (mdbook::book): Check the user guide for migration information:
2022-10-07 22:06:15 [WARN] (mdbook::book):      https://rust-lang.github.io/mdBook/format/config.html 
2022-10-07 22:06:16 [INFO] (mdbook::book): Book building has started
2022-10-07 22:06:16 [INFO] (mdbook::book): Running the html backend
2022-10-07 22:06:28 [INFO] (mdbook::cmd::serve): Serving on: http://localhost:3000
2022-10-07 22:06:28 [INFO] (warp::server): Server::run; addr=[::1]:3000   
2022-10-07 22:06:28 [INFO] (warp::server): listening on http://[::1]:3000 
</code></pre>
<h4 id="gitbook"><a class="header" href="#gitbook">gitbook</a></h4>
<pre><code>$ git clone https://github.com/chinazhangchao/crystal-book-zh_CN.git
$ cd crystal-book
$ npm install -g gitbook-cli@2.3.0
$ gitbook install
$ gitbook serve
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 8 plugins are installed
info: loading plugin &quot;ga&quot;... OK
...
Starting server ...
Serving book on http://localhost:4000

</code></pre>
<p>或者通过docker方式：</p>
<pre><code>$ docker-compose up
...
gitbook_1  | Starting server ...
gitbook_1  | Serving book on http://localhost:4000
gitbook_1  | Restart after change in file node_modules/.bin
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>一旦你通过如下方法的一种安装了编译器，一定要读 <a href="installation/../using_the_compiler/README.html">使用编译器</a>，来学习如何高效地使用它。</p>
<ul>
<li><a href="installation/on_debian_and_ubuntu.html">在 Debian 和 Ubuntu</a></li>
<li><a href="installation/on_redhat_and_centos.html">在 RedHat 和 CentOS</a></li>
<li><a href="installation/on_arch_linux.html">在 Arch Linux</a></li>
<li><a href="installation/on_gentoo_linux.html">在 Gentoo Linux</a></li>
<li><a href="installation/on_mac_osx_using_homebrew.html">在 Mac OSX ，使用 Homebrew</a></li>
<li><a href="installation/on_linux_using_linuxbrew.html">在 Linux ，使用 Linuxbrew</a></li>
<li><a href="installation/on_bash_on_ubuntu_on_windows.html">在 Windows 的 Ubuntu 子系统上使用 Bash</a></li>
<li><a href="installation/on_native_windows.html">在原生 Windows环境</a></li>
<li><a href="installation/from_a_targz.html">从 tar.gz</a></li>
<li><a href="installation/from_source_repository.html">从源码编译</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-debian-和-ubuntu"><a class="header" href="#在-debian-和-ubuntu">在 Debian 和 Ubuntu</a></h1>
<p>在 Debian 系分发版中，你可以使用官方的 Crystal 仓库。</p>
<h2 id="引入仓库"><a class="header" href="#引入仓库">引入仓库</a></h2>
<p>首先你要在你的 APT 配置中加入仓库，简单起见你只要输入如下命令：</p>
<pre><code>curl https://dist.crystal-lang.org/apt/setup.sh | sudo bash
</code></pre>
<p>这会把仓库和秘钥一起加入配置。如果你要手动做这些，请以<em>root</em>身份输如下命令：</p>
<pre><code>apt-key adv --keyserver keys.gnupg.net --recv-keys 09617FD37CC06B54
echo &quot;deb https://dist.crystal-lang.org/apt crystal main&quot; &gt; /etc/apt/sources.list.d/crystal.list
apt-get update
</code></pre>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p>一旦仓库建立完毕，你就可以安装 Crystal：</p>
<pre><code>sudo apt-get install crystal
</code></pre>
<p><a href="https://github.com/crystal-lang/crystal/issues/4342">你可能需要</a> 安装<code>build-essential</code> 包以运行/编译 Crystal程序。你可以用这个命令安装：</p>
<pre><code>sudo apt-get install build-essential
</code></pre>
<h2 id="upgrade"><a class="header" href="#upgrade">Upgrade</a></h2>
<p>When a new Crystal version is released you can upgrade your system using:</p>
<pre><code>sudo apt-get update
sudo apt-get install crystal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-redhat-和-centos"><a class="header" href="#在-redhat-和-centos">在 RedHat 和 CentOS</a></h1>
<p>在 RedHat系分发版上，你可以用官方的 Crystal 仓库。</p>
<h2 id="建立仓库"><a class="header" href="#建立仓库">建立仓库</a></h2>
<p>首先你要在你的 YUM 配置中加入仓库，简单起见你只要输入如下命令：</p>
<pre><code>curl https://dist.crystal-lang.org/rpm/setup.sh | sudo bash
</code></pre>
<p>这会把仓库和秘钥一起加入配置。如果你要手动做这些，请输入如下命令：</p>
<pre><code>rpm --import https://dist.crystal-lang.org/rpm/RPM-GPG-KEY

cat &gt; /etc/yum.repos.d/crystal.repo &lt;&lt;END
[crystal]
name = Crystal
baseurl = https://dist.crystal-lang.org/rpm/
END
</code></pre>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<p>一旦仓库建立完毕，你就可以安装 Crystal：</p>
<pre><code>sudo yum install crystal
</code></pre>
<h2 id="升级"><a class="header" href="#升级">升级</a></h2>
<p>当新的 Crystal 版本发布时，你可以这样升级：</p>
<pre><code>sudo yum update crystal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-arch-linux"><a class="header" href="#在-arch-linux">在 Arch Linux</a></h1>
<p>Arch Linux 的社区库中已经有 Crystal 编译器了。</p>
<h2 id="安装-3"><a class="header" href="#安装-3">安装</a></h2>
<pre><code>sudo pacman -S crystal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-gentoo-linux"><a class="header" href="#在-gentoo-linux">在 Gentoo Linux</a></h1>
<p>Gentoo Linux 在主overlay中已经包含了 Crystal编译器。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>你也许会需要这些可能的配置标识：</p>
<pre><code># equery u dev-lang/crystal
[ Legend : U - final flag setting for installation]
[        : I - package is installed with flag     ]
[ Colors : set, unset                             ]
 * Found these USE flags for dev-lang/crystal-0.18.7:
 U I
 - - doc      : Add extra documentation (API, Javadoc, etc). It is recommended to enable per package instead of globally
 - - examples : Install examples, usually source code
 + + xml      : Use the dev-libs/libxml2 library to enable Crystal xml module
 + - yaml     : Use the dev-libs/libyaml library to enable Crystal yaml module
</code></pre>
<h2 id="安装-4"><a class="header" href="#安装-4">安装</a></h2>
<pre><code>su -
emerge -a dev-lang/crystal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-mac-osx-上用-homebrew"><a class="header" href="#在-mac-osx-上用-homebrew">在 Mac OSX 上用 Homebrew</a></h1>
<p>为了在 Mac 上简单地安装 Crystalyou ，你可以用 <a href="http://brew.sh/">Homebrew</a>.</p>
<pre><code>brew update
brew install crystal
</code></pre>
<p>如果你要改进编译器，你也会需要安装LLVM。为此你可以被最后一行换成：</p>
<pre><code>brew install crystal --with-llvm
</code></pre>
<h2 id="对-osx-1011-el-capitan-的一些补缺"><a class="header" href="#对-osx-1011-el-capitan-的一些补缺">对 OSX 10.11 (El Capitan) 的一些补缺</a></h2>
<p>如果你遇到这种错误：</p>
<pre><code>ld: library not found for -levent
</code></pre>
<p>你应当重新安装命令行工具，然后选择基础的工具链：</p>
<pre><code>$ xcode-select --install
$ xcode-select --switch /Library/Developer/CommandLineTools
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-linux-上用-linuxbrew"><a class="header" href="#在-linux-上用-linuxbrew">在 Linux 上用 Linuxbrew</a></h1>
<p>你可以用 <a href="http://linuxbrew.sh/">Linuxbrew</a>来在某个Linux分发版上轻易地安装Crystal。</p>
<pre><code>brew update
brew install crystal-lang
</code></pre>
<p>如果你要改进编译器，你也会需要安装LLVM。为此你可以被最后一行换成：</p>
<pre><code>brew install crystal-lang --with-llvm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-windows-的-ubuntu-子系统上使用-bash"><a class="header" href="#在-windows-的-ubuntu-子系统上使用-bash">在 Windows 的 Ubuntu 子系统上使用 Bash</a></h1>
<p>Crystal <em>目前</em> 还不支持 Windows 。但是如果你在用 Windows 10，你可以 (实验性的) <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">在 Windows 的 Ubuntu 子系统上使用 Bash</a>尝试Crystal。既然它也是Bash环境，系统类似于<a href="installation/on_debian_and_ubuntu.html">Debian/Ubuntu</a>，那么安装的方法也类似，只是要注意一些地方。</p>
<p>别忘了，<strong>这不过是个实验</strong>。</p>
<h2 id="建立仓库-1"><a class="header" href="#建立仓库-1">建立仓库</a></h2>
<p>首先你要在你的 APT 配置中加入仓库，简单起见你只要输入如下命令：</p>
<pre><code>curl -sSL https://dist.crystal-lang.org/apt/setup.sh | sudo bash
</code></pre>
<p>这会把仓库和秘钥一起加入配置。如果你要手动做这些，请输如下命令：</p>
<pre><code>sudo apt-key adv --keyserver keys.gnupg.net --recv-keys 09617FD37CC06B54
echo &quot;deb https://dist.crystal-lang.org/apt crystal main&quot; | sudo tee /etc/apt/sources.list.d/crystal.list
sudo apt-get update
</code></pre>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<p>Crystal 需要 C 编译器 (<code>cc</code>)和链接器 (<code>ld</code>) 来编译Crystal 程序——所以你应当安装它：</p>
<pre><code>sudo apt-get install clang binutils
</code></pre>
<h2 id="安装-5"><a class="header" href="#安装-5">安装</a></h2>
<p>一旦仓库建立完毕，所有依赖项已安装，你就可以安装 Crystal：</p>
<pre><code>sudo apt-get install crystal
</code></pre>
<h2 id="升级-1"><a class="header" href="#升级-1">升级</a></h2>
<p>当新的 Crystal 版本发布时，你可以这样升级：</p>
<pre><code>sudo apt-get update
sudo apt-get install crystal
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在原生windows环境"><a class="header" href="#在原生windows环境">在原生windows环境</a></h1>
<blockquote>
<p>译注：这是我自己添加的章节，不在官方内容之列。</p>
</blockquote>
<p>在Windows原生环境编译Crystal <a href="https://github.com/crystal-lang/crystal/wiki/Porting-to-Windows">至今还在实验之中</a>。</p>
<p>你可以从<a href="https://github.com/crystal-lang/crystal/releases">发布页面</a>上下载Windows版对应的二进制包，但并非每个版本都会给Windows 提供包。截至2022年10月6日，最新的 Windows 包版本是1.5.0。</p>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<p><code>shards</code> 在拉取依赖包的时候，会在<code>./lib</code>路径创建符号链接，而这在Windows中是需要管理员权限的。所以运行<code>shards install</code>相关的命令时，务必以管理员身份执行命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从-targz"><a class="header" href="#从-targz">从 tar.gz</a></h1>
<p>如果出于某些原因你不能或不想用之前的安装方法，你仍然可以下载一个单独的tar.gz，里面有运行Crystal所需的所有东西。</p>
<p>最新的文件可从Github的发布页下载： https://github.com/crystal-lang/crystal/releases</p>
<p>下载对应你平台的文件，解压它，你在里面可以找到 <code>bin/crystal</code> 可执行文件。</p>
<p>为了方便使用，你可以在PATH中创建一个符号链接：</p>
<p><code>ln -s [full path to bin/crystal] /usr/local/bin/crystal</code></p>
<p>这样你就可以用 <code>crystal</code>命令来简单地调用编译器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从源码编译"><a class="header" href="#从源码编译">从源码编译</a></h1>
<p>如果你要参与改进编译器，你应该尝试从源码编译 Crystal。</p>
<ol>
<li>
<p><a href="https://crystal-lang.org/docs/installation">安装 Crystal 发布</a>。 Crystal已经能实现自举，为了编译 Crystal，你需要一个现成的 Crystal :)。</p>
</li>
<li>
<p>确保你的PATH中有受支持的 LLVM 版本。目前 Crystal 支持 LLVM 3.8，3.9，4.和5.0。尽量用最新的版本。如果你在用 Mac 和 Homebrew，这些会在你加入 <code>--with-llvm</code> 编译选项时自动配置。</p>
</li>
<li>
<p>确保安装<a href="https://github.com/crystal-lang/crystal/wiki/All-required-libraries">所有依赖的库</a>。你也应该了解 <a href="https://github.com/crystal-lang/crystal/blob/master/CONTRIBUTING.md">语言改进指引</a>.</p>
</li>
<li>
<p>复制这个项目：</p>
</li>
</ol>
<pre><code>git clone https://github.com/crystal-lang/crystal
</code></pre>
<ol start="5">
<li>运行 <code>make</code> 来编译你的自制版编译器。 </li>
<li>运行 <code>make spec</code> 来确保所有的测试都通过，且你已经合适地安装了所有东西。</li>
<li>用 <code>bin/crystal</code> 运行你的  crystal 文件。</li>
</ol>
<p>如果你要深入地了解 <code>bin/crystal</code>，参考 <a href="https://crystal-lang.org/docs/using_the_compiler/">使用编译器</a> 相关的文档。</p>
<p>注意：真正的二进制文件其实在 <code>.build/crystal</code>里，但是 <code>bin/crystal</code>是你真正应该调用的包装脚本。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用编译器"><a class="header" href="#使用编译器">使用编译器</a></h1>
<p><a href="using_the_compiler/../installation/README.html">安装</a>完编译器后就可以使用 <code>crystal</code> 命令。</p>
<p>在下面的章节中美元符号(<code>$</code>)表示命令行。</p>
<h2 id="一次编译运行"><a class="header" href="#一次编译运行">一次编译运行</a></h2>
<p>通过<code>crystal</code>命令后面加文件名就可以编译运行程序。</p>
<pre><code>$ crystal some_program.cr
</code></pre>
<p>Crystal程序文件以<code>.cr</code>扩展名结尾。</p>
<p>也可以使用<code>run</code>命令：</p>
<pre><code>$ crystal run some_program.cr
</code></pre>
<h2 id="生成动态链接的可执行文件"><a class="header" href="#生成动态链接的可执行文件">生成动态链接的可执行文件</a></h2>
<p>可以使用<code>build</code>命令生成可执行文件：</p>
<pre><code>$ crystal build some_program.cr
</code></pre>
<p>上面的命令会生成名为<code>some_program</code>的可执行文件：</p>
<pre><code>$ ./some_program
</code></pre>
<p><strong>注意：</strong> 默认生成的可执行文件<strong>没有完全优化</strong>。 打开优化开关，使用<code>--release</code>选项：</p>
<pre><code>$ crystal build some_program.cr --release
</code></pre>
<p>一定要确保在生产环境和性能测试时总是使用<code>--release</code>。</p>
<p>没有完全优化时的性能也不错，编译时间也很短，因此你可以总是使用<code>crystal</code>命令，就好像在运行解释器一样。</p>
<p>可以通过<code>--no-debug</code>选项和<code>strip</code>命令减少二进制文件的大小。调试符号会被移除，只有当大小是主要问题并且不需要调试时才使用这个选项。</p>
<h2 id="生成单独的可执行文件"><a class="header" href="#生成单独的可执行文件">生成单独的可执行文件</a></h2>
<p>生成单独的可执行文件，使用如下命令：</p>
<pre><code>$ crystal build some_program.cr --release --static
</code></pre>
<p>更多有关静态链接的信息<a href="https://github.com/crystal-lang/crystal/wiki/Static-Linking">查看这里</a></p>
<h2 id="创建项目或库"><a class="header" href="#创建项目或库">创建项目或库</a></h2>
<p>使用<code>init</code>命令创建带有标准目录结构的Crystal项目。</p>
<pre><code>$ crystal init lib my_cool_lib
      create  my_cool_lib/.gitignore
      create  my_cool_lib/.editorconfig
      create  my_cool_lib/LICENSE
      create  my_cool_lib/README.md
      create  my_cool_lib/.travis.yml
      create  my_cool_lib/shard.yml
      create  my_cool_lib/src/my_cool_lib.cr
      create  my_cool_lib/src/my_cool_lib/version.cr
      create  my_cool_lib/spec/spec_helper.cr
      create  my_cool_lib/spec/my_cool_lib_spec.cr
Initialized empty Git repository in ~/my_cool_lib/.git/
</code></pre>
<h2 id="其他命令和选项"><a class="header" href="#其他命令和选项">其他命令和选项</a></h2>
<p>要查看所有可用命令，直接输入<code>crystal</code>。</p>
<pre><code>$ crystal
Usage: crystal [command] [switches] [program file] [--] [arguments]

Command:
    init                     generate a new project
    build                    build an executable
    deps                     install project dependencies
    docs                     generate documentation
    env                      print Crystal environment information
    eval                     eval code from args or standard input
    play                     starts crystal playground server
    run (default)            build and run program
    spec                     build and run specs (in spec directory)
    tool                     run a tool
    help, --help, -h         show this help
    version, --version, -v   show version
</code></pre>
<p>查看特定命令的选项，在命令后面使用<code>--help</code>：</p>
<pre><code>$ crystal build --help
Usage: crystal build [options] [programfile] [--] [arguments]

Options:
    --cross-compile                  cross-compile
    -d, --debug                      Add full symbolic debug info
    --no-debug                       Skip any symbolic debug info
    -D FLAG, --define FLAG           Define a compile-time flag
    --emit [asm|llvm-bc|llvm-ir|obj] Comma separated list of types of output for the compiler to emit
    -f text|json, --format text|json Output format text (default) or json
    --error-trace                    Show full error trace
    -h, --help                       Show this message
    --ll                             Dump ll to Crystal's cache directory
    --link-flags FLAGS               Additional flags to pass to the linker
    --mcpu CPU                       Target specific cpu type
    --mattr CPU                      Target specific features
    --no-color                       Disable colored output
    --no-codegen                     Don't do code generation
    -o                               Output filename
    --prelude                        Use given file as prelude
    --release                        Compile in release mode
    -s, --stats                      Enable statistics output
    -p, --progress                   Enable progress output
    -t, --time                       Enable execution time output
    --single-module                  Generate a single LLVM module
    --threads                        Maximum number of threads to use
    --target TRIPLE                  Target triple
    --verbose                        Display executed commands
    --static                         Link statically
    --stdin-filename                 Source file name to be read from STDIN
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概览"><a class="header" href="#概览">概览</a></h1>
<p>你可以自顶向下地阅读这个文档，但是推荐在段落之间进行跳跃，因为概念往往互相联系，分隔开就不能解释清楚。</p>
<p>在代码示例中，注释 <code>#=&gt;</code> 用于指示表达式的值。例如：</p>
<pre><code class="language-crystal">a = 1 + 2
a #=&gt; 3
</code></pre>
<p>注释 <code>:</code> 用于表示变量的类型：</p>
<pre><code class="language-crystal">s = &quot;hello&quot;
# s : String
</code></pre>
<p>我们用这两个例子来熟悉这门语言吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>经典的 &quot;hello world&quot;程序在 Crystal中像这样：</p>
<pre><code class="language-crystal">puts &quot;Hello world!&quot;
</code></pre>
<p>由此你可以看出来程序的主函数就是程序自己：没有必要像其他语言一样定义什么主函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server"><a class="header" href="#http-server">HTTP Server</a></h1>
<p>一个稍微有点意思的例子是 HTTP服务器:</p>
<pre><code class="language-crystal">require &quot;http/server&quot;

server = HTTP::Server.new do |context|
  context.response.content_type = &quot;text/plain&quot;
  context.response.print &quot;Hello world! The time is #{Time.now}&quot;
end

address = server.bind_tcp 8080
puts &quot;Listening on http://#{address}&quot;
server.listen
</code></pre>
<p>上述代码等读完整个语言参考之后才会完全清楚，但是我们已经能学到一些东西了。</p>
<ul>
<li>
<p>可以从其他文件中 <a href="overview/../syntax_and_semantics/requiring_files.html">require</a> 代码：</p>
<pre><code class="language-crystal">require &quot;http/server&quot;
</code></pre>
</li>
<li>
<p>可以定义 <a href="overview/../syntax_and_semantics/local_variables.html">局部变量</a> 而不需要指定类型：</p>
<pre><code class="language-crystal">server = HTTP::Server.new ...
</code></pre>
</li>
<li>
<p>用对象 HTTP::Server 的方法 bind_tcp 来指定 HTTP 服务器的端口 (这里端口设定为 8080)。</p>
<pre><code class="language-crystal">address = server.bind_tcp 8080
</code></pre>
</li>
<li>
<p>程序通过向对象调用 <a href="overview/../syntax_and_semantics/classes_and_methods.html">方法</a> (或发送消息) 来运行。</p>
<pre><code class="language-crystal">HTTP::Server.new ...
...
Time.now
...
address = server.bind_tcp 8080
...
puts &quot;Listening on http://#{address}&quot;
...
server.listen
</code></pre>
</li>
<li>
<p>可以使用代码块，或简称 <a href="overview/../syntax_and_semantics/blocks_and_procs.html">块</a>。这可以方便地重用代码，也可以获得函数式编程的部分优点：</p>
<pre><code class="language-crystal">HTTP::Server.new do |context|
  ...
end
</code></pre>
</li>
<li>
<p>可以通过向字符串嵌入内容来构造它，这称为字符串插值。语言也为创建数组，散列，范围和元组等对象都提供了方便的<a href="overview/../syntax_and_semantics/literals.html">语法</a>：</p>
<pre><code class="language-crystal">&quot;Hello world! The time is #{Time.now}&quot;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法和语义"><a class="header" href="#语法和语义">语法和语义</a></h1>
<p>程序源代码必须以 UTF-8格式编码。</p>
<ul>
<li><a href="syntax_and_semantics/comments.html">注释</a></li>
<li><a href="syntax_and_semantics/literals.html">字面量</a></li>
<li><a href="syntax_and_semantics/assignment.html">赋值</a></li>
<li><a href="syntax_and_semantics/local_variables.html">局部变量</a></li>
<li><a href="syntax_and_semantics/control_expressions.html">控制结构</a></li>
<li><a href="syntax_and_semantics/requiring_files.html">调入文档</a></li>
<li><a href="syntax_and_semantics/types_and_methods.html">类型和方法</a></li>
<li><a href="syntax_and_semantics/exception_handling.html">异常处理</a></li>
<li><a href="syntax_and_semantics/type_grammar.html">类型语法</a></li>
<li><a href="syntax_and_semantics/type_reflection.html">类型反射</a></li>
<li><a href="syntax_and_semantics/macros.html">宏</a></li>
<li><a href="syntax_and_semantics/attributes.html">属性</a></li>
<li><a href="syntax_and_semantics/low_level_primitives.html">底层原语</a></li>
<li><a href="syntax_and_semantics/compile_time_flags.html">编译时标记</a></li>
<li><a href="syntax_and_semantics/c_bindings/">C语言绑定</a></li>
<li><a href="syntax_and_semantics/unsafe.html">Unsafe 代码</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<p>注释以 <code>#</code> 开始，持续一行。</p>
<p>目前只支持单行注释。</p>
<pre><code class="language-crystal"># 这是注释
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量"><a class="header" href="#字面量">字面量</a></h1>
<p>Crystal 为创建基本类型的创建都提供了多种字面量。</p>
<div class="table-wrapper"><table><thead><tr><th>字面量</th><th>示例</th></tr></thead><tbody>
<tr><td><a href="syntax_and_semantics/./literals/nil.html">Nil</a></td><td><code>nil</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/bool.html">布尔值</a></td><td><code>true</code>, <code>false</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/integers.html">整数</a></td><td><code>18</code>, <code>-12</code>, <code>19_i64</code>, <code>14_u32</code>,<code>64_u8</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/floats.html">浮点数</a></td><td><code>1.0</code>, <code>1.0_f32</code>, <code>1e10</code>, <code>-0.5</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/char.html">字符</a></td><td><code>'a'</code>, <code>'\n'</code>, <code>'あ'</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/string.html">字符串</a></td><td><code>&quot;foo\tbar&quot;</code>, <code>%(&quot;あ&quot;)</code>, <code>%q(foo #{foo})</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/symbol.html">符号</a></td><td><code>:symbol</code>, <code>:&quot;foo bar&quot;</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/array.html">数组</a></td><td><code>[1, 2, 3]</code>, <code>[1, 2, 3] of Int32</code>, <code>%w(one two three)</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/array.html#array-like-type-literal">数组型变量</a></td><td><code>Set{1, 2, 3}</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/hash.html">散列</a></td><td><code>{&quot;foo&quot; =&gt; 2}</code>, <code>{} of String =&gt; Int32</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/hash.html#hash-like-type-literal">散列型变量</a></td><td><code>MyType{&quot;foo&quot; =&gt; &quot;bar&quot;}</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/range.html">范围</a></td><td><code>1..9</code>, <code>1...10</code>, <code>0..var</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/regex.html">正则表达式</a></td><td><code>/(foo)?bar/</code>, <code>/foo #{foo}/imx</code>, <code>%r(foo/)</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/tuple.html">元组</a></td><td><code>{1, &quot;hello&quot;, 'x'}</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/named_tuple.html">命名元组</a></td><td><code>{name: &quot;Crystal&quot;, year: 2011}</code>, <code>{&quot;this is a key&quot;: 1}</code></td></tr>
<tr><td><a href="syntax_and_semantics/./literals/proc.html">闭包(Proc)</a></td><td><code>-&gt;(x : Int32, y : Int32) { x + y }</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="nil"><a class="header" href="#nil">Nil</a></h1>
<p><a href="http://crystal-lang.org/api/Nil.html">Nil</a> 表示没有一个值， 类似于其他语言的 <code>null</code>。它只有一个值：</p>
<pre><code class="language-crystal">nil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔值bool"><a class="header" href="#布尔值bool">布尔值(Bool)</a></h1>
<p><a href="http://crystal-lang.org/api/Bool.html">Bool</a> 只可能有两个值： <code>true</code> 或 <code>false</code>。它们以如下的字面量构建：</p>
<pre><code class="language-crystal">true  # Bool 代表 true
false # Bool 代表 false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数integer"><a class="header" href="#整数integer">整数(Integer)</a></h1>
<p>整数有四种有符号类型，和四种无符号类型：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th style="text-align: right">长度</th><th style="text-align: right">最小值</th><th style="text-align: right">最大值</th></tr></thead><tbody>
<tr><td><a href="http://crystal-lang.org/api/Int8.html">Int8</a></td><td style="text-align: right">8</td><td style="text-align: right">-128</td><td style="text-align: right">127</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int16.html">Int16</a></td><td style="text-align: right">16</td><td style="text-align: right">−32,768</td><td style="text-align: right">32,767</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int32.html">Int32</a></td><td style="text-align: right">32</td><td style="text-align: right">−2,147,483,648</td><td style="text-align: right">2,147,483,647</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int64.html">Int64</a></td><td style="text-align: right">64</td><td style="text-align: right">−2<sup>63</sup></td><td style="text-align: right">2<sup>63</sup> - 1</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt8.html">UInt8</a></td><td style="text-align: right">8</td><td style="text-align: right">0</td><td style="text-align: right">255</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt16.html">UInt16</a></td><td style="text-align: right">16</td><td style="text-align: right">0</td><td style="text-align: right">65,535</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt32.html">UInt32</a></td><td style="text-align: right">32</td><td style="text-align: right">0</td><td style="text-align: right">4,294,967,295</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt64.html">UInt64</a></td><td style="text-align: right">64</td><td style="text-align: right">0</td><td style="text-align: right">2<sup>64</sup> - 1</td></tr>
</tbody></table>
</div>
<p>一个整数字面量由可选的 <code>+</code> 或 <code>-</code> 符号加上数字和下划线的序列构成，后面可以有后缀。</p>
<p>如果没有后缀，整数的类型就是 <code>Int32</code>， <code>Int64</code> 和 <code>UInt64</code> 之中能装下它的最小的一个：</p>
<pre><code class="language-crystal">1      # Int32

1_i8   # Int8
1_i16  # Int16
1_i32  # Int32
1_i64  # Int64

1_u8   # UInt8
1_u16  # UInt16
1_u32  # UInt32
1_u64  # UInt64

+10    # Int32
-20    # Int32

2147483648          # Int64
9223372036854775808 # UInt64
</code></pre>
<p>后缀之前的下划线 <code>_</code> 是可选的 。</p>
<p>下划线可以增加可读性：</p>
<pre><code class="language-crystal">1_000_000 # 优于 1000000
</code></pre>
<p>二进制数以 <code>0b</code>开头：</p>
<pre><code class="language-crystal">0b1101 # == 13
</code></pre>
<p>八进制数以 <code>0o</code>开头：</p>
<pre><code class="language-crystal">0o123 # == 83
</code></pre>
<p>十六进制数以 <code>0x</code>开头：</p>
<pre><code class="language-crystal">0xFE012D # == 16646445
0xfe012d # == 16646445
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数floats"><a class="header" href="#浮点数floats">浮点数(Floats)</a></h1>
<p>有两种浮点数, <a href="http://crystal-lang.org/api/Float32.html">Float32</a> 和 <a href="http://crystal-lang.org/api/Float64.html">Float64</a>，分别表示IEEE定义的 <a href="http://en.wikipedia.org/wiki/Single_precision_floating-point_format">binary32</a>
和 <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format">binary64</a>。</p>
<p>浮点数字面量由可选的符号 <code>+</code> 或 <code>-</code> ，接上一系列数字和下划线，接小数点，接数字和下划线，接一个可选的指数后缀，接一个可选的类型后缀构成。
如果没有说明类型，那类型默认为 <code>Float64</code>。</p>
<pre><code class="language-crystal">1.0      # Float64
1.0_f32  # Float32
1_f32    # Float32

1e10     # Float64
1.5e10   # Float64
1.5e-7   # Float64

+1.3     # Float64
-0.5     # Float64
</code></pre>
<p>后缀前的下划线 <code>_</code> 是可选的。</p>
<p>下划线可以增加数字可读性</p>
<pre><code class="language-crystal">1_000_000.111_111 # 功能同 1000000.111111, 但更好读
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符char"><a class="header" href="#字符char">字符(Char)</a></h1>
<p><a href="http://crystal-lang.org/api/Char.html">字符</a> 表示32位<a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> <a href="http://en.wikipedia.org/wiki/Code_point">码点(code point)</a>.</p>
<p>它通常由单引号包住一个UTF-8字符字面量制成.</p>
<pre><code class="language-crystal">'a'
'z'
'0'
'_'
'啊'
'あ'
</code></pre>
<p>反斜杠有特殊功能，它可以表示转义序列，也可以表示一个Unicode码点。</p>
<p>可用的转义序列有：</p>
<pre><code class="language-crystal">'\'' # 单引号
'\\' # 反斜杠
'\a' # 警报
'\b' # 退格
'\e' # 退出键(escape)
'\f' # 换页(form feed)
'\n' # 新行
'\r' # 回车
'\t' # (水平)制表符
'\v' # 垂直制表符
'\uNNNN' # 十六进制表示的Unicode字符
'\u{NNNN...}' # 十六进制表示的Unicode字符
</code></pre>
<p>反斜杠接 <code>u</code> 表示一个Unicode码点。它既可以接正好四个十六进制字符(<code>\u0000</code> to <code>\uFFFF</code>)，也可以接由花括号标注的1-6个字符十六进制字符(<code>\u{0}</code> to <code>\u{10FFFF}</code>)。 </p>
<pre><code class="language-crystal">'\u0041' # =&gt; 'A'
'\u{41}' # =&gt; 'A'
'\u{1F52E}' # =&gt; '&amp;#x1F52E;'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串string"><a class="header" href="#字符串string">字符串(String)</a></h1>
<p><a href="http://crystal-lang.org/api/String.html">字符串</a> 代表一列不可更改的UTF-8字符。</p>
<p>字符串通常以双引号(<code>&quot;</code>)包括的字符串字面量构建：</p>
<pre><code class="language-crystal">&quot;hello world&quot;
</code></pre>
<h2 id="转义"><a class="header" href="#转义">转义</a></h2>
<p>反斜杠有特殊功能，它可以表示转义序列，也可以表示一个Unicode码点。</p>
<p>可用的转义序列有：</p>
<pre><code class="language-crystal">'\'' # 单引号
'\\' # 反斜杠
'\a' # 警报
'\b' # 退格
'\e' # 退出键(escape)
'\f' # 换页(form feed)
'\n' # 新行
'\r' # 回车
'\t' # (水平)制表符
'\v' # 垂直制表符
&quot;\NNN&quot; # 八进制ASCII字符
&quot;\xNN&quot; # 十六进制ASCII字符
'\uNNNN' # 十六进制表示的Unicode字符
'\u{NNNN...}' # 十六进制表示的Unicode字符
</code></pre>
<p>反斜杠接其他任何字符都表示源字符。</p>
<p>反斜杠接最多三个个从 0 到 7 的数，表示一个八进制格式的码点：</p>
<pre><code class="language-crystal">&quot;\101&quot; # =&gt; &quot;A&quot;
&quot;\123&quot; # =&gt; &quot;S&quot;
&quot;\12&quot;  # =&gt; &quot;\n&quot;
&quot;\1&quot;   # 只有一个码点为 1 的字符的字符串
</code></pre>
<p>反斜杠接 <code>u</code> 表示一个Unicode码点。它既可以接正好四个十六进制字符(<code>\u0000</code> to <code>\uFFFF</code>)，也可以接由花括号标注的1-6个字符十六进制字符(<code>\u{0}</code> to <code>\u{10FFFF}</code>)。 </p>
<pre><code class="language-crystal">&quot;\u0041&quot;    # =&gt; &quot;A&quot;
&quot;\u{41}&quot;    # =&gt; &quot;A&quot;
&quot;\u{1F52E}&quot; # =&gt; &quot;&amp;#x1F52E;&quot;
</code></pre>
<p>只有大括号可以包含多个Unicode字符。字符之间用空白字符分隔。</p>
<pre><code class="language-crystal">&quot;\u{48 45 4C 4C 4F}&quot; # =&gt; &quot;HELLO&quot;
</code></pre>
<h2 id="插值"><a class="header" href="#插值">插值</a></h2>
<p>字符串字面量可以使用插值表达式来在运行时展开。</p>
<pre><code class="language-crystal">a = 1
b = 2
&quot;sum: #{a} + #{b} = #{a + b}&quot; # =&gt; &quot;sum: 1 + 2 = 3&quot;
</code></pre>
<p>字符串插值也可以用 <a href="https://crystal-lang.org/api/master/String.html#%25(other)-instance-method">String#%</a>完成。</p>
<p>插值部分可以放任何表达式，但是为了可读性，表达式最好小一些。</p>
<p>可以转义 <code>#</code> 号以取消插值，或是使用没有插值的字符串，比如 <code>%q()</code>。</p>
<pre><code class="language-crystal">&quot;\#{a + b}&quot;  # =&gt; &quot;#{a + b}&quot;
%q(#{a + b}) # =&gt; &quot;#{a + b}&quot;
</code></pre>
<p>插值是通过 创建<a href="http://crystal-lang.org/api/String/Builder.html">String::Builder</a> 和对每个插入 <code>#{...}</code>中的表达式调用<code>Object#to_s(IO)</code>来完成的。表达式 <code>&quot;sum: #{a} + #{b} = #{a + b}&quot;</code> 等价于：</p>
<pre><code class="language-crystal">String.build do |io|
  io &lt;&lt; &quot;sum: &quot;
  io &lt;&lt; a
  io &lt;&lt; &quot; + &quot;
  io &lt;&lt; b
  io &lt;&lt; &quot; = &quot;
  io &lt;&lt; a + b
end
</code></pre>
<h1 id="百分号字符串字面量"><a class="header" href="#百分号字符串字面量">百分号字符串字面量</a></h1>
<p>除了双引号形式的字符串，Crystal也支持百分号 (<code>%</code>)接一对分隔符构成的字面量.可用的分隔符是圆括号<code>()</code>，方括号 <code>[]</code>，花括号<code>{}</code>，尖括号  <code>&lt;&gt;</code>和竖杠。除了竖杠，其他的分隔符都可以嵌套，在内部如同普通的字符。</p>
<p>这个在写包含双引号的字符串时很有用，你不用手动转义每个双引号了。</p>
<pre><code class="language-crystal">%(hello (&quot;world&quot;)) # =&gt; &quot;hello (\&quot;world\&quot;)&quot;
%[hello [&quot;world&quot;]] # =&gt; &quot;hello [\&quot;world\&quot;]&quot;
%{hello {&quot;world&quot;}} # =&gt; &quot;hello {\&quot;world\&quot;}&quot;
%&lt;hello &lt;&quot;world&quot;&gt;&gt; # =&gt; &quot;hello &lt;\&quot;world\&quot;&gt;&quot;
%|hello &quot;world&quot;|   # =&gt; &quot;hello \&quot;world\&quot;&quot;
</code></pre>
<p><code>%q</code> 开头的字面量不接受转义或插值，而 <code>%Q</code>的意思等同于 <code>%</code>.</p>
<pre><code class="language-crystal">name = &quot;world&quot;
%q(hello \n #{name}) # =&gt; &quot;hello \\n \#{name}&quot;
%Q(hello \n #{name}) # =&gt; &quot;hello \n world&quot;
</code></pre>
<h2 id="多行字符串"><a class="header" href="#多行字符串">多行字符串</a></h2>
<p>任何一个字面量都可以跨多行：</p>
<pre><code class="language-crystal">&quot;hello
      world&quot; # =&gt; &quot;hello\n      world&quot;
</code></pre>
<p>注意，在上面的例子里面尾随或前置的空格，新行，也在结果的字符串里面。你可以设多个字符串，然后用反斜杠连接：</p>
<pre><code class="language-crystal">&quot;hello &quot; \
&quot;world, &quot; \
&quot;no newlines&quot; # 等同于 &quot;hello world, no newlines&quot;
</code></pre>
<p>另外，一个反斜杠接新行可以在字符串里取消新行。</p>
<pre><code class="language-crystal">&quot;hello \
     world, \
     no newlines&quot; # 等同于 &quot;hello world, no newlines&quot;
</code></pre>
<p>此时前置的空白符号不算在字符串中。</p>
<h2 id="立即文档heredoc"><a class="header" href="#立即文档heredoc">立即文档(Heredoc)</a></h2>
<p>一个 <em>立即文档</em> (英文为<em>heredoc</em>) 用于创建涉及多行的字符串时很有用。立即文档以 <code>&lt;&lt;-</code> 一个标识符(包含字母,数字,下划线)起头,正文从下一行开始,到看到开头的那个标识符时结尾，忽略新行和其他的空白字符。</p>
<pre><code class="language-crystal">&lt;&lt;-XML
&lt;parent&gt;
  &lt;child /&gt;
&lt;/parent&gt;
XML
</code></pre>
<p>空白字符会根据末尾标识符出现的位置进行剪裁，裁掉标识符之前的部分。</p>
<pre><code class="language-crystal">&lt;&lt;-STRING
  Hello
    world
  STRING # =&gt; &quot;Hello\n  world&quot;

&lt;&lt;-STRING
    Hello
      world
  STRING # =&gt; &quot;  Hello\n    world&quot;
</code></pre>
<p>可以直接调用立即文档的方法(因为他也是一个字符串)，也可以在括号内使用它。</p>
<pre><code class="language-crystal">&lt;&lt;-SOME
hello
SOME.upcase # =&gt; &quot;HELLO&quot;

def upcase(string)
  string.upcase
end

upcase(&lt;&lt;-SOME
  hello
  SOME) # =&gt; &quot;HELLO&quot;
</code></pre>
<p>立即文档通常允许插值和转义。</p>
<p>可以通过在开头对标识符加单引号来禁止转义：</p>
<pre><code class="language-crystal">&lt;&lt;-'HERE'
  hello \n #{world}
  HERE # =&gt; &quot;hello \n #{world}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="符号symbol"><a class="header" href="#符号symbol">符号(Symbol)</a></h1>
<p><a href="http://crystal-lang.org/api/Symbol.html">符号</a> 表示整个源代码中独一无二的名字。</p>
<p>符号在编译时被处理，不能被动态创建。唯一能创建符号的方法是符号字面量，其以冒号(<code>:</code>)开头，接一个标识符。标识符可以用双引号(<code>&quot;</code>)包括。</p>
<pre><code class="language-crystal">:unquoted_symbol
:&quot;quoted symbol&quot;
:&quot;a&quot; # identical to :a
</code></pre>
<p>用双引号包括的字面量可以包含任意Unicode字符，转义类似于<a href="syntax_and_semantics/literals/./string.html">字符串字面量</a>，但没有插值。</p>
<p>没有引号的标识符命名规则类似于方法。它可以含有数字下划线，或是码点大于<code>159</code>(<code>0x9F</code>)的字符。它不能以数字开头，但可以以感叹号(<code>!</code>)或问号(<code>?</code>)结尾。 </p>
<pre><code class="language-crystal">:question?
:exclamation!
</code></pre>
<p>所有的<a href="syntax_and_semantics/literals/../operators.html">Crystal运算符</a>可以不加引号地制成符号：</p>
<pre><code class="language-crystal">:+
:-
:*
:/
:%
:&amp;
:|
:^
:**
:&gt;&gt;
:&lt;&lt;
:==
:!=
:&lt;
:&lt;=
:&gt;
:&gt;=
:&lt;=&gt;
:===
:[]
:[]?
:[]=
:!
:~
:!~
:=~
</code></pre>
<p>在内部，符号被解析成 <code>Int32</code>类型的数字。</p>
<h2 id="百分号符号数组字面量"><a class="header" href="#百分号符号数组字面量">百分号符号数组字面量</a></h2>
<p>除了单独的符号字面量，还有可以创建符号 <a href="https://crystal-lang.org/api/Array.html">数组</a>的百分号字面量。它以 <code>%i</code> 开头，接一对分隔符。
可用的分隔符是圆括号<code>()</code>，方括号 <code>[]</code>，花括号<code>{}</code>，尖括号  <code>&lt;&gt;</code>和竖杠。除了竖杠，其他的分隔符都可以嵌套，在内部如同普通的字符。</p>
<pre><code class="language-crystal">%i(foo bar baz) # =&gt; [:foo, :bar, :baz]
%i(foo\nbar baz) # =&gt; [:&quot;foo\nbar&quot;, :baz]
%i(foo(bar) baz) # =&gt; [:&quot;foo(bar)&quot;, :baz]
</code></pre>
<p>标识符可以含有Unicode字符。如果一个标识符内部有空格(<code> </code>)，那么它必须转义，否则会把标识符切开。</p>
<pre><code class="language-crystal">%i(foo\ bar baz) # =&gt; [:&quot;foo bar&quot;, :baz]
%i(foo bar baz)  # =&gt; [:foo, :bar, :baz]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组array"><a class="header" href="#数组array">数组(Array)</a></h1>
<p>一个 <a href="http://crystal-lang.org/api/Array.html">Array</a> 是可以用整数做索引的一系列<code>T</code>类型的元素。</p>
<p>数组往往以方括号（<code>[]</code>）包含住以逗号（<code>,</code>）分隔的一系列元素。</p>
<pre><code class="language-crystal">[1, 2, 3]
</code></pre>
<h2 id="泛型参数"><a class="header" href="#泛型参数">泛型参数</a></h2>
<p>数组的泛型参数 <code>T</code> 可以从字面量的类型中推出来，如果数组里的所有元素类型都相同，那它就是那个类型。此外,它就是所有元素类型的或。</p>
<pre><code class="language-crystal">[1, 2, 3]          # =&gt; Array(Int32)
[1, &quot;hello&quot;, 'x']  # =&gt; Array(Int32 | String | Char)
</code></pre>
<p>可以用 <code>of</code> 加一个类型做显式类型标注，数组， <code>of</code> 和类型之间都要用空格隔开。这会覆盖自动推导出的类型。数组一开始只有这个类型的元素，但之后可以添加其他类型的元素。</p>
<pre><code class="language-crystal">array_of_numbers = [1, 2, 3] of Number  # =&gt; Array(Number)
array_of_numbers + [0.5]                # =&gt; [1, 2, 3, 0.5]

array_of_int_or_string = [1, 3, 4] of Int32 | String  # =&gt; Array(Int32 | String)
array_of_int_or_string + [&quot;foo&quot;]                      # =&gt; [1, 2, 3, &quot;foo&quot;]
</code></pre>
<p>空数组字面量总是需要类型标注：</p>
<pre><code class="language-crystal">[] of Int32  # =&gt; Array(Int32).new
</code></pre>
<h2 id="百分号数组字面量"><a class="header" href="#百分号数组字面量">百分号数组字面量</a></h2>
<p>[字符串数组](./string.html#Percent String Array Literal) 和 [符号数组](./symbol.html#Percent Symbol Array Literal) 可以用百分号字面量创建：</p>
<pre><code class="language-crystal">%w(one two three)  # =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
%i(one two three)  # =&gt; [:one, :two, :three]
</code></pre>
<h2 id="数组式类型字面量"><a class="header" href="#数组式类型字面量">数组式类型字面量</a></h2>
<p>Crystal对数组和数组型类型有额外的字面量构造方法。他以类型开头，后接大括号(<code>{}</code>)，内部填入以逗号(<code>,</code>)分割的诸元素。</p>
<pre><code class="language-crystal">Array{1, 2, 3}
</code></pre>
<p>这适用于所有有空参构造函数，并且接受 <code>&lt;&lt;</code> 的类型。</p>
<pre><code class="language-crystal">IO::Memory{1, 2, 3}
Set{1, 2, 3}
</code></pre>
<p>对于一个像 <code>IO::Memory</code>这样的非泛型类型，这等价于：</p>
<pre><code class="language-crystal">array_like = IO::Memory.new
array_like &lt;&lt; 1
array_like &lt;&lt; 2
array_like &lt;&lt; 3
</code></pre>
<p>对于一个像 <code>Set</code>这样的泛型，它的类型参数 <code>T</code> 也像数组一样从元素的类型推导而来。上面等价于：</p>
<pre><code class="language-crystal">array_like = Set(typeof(1, 2, 3)).new
array_like &lt;&lt; 1
array_like &lt;&lt; 2
array_like &lt;&lt; 3
</code></pre>
<p>类型参数作为类型名的一部分显式指出：</p>
<pre><code class="language-crystal">Set(Number) {1, 2, 3}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="哈希hash"><a class="header" href="#哈希hash">哈希(Hash)</a></h1>
<p><a href="http://crystal-lang.org/api/Hash.html">哈希</a> 是从键类型<code>K</code>到值类型<code>V</code>的映射的泛型。</p>
<p>构造哈希的最简单方法是哈希字面量。它由大括号(<code>{ }</code>)包含键值对构成，每个键值对是<code>a=&gt;b</code>的形式，中间以逗号<code>,</code>分隔。</p>
<pre><code class="language-crystal">{&quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2}
</code></pre>
<h1 id="泛型参数-1"><a class="header" href="#泛型参数-1">泛型参数</a></h1>
<p>键 <code>K</code> 和值 <code>V</code> 的泛型参数 可以从字面量从元素的类型推导得来，如果键和值的类型分别都相同，那么<code>K</code>/<code>V</code> 就是那个类型。否则它就分别是里面出现过的所有类型的并。</p>
<pre><code class="language-crystal">{1 =&gt; 2, 3 =&gt; 4}     # Hash(Int32, Int32)
{1 =&gt; 2, 'a' =&gt; 3}   # Hash(Int32 | Char, Int32)
</code></pre>
<p>可以用一对空花括号接 <code>of</code> (用空格隔开), 一个类型 (<code>K</code>) 接 <code>=&gt;</code> 接另一个类型 (<code>V</code>)来显式地指明类型. 这会覆盖推断出来的类型。这可以使哈希一开始只有一些一种类型的元素，但后来也可以添加其他类型的元素。</p>
<p>空哈希字面量总是需要类型标注：</p>
<pre><code class="language-crystal">{} of Int32 =&gt; Int32 # =&gt; Hash(Int32, Int32).new
</code></pre>
<h2 id="哈希式类型字面量"><a class="header" href="#哈希式类型字面量">哈希式类型字面量</a></h2>
<p>Crystal 对哈希和类似哈希的类型有字面量支持。它由类型接以花括号(<code>{}</code>)包住的，用逗号分隔的键值对。</p>
<pre><code class="language-crystal">Hash{&quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2}
</code></pre>
<p>这对有空参数构造函数和 <code>[]=</code> 方法的类型都适用。</p>
<pre><code class="language-crystal">HTTP::Headers{&quot;foo&quot; =&gt; &quot;bar&quot;}
</code></pre>
<p>对于 <code>HTTP::Headers</code>这样的非泛型，这等价于：</p>
<pre><code class="language-crystal">headers = HTTP::Headers.new
headers[&quot;foo&quot;] = &quot;bar&quot;
</code></pre>
<p>对于泛型，它其中的类型用类似于哈希字面量的方法推断出来。</p>
<pre><code class="language-crystal">MyHash{&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; &quot;baz&quot;}
</code></pre>
<p>如果 <code>MyHash</code> 是泛型，那么上面的等价于：</p>
<pre><code class="language-crystal">my_hash = MyHash(typeof(&quot;foo&quot;, &quot;bar&quot;), typeof(1, &quot;baz&quot;)).new
my_hash[&quot;foo&quot;] = 1
my_hash[&quot;bar&quot;] = baz
</code></pre>
<p>可以在类型名中显式标注类型参数：</p>
<pre><code class="language-crystal">MyHash(String, String | Int32) {&quot;foo&quot; =&gt; &quot;bar&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="范围range"><a class="header" href="#范围range">范围(Range)</a></h1>
<p><a href="http://crystal-lang.org/api/Range.html">范围</a> 通常以范围字面量构建:</p>
<pre><code class="language-crystal">x..y  # 闭区间, 数学表示为: [x, y]
x...y # 左闭右开区间, 数学表示为: [x, y)
</code></pre>
<p>这样好记一些：多出来的一个点就像把<em>y</em>推得更远，这样它就在范围外面了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正则表达式regular-expressions"><a class="header" href="#正则表达式regular-expressions">正则表达式(Regular Expressions)</a></h1>
<p>正则表达式以 <a href="http://crystal-lang.org/api/Regex.html">Regex</a> 类表示。</p>
<p>正则表达式往往由正则字面量遵循 <a href="http://pcre.org/pcre.txt">PCRE</a>语法构建。它由用正斜杠(<code>/</code>)包含的 UTF-8字符构成：</p>
<pre><code class="language-crystal">/foo|bar/
/h(e+)llo/
/\d+/
/あ/
/啊/
</code></pre>
<h2 id="转义-1"><a class="header" href="#转义-1">转义</a></h2>
<p>正则表达式大转义遵循<a href="syntax_and_semantics/literals/./string.html">字符串字面量的转义</a>.</p>
<pre><code class="language-crystal">'\'' # 单引号
'\\' # 反斜杠
'\a' # 警报
'\b' # 退格
'\e' # 退出键(escape)
'\f' # 换页(form feed)
'\n' # 新行
'\r' # 回车
'\t' # (水平)制表符
'\v' # 垂直制表符
'\uNNNN' # 十六进制表示的Unicode字符
'\u{NNNN...}' # 十六进制表示的Unicode字符
</code></pre>
<p>分隔符 <code>/</code> 在用正斜杠包裹的字符串中也必须转义。
注意：如果PCRE中的特殊字符想要以字面方式使用，那也需要转义。</p>
<h2 id="插值-1"><a class="header" href="#插值-1">插值</a></h2>
<p>正则表达式字面量中的转义如同 <a href="syntax_and_semantics/literals/./string.html">字符串字面量</a>. 注意如果插值得到的字符串不能构成一个正则表达式，那么这会导致运行期异常。</p>
<h2 id="模式设定"><a class="header" href="#模式设定">模式设定</a></h2>
<p>尾部分隔符可以加后缀来改变正则表达式的匹配模式。</p>
<ul>
<li><code>i</code>: 忽略大小写 (<code>PCRE_CASELESS</code>):  Unicode 字母既可以匹配目标中的大写字母，也可以匹配小写字母。</li>
<li><code>m</code>: 多行匹配 (<code>PCRE_MULTILINE</code>): <em>行首</em> (<code>^</code>) 和 <em>行尾</em> (<code>$</code>) 匹配字符串行之间空格的刚开始，或是结束前。</li>
<li><code>x</code>: 扩展空白符号匹配(extended whitespace matching) (<code>PCRE_EXTENDED</code>): 模式里的大多数空白字符都被忽略，除非在另外一个字符类中。不被转义的井号<code>#</code>表示从它开始的一行注释，直到行尾。</li>
</ul>
<blockquote>
<p>译注: 此处原文为 : Most white space characters in the pattern are totally ignored except when ignore or inside a character class. Unescaped hash characters <code>#</code> denote the start of a comment ranging to the end of the line.</p>
</blockquote>
<pre><code class="language-crystal">/foo/i.match(&quot;FOO&quot;)         # =&gt; #&lt;Regex::MatchData &quot;FOO&quot;&gt;
/foo/m.match(&quot;bar\nfoo&quot;)    # =&gt; #&lt;Regex::MatchData &quot;foo&quot;&gt;
/foo /x.match(&quot;foo&quot;)        # =&gt; #&lt;Regex::MatchData &quot;foo&quot;&gt;
/foo /imx.match(&quot;bar\nFOO&quot;) # =&gt; #&lt;Regex::MatchData &quot;FOO&quot;&gt;
</code></pre>
<h2 id="百分号正则字面量"><a class="header" href="#百分号正则字面量">百分号正则字面量</a></h2>
<p>除了斜杠字面量,正则表达式还可以以 <code>%r</code> 接一对分隔符的方式构建。可用的分隔符是圆括号 <code>()</code>，方括号 <code>[]</code>，花括号 <code>{}</code>，尖括号 <code>&lt;&gt;</code>和竖杠 <code>||</code>. 除了竖杠，其他的分隔符都可以嵌套。</p>
<p>它们对于写包含正斜杠的正则表达式很有用。</p>
<pre><code class="language-crystal">%r((/)) # =&gt; /(\/)/
%r[[/]] # =&gt; /[\/]/
%r{{/}} # =&gt; /{\/}/
%r&lt;&lt;/&gt;&gt; # =&gt; /&lt;\/&gt;/
%r|/|   # =&gt; /\//
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组tuple"><a class="header" href="#元组tuple">元组(Tuple)</a></h1>
<p><a href="http://crystal-lang.org/api/Tuple.html">元组</a> 通常以元组字面量创建：</p>
<pre><code class="language-crystal">tuple = {1, &quot;hello&quot;, 'x'} # Tuple(Int32, String, Char)
tuple[0]                  #=&gt; 1       (Int32)
tuple[1]                  #=&gt; &quot;hello&quot; (String)
tuple[2]                  #=&gt; 'x'     (Char)
</code></pre>
<p><a href="http://crystal-lang.org/api/Tuple.html#new%28%2Aargs%29-class-method">Tuple.new</a>可以创建空元组。</p>
<p>以下方法可以声明一个元组类型：</p>
<pre><code class="language-crystal"># 这表示包含 Int32, String 和 Char 的元组。
Tuple(Int32, String, Char)
</code></pre>
<p>在类型声明，泛型参数和其他需要类型的地方，你可以用简便的语法，详见<a href="syntax_and_semantics/literals/../type_grammar.html">类型语法</a>:</p>
<pre><code class="language-crystal"># An array of tuples of Int32, String and Char
Array({Int32, String, Char})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名元组namedtuple"><a class="header" href="#命名元组namedtuple">命名元组(NamedTuple)</a></h1>
<p><a href="http://crystal-lang.org/api/NamedTuple.html">命名元组</a>往往由元组字面量产生：</p>
<pre><code class="language-crystal">tuple = {name: &quot;Crystal&quot;, year: 2011} # NamedTuple(name: String, year: Int32)
tuple[:name] # =&gt; &quot;Crystal&quot; (String)
tuple[:year] # =&gt; 2011      (Int32)
</code></pre>
<p>可以用如下方法声明一个命名元组：</p>
<pre><code class="language-crystal"># 这个表示命名元组 x: Int32, y: String 的类型：
NamedTuple(x: Int32, y: String)
</code></pre>
<p>在类型限制，泛型参数或其他需要类型的地方，你可以用更简短的语法，见<a href="syntax_and_semantics/literals/../type_grammar.html">类型语法</a>:</p>
<pre><code class="language-crystal"># 元组 {x: Int32, y: String}构成的数组
Array({x: Int32, y: String})
</code></pre>
<p>元组的键也可以是字符串字面量:</p>
<pre><code class="language-crystal">{&quot;这是键&quot;: 1}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包proc"><a class="header" href="#闭包proc">闭包(Proc)</a></h1>
<p><a href="http://crystal-lang.org/api/Proc.html">闭包</a> 表示带有可选上下文的函数指针，通常以闭包字面量构造：</p>
<pre><code class="language-crystal"># 无参数闭包
-&gt;{ 1 } # Proc(Int32)

# 有一个参数的闭包
-&gt;(x : Int32) { x.to_s } # Proc(Int32, String)

# 有两个参数的闭包
-&gt;(x : Int32, y : Int32) { x + y } # Proc(Int32, Int32, Int32)
</code></pre>
<p>参数的类型是必须的，除非把闭包字面量直接送给C绑定中的一个库 <code>fun</code>。</p>
<p>返回值可以从闭包体推断出来。</p>
<p>另外，闭包还有一个 <code>new</code>方法：</p>
<pre><code class="language-crystal">Proc(Int32, String).new { |x| x.to_s } # Proc(Int32, String)
</code></pre>
<p>这可以直接指定返回值，并且和闭包体的返回值比对。</p>
<h2 id="闭包类型"><a class="header" href="#闭包类型">闭包类型</a></h2>
<p>你可以这样声明一个闭包类型：</p>
<pre><code class="language-crystal"># 闭包接受一个 Int32 参数，返回一个 String
Proc(Int32, String)

# 闭包不接收参数，返回 Void
Proc(Void)

# 闭包接受两个参数 (一个 Int32 和一个 String) ，返回一个 Char
Proc(Int32, String, Char)
</code></pre>
<p>在类型限制，泛型参数和其他需要类型的地方，你可以用一个简短的语法，详见<a href="syntax_and_semantics/literals/../type_grammar.html">类型</a>:</p>
<pre><code class="language-crystal"># 一个由 Proc(Int32, String, Char)构成的 Array :
Array(Int32, String -&gt; Char)
</code></pre>
<h2 id="调用"><a class="header" href="#调用">调用</a></h2>
<p>你可以用 <code>call</code>方法调用闭包参数的个数必须匹配闭包的类型：</p>
<pre><code class="language-crystal">proc = -&gt;(x : Int32, y : Int32) { x + y }
proc.call(1, 2) #=&gt; 3
</code></pre>
<h2 id="从方法构造闭包"><a class="header" href="#从方法构造闭包">从方法构造闭包</a></h2>
<p>闭包可以从已有的方法构造：</p>
<pre><code class="language-crystal">def one
  1
end

proc = -&gt;one
proc.call #=&gt; 1
</code></pre>
<p>如果方法有参数，你必须确定它们的类型：</p>
<pre><code class="language-crystal">def plus_one(x)
  x + 1
end

proc = -&gt;plus_one(Int32)
proc.call(41) #=&gt; 42
</code></pre>
<p>闭包可以可选地指定一个方法接受者：</p>
<pre><code class="language-crystal">str = &quot;hello&quot;
proc = -&gt;str.count(Char)
proc.call('e') #=&gt; 1
proc.call('l') #=&gt; 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令字面量"><a class="header" href="#命令字面量">命令字面量</a></h1>
<p>命令字面量是一个以反引号 <code>`</code> 或百分号式字面量 <code>%x</code> 包裹的字符串。在运行时，程序在一个子终端中运行此命令，表示运行结果的字符串即为命令字面量的值。</p>
<p>命令和常规字符串一样进行<a href="syntax_and_semantics/literals/string.html#%E8%BD%AC%E4%B9%89">转义</a>和<a href="syntax_and_semantics/literals/string.html#%E6%8F%92%E5%80%BC">插值</a>。</p>
<p>类似于字符串字面量， <code>%x</code> 可用的分隔符是括号 <code>()</code>，方括号 <code>[]</code>，花括号 <code>{}</code>, 尖括号 <code>&lt;&gt;</code> 和竖杠 <code>||</code>。除了竖杠，所有的分隔符都可以嵌套，每个始分隔符转义最近的一个终分隔符。</p>
<p>特殊变量 <code>$?</code> 以 <code>Process::Status</code> 类型保留了命令的执行结果。它只在该字面量的同一个作用域有效。</p>
<pre><code class="language-crystal">`echo foo`  # =&gt; &quot;foo&quot;
$?.success? # =&gt; true
</code></pre>
<p>在内部，编译器会将命令字面量转换为一次对顶层方法 的调用，参数即为命令字符串的内容。<code>echo #{argument}</code> 和 <code>%x(echo #{argument})</code> 被重写为 <code> `(&quot;echo #{argument}&quot;)</code>。</p>
<h2 id="安全问题"><a class="header" href="#安全问题">安全问题</a></h2>
<p>命令行字面量用于脚本程序非常方便，但是使用时应注意检查用户输入，因为它容易导致命令注入：</p>
<pre><code class="language-crystal">user_input = &quot;hello; rm -rf *&quot;
`echo #{user_input}`
</code></pre>
<p>这个命令会写调用<code>hello</code>，然后删除当前工作目录下的所有文件。</p>
<p>为了避免这种情况,最好不要让用户命令字符串中插值.标准库的 <code>Process</code> 提供了一种将用户输入用于命令行参数的安全做法：</p>
<pre><code class="language-crystal">user_input = &quot;hello; rm -rf *&quot;
process = Process.new(&quot;echo&quot;, [user_input], output: Process::Redirect::Pipe)
process.output.gets_to_end # =&gt; &quot;hello; rm -rf *&quot;
process.wait.success?      # =&gt; true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="赋值"><a class="header" href="#赋值">赋值</a></h1>
<p>等号 (<code>=</code>) 表示赋值操作。</p>
<pre><code class="language-crystal"># 向局部变量赋值
local = 1

# 向实例变量赋值
@instance = 2

# 向类变量赋值
@@class = 3
</code></pre>
<p>上述三种赋值操作将随后解释。</p>
<p>有一些包含 <code>=</code>的语法糖也可用于赋值：</p>
<pre><code class="language-crystal">local += 1  # 等同于: local = local + 1

# 上述操作可用于这些运算符：
# +, -, *, /, %, |, &amp;, ^, **, &lt;&lt;, &gt;&gt;

local ||= 1 # 等同于: local || (local = 1)
local &amp;&amp;= 1 # 等同于: local &amp;&amp; (local = 1)
</code></pre>
<p>以 <code>=</code>结尾的方法有语法糖：</p>
<pre><code class="language-crystal"># setter
person.name=(&quot;John&quot;)

# 上式等同于：
person.name = &quot;John&quot;

# 下标寻址加赋值
objects.[]=(2, 3)

# 上式等同于：
objects[2] = 3

# 并不是赋值，但也有语法糖
objects.[](2, 3)

# 上式等同于：
objects[2, 3]
</code></pre>
<p><code>=</code> 运算符对设置和索引操作也有语法糖。注意， <code>||</code> 和 <code>&amp;&amp;</code> 使用 <code>[]?</code> 方法检查键是否存在。</p>
<pre><code class="language-crystal">person.age += 1        # 等同于: person.age = person.age + 1

person.name ||= &quot;John&quot; # 等同于: person.name || (person.name = &quot;John&quot;)
person.name &amp;&amp;= &quot;John&quot; # 等同于: person.name &amp;&amp; (person.name = &quot;John&quot;)

objects[1] += 2        # 等同于: objects[1] = objects[1] + 2

objects[1] ||= 2       # 等同于: objects[1]? || (objects[1] = 2)
objects[1] &amp;&amp;= 2       # 等同于: objects[1]? &amp;&amp; (objects[1] = 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多重赋值"><a class="header" href="#多重赋值">多重赋值</a></h1>
<p>可以通过用逗号(<code>,</code>) 分隔的一系列表达式进行多重声明/赋值：</p>
<pre><code class="language-crystal">name, age = &quot;Crystal&quot;, 1

# 上式等同于:
temp1 = &quot;Crystal&quot;
temp2 = 1
name  = temp1
age   = temp2
</code></pre>
<p>注意，因为表达式会被赋值给临时变量，你可以通过这种方式在一行内交换两个变量的值：</p>
<pre><code class="language-crystal">a = 1
b = 2
a, b = b, a
a #=&gt; 2
b #=&gt; 1
</code></pre>
<p>如果右边只有一个表达式，它会被认为是一个可索引的类型，因此有如下语法糖：</p>
<pre><code class="language-crystal">name, age, source = &quot;Crystal,1,github&quot;.split(&quot;,&quot;)

# 上式等同于:
temp = &quot;Crystal,1,github&quot;.split(&quot;,&quot;)
name   = temp[0]
age    = temp[1]
source = temp[2]
</code></pre>
<p>以 <code>=</code>结尾的方法也可以用于多重赋值：</p>
<pre><code class="language-crystal">person.name, person.age = &quot;John&quot;, 32

# 等同于:
temp1 = &quot;John&quot;
temp2 = 32
person.name = temp1
person.age = temp2
</code></pre>
<p>索引操作也同样适用 (<code>[]=</code>)：</p>
<pre><code class="language-crystal">objects[1], objects[2] = 3, 4

# 等同于:
temp1 = 3
temp2 = 4
objects[1] = temp1
objects[2] = temp2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="局部变量"><a class="header" href="#局部变量">局部变量</a></h1>
<p>局部变量以小写字母开头。它们当你第一次赋值一个变量时被声明。</p>
<pre><code class="language-crystal">name = &quot;Crystal&quot;
age = 1
</code></pre>
<p>局部变量的类型由它们的用法推导而来，而不只是由于初始化它的表达式。 一般来说，它们只是存放值的位置，而值的类型根据位置和用法，可以适当地变化。</p>
<p>比如，对一个变量重新赋值可以让他有新表达式的类型：</p>
<pre><code class="language-crystal">flower = &quot;Tulip&quot;
# 此时 'flower' 是 String

flower = 1
# 此时 'flower' 是 Int32
</code></pre>
<p>下划线开头的名字是合法的，但是它们被留给编译器做其他用途，因此不推荐使用(况且它们把代码变的更丑)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制结构"><a class="header" href="#控制结构">控制结构</a></h1>
<p>讨论控制结构之前,我要搞清楚<em>真</em>和<em>假</em>值的含义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="真值和假值"><a class="header" href="#真值和假值">真值和假值</a></h1>
<p><em>真</em>值是被<code>if</code>, <code>unless</code>, <code>while</code> or <code>until</code>等表达式认为真的值。 <em>假</em> 值是在这些地方被认为假的值。</p>
<p>仅有的假值是 <code>nil</code>, <code>false</code> 和空指针 (指向地址零的指针)。其他所有的值都是真的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">if</a></h1>
<p><code>if</code> 当条件是<em>真的</em> 时，求值给定的分支。否则，就求值<code>else</code>分支(如果有)。</p>
<pre><code class="language-crystal">a = 1
if a &gt; 0
  a = 10
end
a #=&gt; 10

b = 1
if b &gt; 2
  b = 10
else
  b = 20
end
b #=&gt; 20
</code></pre>
<p><code>elsif</code>表示 if-else-if 长链：</p>
<pre><code class="language-crystal">if 某个条件
  做某事
elsif 另一个条件
  做另一些事
else
  其他事
end
</code></pre>
<p><code>if</code>之后，一个表达式的类型是他在所有分支中出现的类型之联合。</p>
<pre><code class="language-crystal">a = 1
if 某个条件
  a = &quot;hello&quot;
else
  a = true
end
# a : String | Bool

b = 1
if 某个条件
  b = &quot;hello&quot;
end
# b : Int32 | String

if 某个条件
  c = 1
else
  c = &quot;hello&quot;
end
# c : Int32 | String

if 某个条件
  d = 1
end
# d : Int32 | Nil
</code></pre>
<p>注意如果表达式在一个分支中声明，而在另一个分支中没有声明，那么 <code>if</code> 之后他会包含 <code>Nil</code>类型。</p>
<p><code>if</code>外已有的变量如果在<code>if</code>的一个分支中被赋予其他的类型的值，那么他在<code>if</code>后就可能是新的类型：</p>
<pre><code class="language-crystal">a = 1
if 某个条件
  a = &quot;hello&quot;
  # a : String
  a.size
end
# a : String | Int32
</code></pre>
<p>即，表达式的类型是最后一次赋值的变量的类型。</p>
<p>如果一个分支包含 <code>return</code>， <code>next</code>， <code>break</code> 或 <code>raise</code>， 即它绝对不会到达 <code>if</code>的结尾，该分支中的赋值就不会影响 <code>if</code>后面的变量：</p>
<pre><code class="language-crystal">if 某个条件
  e = 1
else
  e = &quot;hello&quot;
  # e : String
  return
end
# e : Int32
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作为后缀"><a class="header" href="#作为后缀">作为后缀</a></h1>
<p><code>if</code> 可以写在表达式后，作为后缀：</p>
<pre><code class="language-crystal">a = 2 if 某些条件

# 上式等同于：
if 某些条件
  a = 2
end
</code></pre>
<p>有时这会使代码看起来自然。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作为表达式"><a class="header" href="#作为表达式">作为表达式</a></h1>
<p><code>if</code> 的值是每一个分支的最后一个表达式的值：</p>
<pre><code class="language-crystal">a = if 2 &gt; 1
      3
    else
      4
    end
a #=&gt; 3
</code></pre>
<p>如果 <code>if</code> 的一个分支是空的，或没有这个分支，那这个分支的值默认是 <code>nil</code>：</p>
<pre><code class="language-crystal">if 1 &gt; 2
  3
end

# 上式等同于：
if 1 &gt; 2
  3
else
  nil
end

# 另一个例子
if 1 &gt; 2
else
  3
end

# 上式等同于：
if 1 &gt; 2
  nil
else
  3
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三元-if-表达式"><a class="header" href="#三元-if-表达式">三元 <code>if</code> 表达式</a></h1>
<p>三元 <code>if</code> 表达式可以用更短的方式表示<code>if</code>结构：</p>
<pre><code class="language-crystal">a = 1 &gt; 2 ? 3 : 4

# 上式等同于:
a = if 1 &gt; 2
      3
    else
      4
    end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-变量"><a class="header" href="#if-变量">if 变量</a></h1>
<p>如果一个变量被用作 <code>if</code> 的条件，那么在 <code>then</code>分支内他会被认为不可能是 <code>Nil</code>类型：</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
# a is Int32 or Nil

if a
  # 既然我们只能通过 a 为真一种方式到达这里,
  # a 就不能是. 所以在此， a 是 Int32.
  a.abs
end
</code></pre>
<p>同样的思维用于当一个值在if表达式中被赋值时：</p>
<pre><code class="language-crystal">if a = some_expression
  # 此处 a 不会是 nil
end
</code></pre>
<p>逻辑与运算符(<code>&amp;&amp;</code>)也适用此规律： </p>
<pre><code class="language-crystal">if a &amp;&amp; b
  # 这里 a 和 b 保证都不是 Nil
end
</code></pre>
<p>这里， <code>&amp;&amp;</code> 表达式右边的 <code>b</code> 也保证不是 <code>Nil</code>。</p>
<p>当然，在 <code>then</code> 分支重赋值变量会导致变量有新的类型。</p>
<h2 id="限制"><a class="header" href="#限制">限制</a></h2>
<p>这个逻辑 <strong>不适用于</strong> 成员变量，类变量和其他在闭包中绑定的变量。这些变量的值有可能在条件判断之后又被另外的纤程修改，导致它变成 <code>nil</code>。</p>
<pre><code class="language-crystal">if @a
  # 此处 `@a` 可以是 nil
end

if @@a
  # 此处 `@@a` 可以是 nil
end

a = nil
closure = -&gt;(){ foo = &quot;foo&quot; } # 这个闭包绑定了前面所有的变量，包括 a

if a
  # 此处 `a` 可以是 nil
end
</code></pre>
<p>This can be circumvented by assigning the value to a new local variable:</p>
<pre><code class="language-crystal">if a = @a
  # here `a` can't be nil
end
</code></pre>
<p>Another option is to use <a href="https://crystal-lang.org/api/Object.html#try%28%26block%29-instance-method"><code>Object#try</code></a> found in the standard library which only executes the block if the value is not <code>nil</code>:</p>
<pre><code class="language-crystal">@a.try do |a|
  # here `a` can't be nil
end
</code></pre>
<h2 id="method-calls"><a class="header" href="#method-calls">Method calls</a></h2>
<p>That logic also doesn't work with proc and method calls, including getters and properties, because nilable (or, more generally, union-typed) procs and methods aren't guaranteed to return the same more-specific type on two successive calls.</p>
<pre><code class="language-crystal">if method # first call to a method that can return Int32 or Nil
          # here we know that the first call did not return Nil
  method  # second call can still return Int32 or Nil
end
</code></pre>
<p>The techniques described above for instance variables will also work for proc and method calls.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-varis_a"><a class="header" href="#if-varis_a">if var.is_a?(...)</a></h1>
<p>如果 <code>if</code>的条件是 <code>is_a?</code> 测试，那<code>then</code>分支中该表达式就确定是这个类型。 </p>
<pre><code class="language-crystal">if a.is_a?(String)
  # 此处 a 是 String
end

if b.is_a?(Number)
  # 此处 b 是 Number
end
</code></pre>
<p>另外，在 <code>else</code> 分支中该变量就确定不是这个类型：</p>
<pre><code class="language-crystal">a = some_condition ? 1 : &quot;hello&quot;
# a : Int32 | String

if a.is_a?(Number)
  # a : Int32
else
  # a : String
end
</code></pre>
<p>注意，你可以用 <code>is_a?</code>测试任意的类型，比如抽象类和模块。</p>
<p>上述规则也适用于条件中的与运算(<code>&amp;&amp;</code>)：</p>
<pre><code class="language-crystal">if a.is_a?(String) &amp;&amp; b.is_a?(Number)
  # 此处 a 是 String , b 是 Number
end
</code></pre>
<h2 id="限制-1"><a class="header" href="#限制-1">限制</a></h2>
<p>上述规则 <strong>不适用于</strong> 成员变量或类变量。为了在这些地方使用它，首先把它赋值给一个局部变量：</p>
<pre><code class="language-crystal">if @a.is_a?(String)
  # 此处 @a 不能保证是 String
end

a = @a
if a.is_a?(String)
  # 此处 a is 保证是 String
end

# 简短一些:
if (a = @a).is_a?(String)
  # 此处 a is 保证是 String
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-varresponds_to"><a class="header" href="#if-varresponds_to">if var.responds_to?(...)</a></h1>
<p>如果 <code>if</code>的条件是 <code>responds_to?</code>测试，那么在 <code>then</code> 分支该变量保证响应这种方法：</p>
<pre><code class="language-crystal">if a.responds_to?(:abs)
  # 这里a的确定可以响应 'abs' 方法
end
</code></pre>
<p>另外，在 <code>else</code> 分支该变量保证不响应该方法：</p>
<pre><code class="language-crystal">a = some_condition ? 1 : &quot;hello&quot;
# a : Int32 | String

if a.responds_to?(:abs)
  # 此处 a 会是 Int32, 因为 Int32#abs 存在, 而  String#abs 不存在
else
  # 此处 a 会是 String
end
</code></pre>
<h1 id="限制-2"><a class="header" href="#限制-2">限制</a></h1>
<p>上述规则 <strong>不适用于</strong> 成员变量或类变量。为了在这些地方使用它，首先把它赋值给一个局部变量：</p>
<pre><code class="language-crystal">if @a.responds_to?(:abs)
  # 此处 @a 不能保证接收 `abs` 消息
end

a = @a
if a.responds_to?(:abs)
  # 此处 a 保证接收 `abs` 消息
end

# A bit shorter:
if (a = @a).responds_to?(:abs)
  # 此处 a 保证接收 `abs` 消息
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-varnil"><a class="header" href="#if-varnil">if var.nil?</a></h1>
<p>如果 <code>if</code>的条件是 <code>var.nil?</code> ，那么在 <code>then</code> 分支中，<code>var</code>的值就确定是 <code>Nil</code>，并且在<code>else</code>分支中它就确定不是 <code>Nil</code>：</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
if a.nil?
  # 此处 a 是 Nil
else
  # 此处 a 是 Int32
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-"><a class="header" href="#if-">if !</a></h1>
<p><code>!</code> 运算符翻转一个变量的 <a href="syntax_and_semantics/truthy_and_falsey_values.html">真性</a>，返回<code>Bool</code>.</p>
<p>当在 <code>if</code> 中与一个变量连接时， <code>is_a?</code>， <code>responds_to?</code> 或 <code>nil?</code> 都会相应地翻转自己的结论：</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
if !a
  # 此处 a 是 Nil 因为 a 在这个分支是假的
else
  # 此处 a 是 Int32, 因为 a 在这个分支是真的
end
</code></pre>
<pre><code class="language-crystal">b = some_condition ? 1 : &quot;x&quot;
if !b.is_a?(Int32)
  # 此处 b 是 String ，因为它不是 Int32
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unless"><a class="header" href="#unless">unless</a></h1>
<p>与<code>if</code>相反，<code>unless</code> 当条件为 <em>假</em> 的时候求值then分支，分则求值else分支(如果有)：</p>
<pre><code class="language-crystal">unless some_condition
  then_expression
else
  else_expression
end

# 上式等同于:
if some_condition
  else_expression
else
  then_expression
end

# 也可以后置
close_door unless door_closed?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case"><a class="header" href="#case">case</a></h1>
<p><code>case</code> 是类似于模式匹配的控制表达式，他可以等效于一系列 if-else-if 表达式，但也有更强大的功能。</p>
<p>在最基本的结构中，它可以比对一个值与其他值：</p>
<pre><code class="language-crystal">case exp
when value1, value2
  do_something
when value3
  do_something_else
else
  do_another_thing
end

# 上式等同于:
tmp = exp
if value1 === tmp || value2 === tmp
  do_something
elsif value3 === tmp
  do_something_else
else
  do_another_thing
end
</code></pre>
<p>表达式与 <code>case</code>的值是否等价，这由 <em>等价判断运算符</em> <code>===</code> 决定。这是 <a href="https://crystal-lang.org/api/Object.html#%3D%3D%3D%28other%29-instance-method"><code>Object</code></a> 中定义的一个方法，也可以由其他类重载以提供特定的的匹配语义。比如， <a href="https://crystal-lang.org/api/Class.html#%3D%3D%3D%28other%29-instance-method"><code>Class</code></a> 进行匹配的方法是看该对象是否是这个类的实例， <a href="https://crystal-lang.org/api/Regex.html#%3D%3D%3D%28other%3AString%29-instance-method"><code>Regex</code></a> 则看这个值(往往是字符串)是否和正则表达式匹配，而 <a href="https://crystal-lang.org/api/Range.html#%3D%3D%3D%28value%29-instance-method"><code>Range</code></a> 则检查这个值是否处于范围之中。</p>
<p>如果 <code>when</code>对应的表达式是一个类型，就用 <code>is_a?</code> 来判断。另外，在不同的分支中，表达式的类型也会有更准确的限制：</p>
<pre><code class="language-crystal">case var
when String
  # var : String
  do_something
when Int32
  # var : Int32
  do_something_else
else
  # 这里 var 既不是 String 也不是 Int32
  do_another_thing
end

# 上式等同于:
if var.is_a?(String)
  do_something
elsif var.is_a?(Int32)
  do_something_else
else
  do_another_thing
end
</code></pre>
<p>你可以通过隐式对象语法在<code>when</code>中调用 <code>case</code>表达式的方法：</p>
<pre><code class="language-crystal">case num
when .even?
  do_something
when .odd?
  do_something_else
end

# 上式等同于:
tmp = num
if tmp.even?
  do_something
elsif tmp.odd?
  do_something_else
end
</code></pre>
<p>你可以在  <code>when</code> 表达式后面接<code>then</code> 来避免另起一行。</p>
<pre><code class="language-crystal">case exp
when value1, value2 then do_something
when value3         then do_something_else
else                     do_another_thing
end
</code></pre>
<p>最后，你可以省略 <code>case</code>的值：</p>
<pre><code class="language-crystal">case
when cond1, cond2
  do_something
when cond3
  do_something_else
end

# 上式等同于:
if cond1 || cond2
  do_something
elsif cond3
  do_something_else
end
</code></pre>
<p>这有时会增强代码可读性。</p>
<h2 id="元组字面量"><a class="header" href="#元组字面量">元组字面量</a></h2>
<p>如果 case 的值和when的条件是元组字面量，case的行为会有一些特殊。</p>
<h3 id="元组的大小必须匹配"><a class="header" href="#元组的大小必须匹配">元组的大小必须匹配</a></h3>
<pre><code class="language-crystal">case {value1, value2}
when {0, 0} # OK, 2 个元素
  # ...
when {1, 2, 3} # 编译错误，这个分支绝不会被匹配到
  # ...
end
</code></pre>
<h3 id="忽略变量"><a class="header" href="#忽略变量">忽略变量</a></h3>
<pre><code class="language-crystal">case {value1, value2}
when {0, _}
  # 当 0 === value1, 时匹配，不对 value2 做检查
when {_, 0}
  # 当 0 === value2, 时匹配，不对 value1 做检查
end
</code></pre>
<h3 id="元组中的隐式对象调用"><a class="header" href="#元组中的隐式对象调用">元组中的隐式对象调用</a></h3>
<pre><code class="language-crystal">case {value1, value2}
when {.even?, .odd?}
  # 当 value1.even? &amp;&amp; value2.odd? 时匹配
end
</code></pre>
<h3 id="对类型匹配就是使用-is_a-进行检查"><a class="header" href="#对类型匹配就是使用-is_a-进行检查">对类型匹配就是使用 is_a? 进行检查</a></h3>
<pre><code class="language-crystal">case {value1, value2}
when {String, Int32}
  # 当 value1.is_a?(String) &amp;&amp; value2.is_a?(Int32) 时匹配
  # 此时编译器知道 value1 是 String, value2 是Int32
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while"><a class="header" href="#while">while</a></h1>
<p><code>while</code>表达式只要条件是<em>真</em>的,就执行它的内容。</p>
<pre><code class="language-crystal">while some_condition
  do_this
end
</code></pre>
<p><code>while</code>先测试条件，如果为 <em>真</em>，就执行主体。即，也许主体根本不会被执行(如果条件一开始就是假的)。 </p>
<p><code>while</code>的类型永远是 <code>Nil</code>.</p>
<p>类似于 <code>if</code>,如果 <code>while</code>的条件是一个变量，这个变量在循环体中保证不是<code>nil</code>。如果条件是测试 <code>var.is_a?(Type)</code>， <code>var</code> 就保证是 <code>Type</code>的那个类型。如果条件是 <code>var.responds_to?(:method)</code>， <code>var</code>就保证能响应这个方法。</p>
<p><code>while</code> 之后，一个变量的类型取决于他在 <code>while</code> 之前的值，以及 <code>while</code> 中对他的最后一次赋值：</p>
<pre><code class="language-crystal">a = 1
while some_condition
  # a : Int32 | String
  a = &quot;hello&quot;
  # a : String
  a.size
end
# a : Int32 | String
</code></pre>
<h2 id="在循环结尾检查条件"><a class="header" href="#在循环结尾检查条件">在循环结尾检查条件</a></h2>
<p>如果你至少要执行一次循环体，然后检查是否跳出，你可以这么做：</p>
<pre><code class="language-crystal">while true
  do_something
  break if some_condition
end
</code></pre>
<p>或者使用标准库里的 <code>loop</code>：</p>
<pre><code class="language-crystal">loop do
  do_something
  break if some_condition
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break"><a class="header" href="#break">break</a></h1>
<p>你可以使用 <code>break</code> 跳出<code>while</code> 循环：</p>
<pre><code class="language-crystal">a = 2
while (a += 1) &lt; 20
  if a == 10
    break # 跳到 'puts a'
  end
end
puts a #=&gt; 10
</code></pre>
<p><code>break</code> 也可以带一个参数，这会在跳出<code>while</code>的时候返回一个值：</p>
<pre><code class="language-crystal">def foo
  loop do
    break &quot;bar&quot;
  end
end
puts foo #=&gt; &quot;bar&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="next"><a class="header" href="#next">next</a></h1>
<p>可以用 <code>next</code>直接跳到执行<code>while</code>的下一个循环。在 <code>next</code>执行后， <code>while</code>会检查条件，如果是 <em>真</em>的，它就接着执行循环体。</p>
<pre><code class="language-crystal">a = 1
while a &lt; 5
  a += 1
  if a == 3
    next
  end
  puts a
end
# 上面的结构打印数 2, 4 和 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="until"><a class="header" href="#until">until</a></h1>
<p><code>until</code>执行它的循环体，直到条件是 <em>真的</em>。 一个 <code>until</code> 只是 <code>while</code>否定格式的一个语法糖：</p>
<pre><code class="language-crystal">until some_condition
  do_this
end

# 上式等价于:
while !some_condition
  do_this
end
</code></pre>
<p><code>break</code> 和 <code>next</code> 也可以在 <code>until</code>里使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--逻辑与运算符"><a class="header" href="#--逻辑与运算符">&amp;&amp; - 逻辑与运算符</a></h1>
<p><code>&amp;&amp;</code> (与) 先求其左式的值。如果左边<em>是真的</em>，它的值就是其右边的值。否则它的值就是左式的值(多半是 <code>false</code> 或<code>nil</code>)。他的类型是左右两边类型的或。</p>
<p>你可以认为 <code>&amp;&amp;</code> 是 <code>if</code>的语法糖：</p>
<pre><code class="language-crystal">some_exp1 &amp;&amp; some_exp2

#上式等同于:
tmp = some_exp1
if tmp
  some_exp2
else
  tmp
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="---逻辑或运算符"><a class="header" href="#---逻辑或运算符">|| - 逻辑或运算符</a></h1>
<p><code>||</code> (或) 先求左边表达式的值，如果他是 <em>假的</em>， 它就会求值右边的表达式，并把自己的值设为它。它的类型是左右两边类型的并。</p>
<p>你可以认为 <code>||</code> 是 <code>if</code>的语法糖：</p>
<pre><code class="language-crystal">some_exp1 || some_exp2

# 上式等同于:
tmp = some_exp1
if tmp
  tmp
else
  some_exp2
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导入文件"><a class="header" href="#导入文件">导入文件</a></h1>
<p>对于小的片段或是测试程序，把所有程序写到一个文件里尚可以接受。然而，大程序更适合分到多个文件里，以维持清晰的结构，增强可维护性。</p>
<p>要让编译器处理其他文档，你可以用 <code>require &quot;...&quot;</code>。 它接受一个单独的字符串字面量。<code>require &quot;...&quot;</code>有很多功能，下面将一一说明。</p>
<p>一旦文件被包含，编译器就会记住文件的绝对路径，对其重复的<code>require</code>会被忽略。</p>
<h2 id="require-filename"><a class="header" href="#require-filename">require &quot;filename&quot;</a></h2>
<p>查找包含目录里面的文件 &quot;filename&quot; 。</p>
<p>默认的包含目录是编译器指定的标准库目录，以及当前目录下的&quot;lib&quot; 子目录(由unix shell 的<code>pwd</code> 指定)。默认情况下只会查找这两个地方。</p>
<p>查找遵循如下规则：</p>
<ul>
<li>如果包含目录中有文件叫 &quot;filename.cr&quot;， 那就导入它。</li>
<li>如果有目录叫 &quot;filename&quot; ，并且里面有文件 &quot;filename.cr&quot;直属于它，那就导入这个文件。</li>
<li>否则产生编译错误。</li>
</ul>
<p>第二个规则非常方便，因为项目的典型目录结构是这样的：</p>
<pre><code>- project
  - lib
    - foo
      foo.cr
    - bar
      bar.cr
  - src
    - project.cr
  - spec
    - project_spec.cr
</code></pre>
<p>比如，如果你在<code>project.cr</code>中写<code>require &quot;foo&quot;</code>以导入foo，然后在项目根目录中运行  <code>crystal src/project.cr</code>，它就在 <code>lib/foo/foo.cr</code>中找到 <code>foo</code>。</p>
<p>如果你从其他地方运行编译器,比如说 <code>src</code>文件夹，那么 <code>lib</code>就不在路径中， <code>require &quot;foo&quot;</code>也不会被找到。</p>
<h2 id="require-filename-1"><a class="header" href="#require-filename-1">require &quot;./filename&quot;</a></h2>
<p>这会从文档的当前位置以相对路径查找 &quot;filename&quot;。</p>
<p>查找遵循如下规律：</p>
<ul>
<li>如果有文件 &quot;filename.cr&quot; 在当前文档中，那就包含它。</li>
<li>如果有目录 &quot;filename&quot; ，而且里面有文件 &quot;filename.cr&quot;直属于它，那就导入这个文件。</li>
<li>否则产生编译错误。</li>
</ul>
<p>这个关系往往用于引用项目内的其他文件。它也用于从<a href="syntax_and_semantics/../guides/testing.html">specs</a>中引用项目的文件：</p>
<pre><code class="language-crystal"># 在 spec/project_spec.cr
require &quot;../src/project&quot;
</code></pre>
<h2 id="其他形式"><a class="header" href="#其他形式">其他形式</a></h2>
<p>这两种形式都支持嵌套名称，这会导到对应的嵌套文件或目录里面：</p>
<ul>
<li><code>require &quot;foo/bar/baz&quot;</code> 会在包含目录中查找 &quot;foo/bar/baz.cr&quot; 或 &quot;foo/bar/baz/baz.cr&quot; </li>
<li><code>require &quot;./foo/bar/baz&quot;</code> 会从当前目录以相对路径查找 &quot;foo/bar/baz.cr&quot; 或 &quot;foo/bar/baz/baz.cr&quot;</li>
</ul>
<p>你也可以用 &quot;../&quot; 去访问当前文件的上级目录，所以 <code>require &quot;../../foo/bar&quot;</code>也可以使用。</p>
<p>这两种形式都支持 <code>*</code> 和 <code>**</code> 后缀：</p>
<ul>
<li><code>require &quot;foo/*&quot;</code> 会导入&quot;foo&quot;文件夹中所有的 &quot;.cr&quot;文件，但到这层为止，不会递归地包含底下的目录。</li>
<li><code>require &quot;foo/**&quot;</code> 会导入&quot;foo&quot;文件夹中所有的 &quot;.cr&quot;文件，同时会递归地包含底下的目录。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型和方法"><a class="header" href="#类型和方法">类型和方法</a></h1>
<p>本节假设你已经理解什么是<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象编程</a>, 知道<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>和<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">方法</a>的概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一切都是对象"><a class="header" href="#一切都是对象">一切都是对象</a></h1>
<p>在 Crystal 中一切都是对象。对象的定义归结为两点：</p>
<ul>
<li>它属于一个类型</li>
<li>它能响应一组方法</li>
</ul>
<p>这就是你需要知道的关于对象的全部内容：它的类型、它是否响应某些方法。</p>
<p>只能通过调用方法来访问对象的内部状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crystal-程序"><a class="header" href="#crystal-程序">Crystal 程序</a></h1>
<p>Crystal 程序是一个全局对象，在里面可以定义类型、方法和文件局部变量。</p>
<pre><code class="language-crystal"># 在程序定义方法
def add(x, y)
  x + y
end

# 在程序调用add方法
add(1, 2) #=&gt; 3
</code></pre>
<p>方法的返回值是最后一条表达式的值；无需显式使用 <code>return</code> 表达式。当然也可以使用 <code>return</code> ：</p>
<pre><code class="language-crystal">def even?(num)
  if num % 2 == 0
    return true
  end

  return false
end
</code></pre>
<p>当调用一个方法时，假如没有指定接收者，例如 <code>add(1, 2)</code>，如果在当前类型或祖先链中没有找该方法，就会在全局程序中继续查找。</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

class Foo
  def bar
    # 调用全局程序的 add 方法
    add(1, 2)

    # 调用 Foo 的 baz 方法
    baz(1, 2)
  end

  def baz(x, y)
    x * y
  end
end
</code></pre>
<p>如果要调用全局程序的方法，不管当前类型是否定义了一个同名方法，都可以使用前缀 <code>::</code>：</p>
<pre><code class="language-crystal">def baz(x, y)
  x + y
end

class Foo
  def bar
    baz(4, 2) #=&gt; 2
    ::baz(4, 2) #=&gt; 6
  end

  def baz(x, y)
    x - y
  end
end
</code></pre>
<p>全局声明的变量在方法内不可见：</p>
<pre><code class="language-crystal">x = 1

def add(y)
  x + y # error: undefined local variable or method 'x'
end

add(2)
</code></pre>
<p>方法调用时圆括号可以省略：</p>
<pre><code class="language-crystal">add 1, 2 # 等价于 add(1, 2)
</code></pre>
<h2 id="主代码"><a class="header" href="#主代码">主代码</a></h2>
<p>主代码是编译运行程序时运行的代码，可以直接在源文件里写，无需放入 &quot;main&quot; 函数：</p>
<pre><code class="language-crystal"># 这是一个输出 &quot;Hello Crystal!&quot; 的程序
puts &quot;Hello Crystal!&quot;
</code></pre>
<p>主代码也可以在类型声明里：</p>
<pre><code class="language-crystal"># 这是一个输出 &quot;Hello&quot; 的程序
class Hello
  # 这里的 'self' 是 Hello 类
  puts self
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类和方法"><a class="header" href="#类和方法">类和方法</a></h1>
<p>类是对象创建的模板。举个例子，要定义一个 <code>Person</code> 类。写法如下：</p>
<pre><code class="language-crystal">class Person
end
</code></pre>
<p>在 Crystal 里类名（事实上所有类型名）都以大写字母开头。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实例化初始化和内存分配"><a class="header" href="#实例化初始化和内存分配">实例化，初始化和内存分配</a></h1>
<p>通过调用类的 <code>new</code> 方法创建实例：</p>
<pre><code>person = Person.new
</code></pre>
<p><code>person</code> 是 <code>Person</code> 的一个实例。</p>
<p>目前 <code>person</code> 没啥大用，我们给它加一些概念。一个 <code>Person</code> 有名字和年龄。在“一切都是对象”那一节我们说过一个对象属于一个类型、响应一组方法，只能通过调用方法来访问对象的内部状态，因此我们需要 <code>name</code> 和 <code>age</code> 方法。我们把这些信息存储在实例变量里面，实例变量名以 <code>@</code> 开头。我们想让 <code>Person</code> 初始化的时候带一个自定义的名字和值为0的年龄。初始化使用一个特殊的方法 <code>initialize</code>，这个方法经常被称为“构造函数”：</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    @name = name
    @age = 0
  end

  def name
    @name
  end

  def age
    @age
  end
end
</code></pre>
<p>现在可以这样创建 <code>Person</code> 对象：</p>
<pre><code class="language-crystal">john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john.name #=&gt; &quot;John&quot;
john.age #=&gt; 0

peter.name #=&gt; &quot;Peter&quot;
</code></pre>
<p>（如果你疑惑为啥 <code>name</code> 字段指定 <code>String</code> 类型，而 <code>age</code> 字段没有指定类型，参考<a href="syntax_and_semantics/type_inference.html">全局类型接口算法</a>）</p>
<p>注意，我们使用 <code>new</code> 方法创建 <code>Person</code> 实例，但是初始化代码是在 <code>initialize</code> 方法定义的，不是在 <code>new</code> 方法。这是为什么？</p>
<p>原因是当我们定义 <code>initialize</code> 方法时，Crystal 为我们定义了一个 <code>new</code> 方法，类似这样：</p>
<pre><code class="language-crystal">class Person
  def self.new(name : String)
    instance = Person.allocate
    instance.initialize(name)
    instance
  end
end
</code></pre>
<p>首先，注意 <code>self.new</code> 这种写法。这是一个<a href="syntax_and_semantics/class_methods.html">类方法</a>，类方法属于 <strong>类</strong> <code>Person</code>，不属于类的实例。这就是我们能够使用 <code>Person.new</code> 的原因。</p>
<p>其次，<code>allocate</code> 是一个底层的类方法，用来创建未初始化的该类对象。本质上它为对象分配所需的内存，然后在该内存上调用 <code>initialize</code> 方法，最后返回这个实例。通常你永远不需要调用 <code>allocate</code>，因为它是<a href="syntax_and_semantics/unsafe.html">不安全的</a>。这就是 <code>new</code> 和 <code>initialize</code> 如何关联的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法和实例变量"><a class="header" href="#方法和实例变量">方法和实例变量</a></h1>
<p>通过一种简短的语法我们可以简化构造函数，把方法参数名改为实例变量名：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
  
  def age
    @age
  end
end
</code></pre>
<p>目前，我们所能做的只有用一个名字创建 <code>Person</code> 对象。它的年龄永远是0。让我们增加一个让 person 变老的方法：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
  
  def age
    @age
  end
  
  def become_older
    @age += 1
  end
end

john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

peter.age #=&gt; 0
</code></pre>
<p>方法名以小写字母开头，按照惯例，只能使用小写字母、下划线和数字。</p>
<h2 id="读写宏"><a class="header" href="#读写宏">读写宏</a></h2>
<p>Crystal <a href="https://crystal-lang.org/api">标准库</a>提供了宏，可以简化读写方法的定义：</p>
<pre><code class="language-crystal">class Person
  property age
  getter name : String

  def initialize(@name)
    @age = 0
  end
end

john = Person.new &quot;John&quot;
john.age = 32
john.age #=&gt; 32
</code></pre>
<p>想了解更多关于读写宏的信息，参考标准库文档 <a href="https://crystal-lang.org/api/latest/Object.html#getter%28%2Anames%29-macro">Object#getter</a>， <a href="https://crystal-lang.org/api/latest/Object.html#setter%28%2Anames%29-macro">Object#setter</a>， and <a href="https://crystal-lang.org/api/latest/Object.html#property%28%2Anames%29-macro">Object#property</a>。</p>
<p>另外，我们可以在原始的 <code>Person</code> 定义中定义 <code>become_older</code> 方法，也可以分开定义，Crystal 会合并所有的定义到一个类中。下面是合法的代码：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
end

class Person
  def become_older
    @age += 1
  end
end
</code></pre>
<h2 id="重定义方法和previous_def"><a class="header" href="#重定义方法和previous_def">重定义方法和previous_def</a></h2>
<p>如果重定义一个方法，最后一次定义的优先级最高。</p>
<pre><code class="language-crystal">class Person
  def become_older
    @age += 1
  end
end

class Person
  def become_older
    @age += 2
  end
end

person = Person.new &quot;John&quot;
person.become_older
person.age #=&gt; 2
</code></pre>
<p>可用通过 <code>previous_def</code> 调用之前定义的方法（译注：多次定义可以递归）：</p>
<pre><code class="language-crystal">class Person
  def become_older
    @age += 1
  end
end

class Person
  def become_older
    previous_def
    @age += 2
  end
end

person = Person.new &quot;John&quot;
person.become_older
person.age #=&gt; 3
</code></pre>
<p>不带括号和参数的情况下，<code>previous_def</code> 将使用当前方法调用时的参数。否则使用传入的参数。</p>
<h2 id="一网打尽初始化"><a class="header" href="#一网打尽初始化">“一网打尽”初始化</a></h2>
<p>实例变量也可以在 <code>initialize</code> 方法外面初始化：</p>
<pre><code class="language-crystal">class Person
  @age = 0

  def initialize(@name : String)
  end
end
</code></pre>
<p>这会在所有构造函数中把 <code>@age</code> 初始化为0。这对减少重复代码非常有用，也避免重新打开类增加实例变量时产生 <code>Nil</code> 类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型推导"><a class="header" href="#类型推导">类型推导</a></h1>
<p>Crystal的思想是尽量少写类型声明。但是仍有一些声明要写。</p>
<pre><code class="language-crystal">class Person
  def initialize(@name)
    @age = 0
  end
end
</code></pre>
<p>我们马上就能看到 <code>@age</code> 是整数，但是我们不知道 <code>@name</code>是什么类型。编译器会尝试从 <code>Person</code> 类的所有使用来推导<code>@name</code>的类型。这会导致一些问题：</p>
<ul>
<li>这个类型对读代码的人不友好：他也得检查 <code>Person</code>的所有用法来得到推出它。</li>
<li>一些编译器优化，比如方法只分析一次，增量编译等，几乎不可能被做到。</li>
</ul>
<p>随着代码规模增长，这个问题会愈加显著：项目变得更难理解，编译时间原地飞升。</p>
<p>因此， Crystal需要知道成员变量和<a href="syntax_and_semantics/class_variables.html">类变量</a>的类型。清晰的声明会让编译器舒适，也会让阅读者舒适。</p>
<p>如下几种方法可以帮助 Crystal知道这些。</p>
<h2 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h2>
<p>最简单，也最累的方法是显示标注类型。</p>
<pre><code class="language-crystal">class Person
  @name : String
  @age : Int32

  def initialize(@name)
    @age = 0
  end
end
</code></pre>
<h2 id="不写类型标注"><a class="header" href="#不写类型标注">不写类型标注</a></h2>
<p>如果你没有显式地标注类型，编译器就会尝试用它丰富的规则积累推导成员变量或类变量的类型。</p>
<p>对于一个成员/类变量，当从一个规则猜出一种类型时，这个类型会被记录到集合中。等到所有的规律都应用完毕，推导的类型就会是这些类型之 <a href="syntax_and_semantics/union_types.html">联合</a>。另外，如果编译器知道这些变量没有总是得到初始化，它就会把 <a href="syntax_and_semantics/literals/nil.html">Nil</a>类型也加进去。</p>
<p>规则有很多，但只有前三条被经常应用，因此你没必要全记住。如果编译器报错说推不出这个变量的类型，你再添一个声明也不迟。</p>
<p>如下的规则适用于成员变量，但也可以被应用与类变量。</p>
<h3 id="1-字面量赋值"><a class="header" href="#1-字面量赋值">1. 字面量赋值</a></h3>
<p>当成员变量被赋以字面量时，字面量的类型被加入候选。所有的 <a href="syntax_and_semantics/literals.html">字面量</a>都关联有一个类型。</p>
<p>下例中， <code>@name</code>推导为 <code>String</code>，而 <code>@age</code>推导为 <code>Int32</code>。</p>
<pre><code class="language-crystal">class Person
  def initialize
    @name = &quot;John Doe&quot;
    @age = 0
  end
end
</code></pre>
<p>这个规则，和下面的所有规则，也用于<code>initialize</code>之外的方法。比如：</p>
<pre><code class="language-crystal">class SomeObject
  def lucky_number
    @lucky_number = 42
  end
end
</code></pre>
<p>上例中， <code>@lucky_number</code> 会被推导为 <code>Int32 | Nil</code>：<code>Int32</code> 是因为42被赋给它，而 <code>Nil</code>是因为他不总是在所有的初始化方法中都被赋值。</p>
<h3 id="2-赋以调用某个类方法-new的结果"><a class="header" href="#2-赋以调用某个类方法-new的结果">2. 赋以调用某个类方法 <code>new</code>的结果</a></h3>
<p>当成员变量被赋以一个 <code>Type.new(...)</code> 之类的表达式，对应的 <code>Type</code>被加入候选。</p>
<p>下例中， <code>@address</code> 推导为 <code>Address</code>。</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.new(&quot;somewhere&quot;)
  end
end
</code></pre>
<p>这对泛型也适用。这里 <code>@values</code> 推导为 <code>Array(Int32)</code>.</p>
<pre><code class="language-crystal">class Something
  def initialize
    @values = Array(Int32).new
  end
end
</code></pre>
<p><strong>注意</strong>：  <code>new</code>方法可能在类型中被重定义，如果这样，那么它的类型就是 <code>new</code>的返回值类型，如果返回值能凭借接下来的规则推出来。</p>
<h3 id="3-赋以一个在方法中有类型限制的变量"><a class="header" href="#3-赋以一个在方法中有类型限制的变量">3. 赋以一个在方法中有类型限制的变量</a></h3>
<p>下例中<code>@name</code> 推导为 <code>String</code> ，因为 <code>name</code> 的类型被确定为 <code>String</code>，然后他又被赋给了 <code>@name</code>。</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    @name = name
  end
end
</code></pre>
<p>注意这个参数的名字并不重要。这个例子也顶用：</p>
<pre><code class="language-crystal">class Person
  def initialize(obj : String)
    @name = obj
  end
end
</code></pre>
<p>这个行为有语法糖，以下的代码和上面的代码是等效的：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end
end
</code></pre>
<p>同时注意，编译器不会检查方法的参数是否被赋予了别的值：</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    name = 1
    @name = name
  end
end
</code></pre>
<p>这个例子中，编译器仍然会认为 <code>@name</code> 是 <code>String</code>，然后报编译错误，说 <code>Int32</code> 不能被赋给类型为 <code>String</code>的变量。如果 <code>@name</code>不应该是<code>String</code>，你应当标注出来。</p>
<h3 id="4-赋以返回值有标注的类方法"><a class="header" href="#4-赋以返回值有标注的类方法">4. 赋以返回值有标注的类方法</a></h3>
<p>下例中， <code>@address</code> 推导为 <code>Address</code>，因为类方法 <code>Address.unknown</code>的返回值被标为 <code>Address</code>。</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.unknown
  end
end

class Address
  def self.unknown : Address
    new(&quot;unknown&quot;)
  end

  def initialize(@name : String)
  end
end
</code></pre>
<p>实际上， <code>self.unknown</code>用不着标注返回值类型，因为编译器会分析这个类方法。如果它能应用之前的规律(像是 <code>new</code>方法或是字面量的规律)，他就能把类方法的返回值推出来。所以，我们可以这么简写：</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.unknown
  end
end

class Address
  # 这里不用标注返回值:
  def self.unknown
    new(&quot;unknown&quot;)
  end

  def initialize(@name : String)
  end
end
</code></pre>
<p>这个规律非常方便，因为<code>new</code>之外的“类似于构造函数”的类方法非常常见。</p>
<h3 id="5赋以方法参数中的默认值"><a class="header" href="#5赋以方法参数中的默认值">5.赋以方法参数中的默认值</a></h3>
<p>下例中， 因为 <code>name</code> 的默认值是字面量，而后他被赋值给 <code>@name</code>，所以 <code>String</code>也会被加入候选。</p>
<pre><code class="language-crystal">class Person
  def initialize(name = &quot;John Doe&quot;)
    @name = name
  end
end
</code></pre>
<p>同样的，这也有语法糖：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name = &quot;John Doe&quot;)
  end
end
</code></pre>
<p>同样地，默认值可以使是 <code>Type.new(...)</code> ，或是一个有返回值标注的类方法。</p>
<h3 id="6-赋以-lib函数的返回值"><a class="header" href="#6-赋以-lib函数的返回值">6. 赋以 <code>lib</code>函数的返回值</a></h3>
<p>因为 <a href="syntax_and_semantics/c_bindings/fun.html">C库函数</a> 肯定有显式的类型，所以编译器可以由此推出被赋值者的类型。</p>
<p>下例中<code>@age</code> 推导为 <code>Int32</code>。</p>
<pre><code class="language-crystal">class Person
  def initialize
    @age = LibPerson.compute_default_age
  end
end

lib LibPerson
  fun compute_default_age : Int32
end
</code></pre>
<h3 id="7-使用-out-库表达式"><a class="header" href="#7-使用-out-库表达式">7. 使用 <code>out</code> 库表达式</a></h3>
<p>因为 <a href="syntax_and_semantics/c_bindings/fun.html">库函数</a> 的参数肯定有显式的类型，编译器就可以猜出 <code>out</code>参数的类型。这应该是一个指针类型，也可能是是指针解引用得到的类型。</p>
<p>下例中<code>@age</code> 推导为 <code>Int32</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    LibPerson.compute_default_age(out @age)
  end
end

lib LibPerson
  fun compute_default_age(age_ptr : Int32*)
end
</code></pre>
<h3 id="其他规则"><a class="header" href="#其他规则">其他规则</a></h3>
<p>编译器会尽它最大的智能来减少你手动标注类型的需要。比如，如果 <code>if</code>的结果被拿来赋值，类型就会是 <code>then</code>和 <code>else</code>分支返回类型的并：</p>
<pre><code class="language-crystal">class Person
  def initialize
    @age = some_condition ? 1 : 2
  end
end
</code></pre>
<p>因为上面的<code>if</code>  (额，技术上叫三元运算符，不过类似于 <code>if</code>)有整数字面量， <code>@age</code>就会被成功推导为 <code>Int32</code>而不用再标注类型。</p>
<p>另外的例子是 <code>||</code> 和 <code>||=</code>：</p>
<pre><code class="language-crystal">class SomeObject
  def lucky_number
    @lucky_number ||= 42
  end
end
</code></pre>
<p>上例中 <code>@lucky_number</code> 推导为 <code>Int32 | Nil</code>。这对于惰性初始化的变量非常有用。</p>
<p>也可以用常量赋值，这对于编译器和人类都很友好。</p>
<pre><code class="language-crystal">class SomeObject
  DEFAULT_LUCKY_NUMBER = 42

  def initialize(@lucky_number = DEFAULT_LUCKY_NUMBER)
  end
end
</code></pre>
<p>此时应用规则 5 (参数初始值)，然后因为常量是一个整数字面量， <code>@lucky_number</code> 就推导为 <code>Int32</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合类型"><a class="header" href="#联合类型">联合类型</a></h1>
<p>变量和表达式的类型可以有多个类型组成，这被称为联合类型。例如，当在 <a href="syntax_and_semantics/if.html">if</a>的不同分支中赋值同一个变量时：</p>
<pre><code class="language-crystal">if 1 + 2 == 3
  a = 1
else
  a = &quot;hello&quot;
end

a # : Int32 | String
</code></pre>
<p>在if的结尾， <code>a</code> 会有类型 <code>Int32 | String</code>，读作 &quot; Int32 和 String的联合类型&quot;。这个联合类型由编译器自动构建。在运行时， <code>a</code> 当然只会有一个类型。这可以由调用 <code>class</code>方法看出：</p>
<pre><code class="language-crystal"># 运行时类型
a.class # =&gt; Int32
</code></pre>
<p>编译时类型可以由 <a href="syntax_and_semantics/typeof.html">typeof</a>看出：</p>
<pre><code class="language-crystal"># 编译时类型
typeof(a) # =&gt; Int32 | String
</code></pre>
<p>一个联合类型可以由任意多的类型组成。当调用联合类型的某个方法时，所有的类型都必须响应这个方法，否则会产生编译错误。这个方法调用返回值的类型是所有可能的返回值类型的联合。</p>
<pre><code class="language-crystal"># to_s 在 Int32 和 String 都有定义，它返回 String
a.to_s # =&gt; String

a + 1 # 错误，因为 String#+(Int32) 没有定义
</code></pre>
<p>如果需要，一个变量可以在编译时设为联合类型。</p>
<pre><code class="language-crystal"># 设置编译时类型
a = 0.as(Int32|Nil|String)
typeof(a) # =&gt; Int32 | Nil | String
</code></pre>
<h2 id="联合类型规则"><a class="header" href="#联合类型规则">联合类型规则</a></h2>
<p>一般来说，但两个类型 <code>T1</code>和 <code>T2</code>结合时，得到的类型是 <code>T1 | T2</code>。然而，在少数情况返回值可以是其他的类型。</p>
<h3 id="同一级的类和结构体之联合"><a class="header" href="#同一级的类和结构体之联合">同一级的类和结构体之联合</a></h3>
<p>如果 <code>T1</code> 和 <code>T2</code>在同一个等级，并且它们最近的共同祖先 <code>Parent</code>不是 <code>Reference</code>、 <code>Struct</code>、 <code>Int</code>、 <code>Float</code>或 <code>Value</code>，则返回类型是 <code>Parent+</code>。这称作虚类型，意思是编译器不会把它看做 <code>Parent</code>，或是任何的子类型。</p>
<p>例如：</p>
<pre><code class="language-crystal">class Foo
end

class Bar &lt; Foo
end

class Baz &lt; Foo
end

bar = Bar.new
baz = Baz.new

# 这里 foo的类型是 Bar | Baz,
# 但是由于Bar 和 Baz 都继承 Foo,
# 返回类型是 Foo+
foo = rand &lt; 0.5 ? bar : baz
typeof(foo) # =&gt; Foo+
</code></pre>
<h3 id="同样大小的元组之联合"><a class="header" href="#同样大小的元组之联合">同样大小的元组之联合</a></h3>
<p>同样大小的元组的联合，会得到一个新元组，每个位置的类型是原先对应位置的各类型之并。</p>
<p>例如：</p>
<pre><code class="language-crystal">t1 = {1, &quot;hi&quot;}   # Tuple(Int32, String)
t2 = {true, nil} # Tuple(Bool, Nil)

t3 = rand &lt; 0.5 ? t1 : t2
typeof(t3) # Tuple(Int32 | Bool, String | Nil)
</code></pre>
<h3 id="相同键名的命名元组之联合"><a class="header" href="#相同键名的命名元组之联合">相同键名的命名元组之联合</a></h3>
<p>不管键的排列顺序如何，相同键名的命名元组之联合会得到一个新元组，每个键值的类型是原先对应键值的各类型之并。键的顺序如同最表达式左边的那个元组。</p>
<p>例如：</p>
<pre><code class="language-crystal">t1 = {x: 1, y: &quot;hi&quot;}   # Tuple(x: Int32, y: String)
t2 = {y: true, x: nil} # Tuple(y: Bool, x: Nil)

t3 = rand &lt; 0.5 ? t1 : t2
typeof(t3) # NamedTuple(x: Int32 | Nil, y: String | Bool)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重载"><a class="header" href="#重载">重载</a></h1>
<p>我们可以定义一个 <code>become_older</code> 方法，它接受一个数字，表示成长的年龄：</p>
<pre><code class="language-crystal">class Person
  getter :age
    
  def initialize(@name : String, @age : Int = 0)
  end

  def become_older
    @age += 1
  end

  def become_older(years)
    @age += years
  end
end

john = Person.new &quot;John&quot;
john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

john.become_older 5
john.age #=&gt; 6
</code></pre>
<p>如果你定义名称相同，参数个数不同的多种方法，他们那会被认为是不同的方法。这被称为<em>方法重载</em>。</p>
<p>方法重载有多个指标：</p>
<ul>
<li>参数的个数</li>
<li>加给参数的类型限制</li>
<li>参数需要的名称</li>
<li>方法是否接收 <a href="syntax_and_semantics/blocks_and_procs.html">块</a></li>
</ul>
<p>例如，我们可以定义四种不同的 <code>become_older</code> 方法：</p>
<pre><code class="language-crystal">class Person
  @age = 0

  # 年龄增长一岁
  def become_older
    @age += 1
  end

  # 按指定年龄增长
  def become_older(years : Int32)
    @age += years
  end

  # 按字符串指定的年龄增长
  def become_older(years : String)
    @age += years.to_i
  end

  # 产出(yield)这个人当前的年龄,并且按块的返回值增加它
  def become_older
    @age += yield @age
  end
end

person = Person.new &quot;John&quot;

person.become_older
person.age #=&gt; 1

person.become_older 5
person.age #=&gt; 6

person.become_older &quot;12&quot;
person.age #=&gt; 18

person.become_older do |current_age|
  current_age &lt; 20 ? 10 : 30
end
person.age #=&gt; 28
</code></pre>
<p>注意在那个有yield的方法的情况中，编译器发现方法里有一个<code>yield</code>表达式，所以知道它接受一个块。如果要明显地指出，你可以在参数列表末尾加入一个<code>&amp;block</code> 参数。</p>
<pre><code class="language-crystal">class Person
  @age = 0

  def become_older(&amp;block)
    @age += yield @age
  end
end
</code></pre>
<p>在产生的文档中，这个 <code>&amp;block</code> 方法将总是写出，不论你有没有显式地写出它。</p>
<p>参数个数相同时，编译器会尝试找到更<em>精确匹配</em>的方法定义，然后调用它。</p>
<pre><code class="language-crystal">class Person
  @age = 0

  # 首先这个方法被定义了
  def become_older(age)
    @age += age
  end

  # 因为 &quot;String&quot; 比毫无限制要严格，编译器进行重载决议时，会让他优先于之前的那个。
  def become_older(age : String)
    @age += age.to_i
  end
end

person = Person.new &quot;John&quot;

# 调用第一个定义
person.become_older 20

# 调用第二个定义
person.become_older &quot;12&quot;
</code></pre>
<p>然而这个比较不是全序的(译注：如果有多个匹配，它们在不同的方面做了限制，编译器将犯难最终要用哪一个)。所以最好总是把最宽泛的方法放在最后面。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="默认值"><a class="header" href="#默认值">默认值</a></h1>
<p>一个方法可以指定后面一些参数的默认值：</p>
<pre><code class="language-crystal">class Person
  def become_older(by = 1)
    @age += by
  end
end

john = Person.new &quot;John&quot;
john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

john.become_older 2
john.age #=&gt; 3
</code></pre>
<h1 id="命名参数"><a class="header" href="#命名参数">命名参数</a></h1>
<p>所有的参数除了使用位置确定之外，还可以通过名称来确定。例如：</p>
<pre><code class="language-crystal">john.become_older by: 5
</code></pre>
<p>当有多个参数时，只要所有需要的参数都指定了，那么指定名称的顺序就没有影响。</p>
<pre><code class="language-crystal">def some_method(x, y = 1, z = 2, w = 3)
  # 做一些事情
end

some_method 10                   # x: 10, y: 1, z: 2, w: 3
some_method 10, z: 10            # x: 10, y: 1, z: 10, w: 3
some_method 10, w: 1, y: 2, z: 3 # x: 10, y: 2, z: 3, w: 1
some_method y: 10, x: 20         # x: 20, y: 10, z: 2, w: 3

some_method y: 10                # 错误: 缺少参数 x
</code></pre>
<p>当用元组概括不定数量参数时，不能使用命名参数。因为这时难以确定哪个输入匹配哪个位置。此时位置参数相对易于理解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组展开"><a class="header" href="#元组展开">元组展开</a></h1>
<p>一个方法可以通过<em>星号参数</em> (<code>*</code>)来接收不定数量的参数。星号参数可以出现在任何位置，但只能出现一次：</p>
<pre><code class="language-crystal">def sum(*elements)
  total = 0
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3    #=&gt; 6
sum 1, 2, 3, 4.5 #=&gt; 10.5
</code></pre>
<p>这些传递的参数在消息内会形成一个<a href="http://crystal-lang.org/api/Tuple.html">元组</a>：</p>
<pre><code class="language-crystal"># 元组(Int32, Int32, Int32)中的元素
sum 1, 2, 3

# 元组(Int32, Int32, Int32, Float64)中的元素
sum 1, 2, 3, 4.5
</code></pre>
<p>星号后面只能接命名参数：</p>
<pre><code class="language-crystal">def sum(*elements, initial = 0)
  total = initial
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3 # =&gt; 6
sum 1, 2, 3, initial: 10 # =&gt; 16
</code></pre>
<p>星号后面的参数如果没有默认值，那就只能用名称指定：</p>
<pre><code class="language-crystal">def sum(*elements, initial)
  total = initial
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3 # 错误，缺少参数: initial
sum 1, 2, 3, initial: 10 # =&gt; 16
</code></pre>
<p>两个需要不同名称的命名参数是不同的,只是重载在一起而已：</p>
<pre><code class="language-crystal">def foo(*elements, x)
  1
end

def foo(*elements, y)
  2
end

foo x: &quot;something&quot; # =&gt; 1
foo y: &quot;something&quot; # =&gt; 2
</code></pre>
<p>星号参数也可以不写名字，这意味着“我之后只能是命名参数”：</p>
<pre><code class="language-crystal">def foo(x, y, *, z)
end

foo 1, 2, 3    # 错误, 参数数目不匹配 (给出 3, 期待 2)
foo 1, 2       # 错误, 缺少参数: z
foo 1, 2, z: 3 # OK
</code></pre>
<h2 id="展开元祖"><a class="header" href="#展开元祖">展开元祖</a></h2>
<p><code>Tuple</code> 可以用<code>*</code>在方法中展开：</p>
<pre><code class="language-crystal">def foo(x, y)
  x + y
end

tuple = {1, 2}
foo *tuple # =&gt; 3
</code></pre>
<h2 id="双星号和命名元组"><a class="header" href="#双星号和命名元组">双星号和命名元组</a></h2>
<p>双星号(<code>**</code>) 接受没有被其他名称匹配的命名参数。他自己的类型是 <code>NamedTuple</code>：</p>
<pre><code class="language-crystal">def foo(x, **other)
  # 以 NamedTuple 的形式返回其他参数
  other
end

foo 1, y: 2, z: 3    # =&gt; {y: 2, z: 3}
foo y: 2, x: 1, z: 3 # =&gt; {y: 2, z: 3}
</code></pre>
<h2 id="命名元组的展开"><a class="header" href="#命名元组的展开">命名元组的展开</a></h2>
<p><code>NamedTuple</code> 可以通过 <code>**</code>展开，送进一个方法：</p>
<pre><code class="language-crystal">def foo(x, y)
  x - y
end

tuple = {y: 3, x: 10}
foo **tuple # =&gt; 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型限制"><a class="header" href="#类型限制">类型限制</a></h1>
<p>类型限制是施加于方法参数上的类型声明，用于限制方法接受的参数。</p>
<pre><code class="language-crystal">def add(x : Number, y : Number)
  x + y
end

# Ok
add 1, 2 # Ok

# 错误: 'add' 没有重载匹配类型 Bool, Bool
add true, false
</code></pre>
<p>注意如果我们定义 <code>add</code>时没有增加类型约束，最终还是会得到编译错误：</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

add true, false
</code></pre>
<p>他会产生如下的错误：</p>
<pre><code>错误:  foo.cr:6: 实例化 'add(Bool, Bool)' 时:

add true, false
^~~

foo.cr:2: Bool 没有定义方法 '+' 

  x + y
    ^
</code></pre>
<p>这是因为你调用 <code>add</code>时，他会以参数的类型实例化：以每一种类型组合调用方法都会得到不同的实例化方法。</p>
<p>唯一的区别就是第一个错误信息更加清晰。但是两种定义都是安全的，因为错误的调用都会产生编译错误。所以总的来说，最好不要指定类型限制，只在定义不同的方法重载时使用它。这可以产生更加泛化，更加可用的代码。例如，如果我们对<code>Number</code>意外的类型定义 <code>+</code> 方法，我们就可以使用不带类型限制的 <code>add</code>方法，但是我们就不能使用有限制的那个 <code>add</code>。</p>
<pre><code class="language-crystal"># 一个有 '+' 方法却不是 Number 的类:
class Six
  def +(other)
    6 + other
  end
end

# 不带类型限制的add方法:
def add(x, y)
  x + y
end

# OK
add Six.new, 10

# 带类型限制的add方法:
def restricted_add(x : Number, y : Number)
  x + y
end

# 错误: 'restricted_add'没有重载以匹配类型 Six, Int32
restricted_add Six.new, 10
</code></pre>
<p>对于类型限制的写法，参考<a href="syntax_and_semantics/type_grammar.html">类型语法</a>。</p>
<p>注意类型限制不适用于方法内部的变量：</p>
<pre><code class="language-crystal">def handle_path(path : String)
  path = Path.new(path) # *path* 现在是 Path
  # 对 *path* 做点什么
end
</code></pre>
<h2 id="self-限制"><a class="header" href="#self-限制">self 限制</a></h2>
<p><code>self</code> 特殊的类型限制是：</p>
<pre><code class="language-crystal">class Person
  def ==(other : self)
    other.name == name
  end

  def ==(other)
    false
  end
end

john = Person.new &quot;John&quot;
another_john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john == another_john #=&gt; true
john == peter #=&gt; false (names differ)
john == 1 #=&gt; false (because 1 is not a Person)
</code></pre>
<p>上例中 <code>self</code> 等同于写 <code>Person</code>。但是一般来说， <code>self</code> 等同于写最终要拥有这个方法的类型。这对于模块更有用；</p>
<p>另外来说，既然 <code>Person</code>继承了 <code>Reference</code>。第二个 <code>==</code> 的定义就不必要了，因为它已经定义在 <code>Reference</code>里。</p>
<p>注意 <code>self</code>总是代表实例类型，即使是在类方法中：</p>
<pre><code class="language-crystal">class Person
  def self.compare(p1 : self, p2 : self)
    p1.name == p2.name
  end
end

john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

Person.compare(john, peter) # OK
</code></pre>
<p>你可以用 <code>self.class</code>指代 Person类型。下一章将介绍类型限制中的 <code>.class</code>后缀。</p>
<h2 id="类作为类型限制"><a class="header" href="#类作为类型限制">类作为类型限制</a></h2>
<p>举个例子， <code>Int32</code> 作为类型限制使方法只能接受 <code>Int32</code>的实例：</p>
<pre><code class="language-crystal">def foo(x : Int32)
end

foo 1       # OK
foo &quot;hello&quot; # Error
</code></pre>
<p>如果你想要方法只接受类型 Int32 (而不是它的示例)你应该用 <code>.class</code>：</p>
<pre><code class="language-crystal">def foo(x : Int32.class)
end

foo Int32  # OK
foo String # Error
</code></pre>
<p>这对于指定类型——而不是实例——进行方法重载时很有用：</p>
<pre><code class="language-crystal">def foo(x : Int32.class)
  puts &quot;Got Int32&quot;
end

def foo(x : String.class)
  puts &quot;Got String&quot;
end

foo Int32  # prints &quot;Got Int32&quot;
foo String # prints &quot;Got String&quot;
</code></pre>
<h2 id="元组展开中的类型限制"><a class="header" href="#元组展开中的类型限制">元组展开中的类型限制</a></h2>
<p>你可以指定不定数目参数的类型限制：</p>
<pre><code class="language-crystal">def foo(*args : Int32)
end

def foo(*args : String)
end

foo 1, 2, 3       # OK, 调用第一个重载
foo &quot;a&quot;, &quot;b&quot;, &quot;c&quot; # OK, 调用第二个重载
foo 1, 2, &quot;hello&quot; # Error
foo()             # Error
</code></pre>
<p>当指定类型时，元组中所有的参数都要匹配这个类型。另外，空元组不会匹配上面任何一种类型。如果你要指定空元组的情况，就再加一个重载：</p>
<pre><code class="language-crystal">def foo
  # This is the empty-tuple case
end
</code></pre>
<p>一种匹配一个或多个任意类型参数的方法是用 <code>Object</code> 做限制：</p>
<pre><code class="language-crystal">def foo(*args : Object)
end

foo() # Error
foo(1) # OK
foo(1, &quot;x&quot;) # OK
</code></pre>
<h2 id="类型参数"><a class="header" href="#类型参数">类型参数</a></h2>
<p>你可以用<code>forall</code>关键字让类型限制拥有类型参数 :</p>
<pre><code class="language-crystal">def foo(x : T) forall T
  T
end

foo(1)       #=&gt; Int32
foo(&quot;hello&quot;) #=&gt; String
</code></pre>
<p>此时， <code>T</code> 成为了用于实例化方法的类型。</p>
<p>一个类型变量可以用于抽取出泛型类型限制中的参数类型：</p>
<pre><code class="language-crystal">def foo(x : Array(T)) forall T
  T
end

foo([1, 2])   #=&gt; Int32
foo([1, &quot;a&quot;]) #=&gt; (Int32 | String)
</code></pre>
<p>为了创建接受类型名(而不是实例)的方法，就给这个类型变量加 <code>.class</code>：</p>
<pre><code class="language-crystal">def foo(x : T.class) forall T
  Array(T)
end

foo(Int32)  #=&gt; Array(Int32)
foo(String) #=&gt; Array(String)
</code></pre>
<p>一个类型参数如果出现在多处，那就意味着这些地方的类型必须是同一个：</p>
<pre><code class="language-crystal">def push(element : T, array : Array(T)) forall T
  array &lt;&lt; element
end

push(4, [1, 2, 3]) # OK
push(&quot;oops&quot;, [1, 2, 3]) # Error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h1>
<p>编译器可以推出来一个方法的返回类型。但是因为以下两个原因，你应当手动确定它：</p>
<ol>
<li>保证这个方法返回了你想要的类型</li>
<li>让它在帮助文档中出现</li>
</ol>
<p>例如：</p>
<pre><code class="language-crystal">def some_method : String
  &quot;hello&quot;
end
</code></pre>
<p>返回类型也遵循<a href="syntax_and_semantics/type_grammar.html">类型语法</a>.</p>
<h2 id="nil-返回类型"><a class="header" href="#nil-返回类型">Nil 返回类型</a></h2>
<p>标志一个方法返回 <code>Nil</code> 会让他把任何实际返回的值都丢弃，只剩一个 <code>nil</code> 。</p>
<pre><code class="language-crystal">def some_method : Nil
  1 + 2
end

some_method # =&gt; nil
</code></pre>
<p>这在两种情况下很有用：</p>
<ol>
<li>保证这个方法返回 <code>nil</code> 而不用在每个返回的地点都加一个 <code>nil</code></li>
<li>在文档中指出：这个方法的返回值没有意义</li>
</ol>
<p>这些方法的返回值没有意义，因此它们通过副作用发挥功能。</p>
<p>用 <code>Void</code> 类型标识可以起到同样的效果，但是 <code>Nil</code> 更加理想。 <code>Void</code> 适合在 C 绑定中使用。</p>
<h2 id="noreturn-返回类型"><a class="header" href="#noreturn-返回类型">NoReturn 返回类型</a></h2>
<p>一些表达式不可能回到当前的作用域，因此它们根本不会返回(区别于上面有返回值但是没意义的情况)这种表达式用特殊的返回类型<code>NoReturn</code>表示。</p>
<p>典型的无返回值的方法和关键词有 <code>return</code>，<code>exit</code>，<code>raise</code>，<code>next</code>，和 <code>break</code>。</p>
<p>这常用于解构联合类型：</p>
<pre><code>string = STDIN.gets
typeof(string)                        # =&gt; String?
typeof(raise &quot;Empty input&quot;)           # =&gt; NoReturn
typeof(string || raise &quot;Empty input&quot;) # =&gt; String
</code></pre>
<p>编译器会知道当变量 <code>string</code>是 <code>Nil</code>类型时，表达式 <code>string || raise</code>的右边会被求值。因为 <code>typeof(raise &quot;Empty input&quot;)</code> 是 <code>NoReturn</code>，这个表达式执行起来根本不会到达当前的作用域。所以表达式求值剩下的类型就是 <code>String</code>。</p>
<p>如果一个表达式所有的可能都导致 <code>NoReturn</code> ，它自己也会是 <code>NoReturn</code>类型。 <code>NoReturn</code>不会在联合类型中出现，因为它实际上寓于所有类型之中。只有要确认当前表达式不会返回，这个类型才会被写出来。</p>
<blockquote>
<p>译注：从类型代数的角度说，它是所有类型的<a href="syntax_and_semantics/">始对象</a>，拥有从他产生任何类型的能力(在程序中也许是rescue?)，但是它不能从任何类型构造。这种类型在C/C++中用<code>[[noreturn]]</code>属性标识，在Haskell中称为<code>Void</code>。对应的，<code>Nil</code> 被称为<a href="https://encyclopediaofmath.org/wiki/Final_object">终对象</a>，可以从任何类型构造它，这类似于函数式语言中的<code>unit</code>或<code>()</code>。 更详细的内容可以参考 <a href="https://github.com/hmemcpy/milewski-ctfp-pdf">给程序员的范畴论</a></p>
</blockquote>
<p><code>NoReturn</code> 可以显式地设为方法或函数的返回类型，不过往往也能被编译器推出来。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法形参详述"><a class="header" href="#方法形参详述">方法形参详述</a></h1>
<p>这是方法和调用所用参数的形式规定。</p>
<h2 id="方法定义的组成"><a class="header" href="#方法定义的组成">方法定义的组成</a></h2>
<p>一个方法定义有如下部分：</p>
<ul>
<li>要求和可选的位置参数</li>
<li>可选的不定长参数(splat)，它的名字可以为空</li>
<li>要求和可选的命名参数</li>
<li>可选的键值对(double splat)参数</li>
</ul>
<p>例如：</p>
<pre><code class="language-crystal">def foo(
  # 这些是位置参数:
  x, y, z = 1,
  # 这是不定长参数:
  *args,
  # 这是命名参数:
  a, b, c = 2,
  # 这是键值对参数:
  **options
  )
end
</code></pre>
<p>他们每一个都是可选的，所以一个方法没有谁都可以，不论是位置参数，不定长参数，命名参数和键值对参数。</p>
<h2 id="方法调用的组成"><a class="header" href="#方法调用的组成">方法调用的组成</a></h2>
<p>一个方法调用应当有如下部分:</p>
<pre><code class="language-crystal">foo(
  # 这些是位置参数
  1, 2,
  # 这些是命名参数
  a: 1, b: 2
)
</code></pre>
<p>另外，调用参数中也可以有展开 (<code>*</code>) 或双展开 (<code>**</code>)。 展开把<a href="syntax_and_semantics/literals/tuple.html">元组</a> 展开填充进位置参数里，双展开则把一个 <a href="syntax_and_semantics/literals/named_tuple.html">命名元组</a> 填充进命名参数里。方法调用中可以有多个展开式。</p>
<h2 id="调用实参如何匹配到方法形参上"><a class="header" href="#调用实参如何匹配到方法形参上">调用实参如何匹配到方法形参上</a></h2>
<p>当调用一个方法时，匹配形参和实参的算法是：</p>
<ul>
<li>
<p>首先匹配位置参数，实参的数量至少等于没有初始值的形参的数量。如果方法以具名的元组接受不定长参数(不具名的情况稍等)，那么实参可以多于形参，多出的部分会保存在那个元组之中。位置参数不会超过不定长参数的位置。</p>
</li>
<li>
<p>然后匹配命名参数，它们按名称匹配到任何地方(在不定长参数的前面和后面都可以)。如果这个参数已经被位置参数填充了，那么会产生错误。</p>
</li>
<li>
<p>额外的命名参数会作为<a href="syntax_and_semantics/literals/named_tuple.html">命名元组</a> 打包进键值对参数中。如果键值对参数不存在，就会产生错误。</p>
</li>
</ul>
<p>如果不定长参数没有名字，那这意味着它不再接受额外的位置参数，它之后的参数必须以命名参数的形式传递。例如：</p>
<pre><code class="language-crystal"># 只允许一个位置参数, y 必须按名称传递
def foo(x, *, y)
end

foo 1 # 错误, 缺少参数: y
foo 1, 2 # 错误: 参数数目不对 (给出 2, 应得 1)
foo 1, y: 10 # OK
</code></pre>
<p>不过即使不定长参数有名字，它之后的参数也只能按名称传递(因为他把后面所有的位置参数都吸走了)：</p>
<pre><code class="language-crystal"># 可以允许一个或多个位置参数, 但 y 必须按名称传递
def foo(x, *args, y)
end

foo 1 # 错误: 缺少参数: y
foo 1, 2 # 错误: 缺少参数; y
foo 1, 2, 3 # 错误: 缺少参数: y
foo 1, y: 10 # OK
foo 1, 2, 3, y: 4 # OK
</code></pre>
<p>也可以上一个方法只接受命名参数，只要把星号放到最前面就行了：</p>
<pre><code class="language-crystal"># 一个方法，只接受两个命名参数: x 和 y
def foo(*, x, y)
end

foo # 错误: 缺少参数: x, y
foo x: 1 # 错误: 缺少参数: y
foo x: 1, y: 2 # OK
</code></pre>
<p>星号后面的参数也可以有默认值。这意味着它们必须按名称传递，但不是非要给出(即：可选的命名参数)：</p>
<pre><code class="language-crystal"># 一个方法，接受两个命名参数: x 和 y, 其中 y 有默认值
def foo(*, x, y = 2)
end

foo # 错误: 缺少参数: x
foo x: 1 # OK, y 是 2
foo x: 1, y: 3 # OK, y 是 3
</code></pre>
<p>因为星号后,没有初始值的命名参数必须按名称传递，所以接受不同名参数的两个同名方法是<em>不同</em>的，它们会彼此重载：</p>
<pre><code class="language-crystal">def foo(*, x)
  puts &quot;获得 x: #{x}&quot;
end

def foo(*, y)
  puts &quot;获得 y: #{y}&quot;
end

foo x: 1 # =&gt; 获得 x: 1
foo y: 2 # =&gt; 获得 y: 2
</code></pre>
<p>位置参数也可以按名称传递：</p>
<pre><code class="language-crystal">def foo(x, *, y)
end

foo 1, y: 2 # OK
foo y: 2, x: 3 # OK
</code></pre>
<h2 id="外部名称"><a class="header" href="#外部名称">外部名称</a></h2>
<p>方法形参可以指定内部名称和外部名称。外部名称是传递参数时使用名字，而内部名称是仅在这个方法定义内使用的名字：</p>
<pre><code class="language-crystal">def foo(external_name internal_name)
  # 这里我们使用 internal_name
end

foo external_name: 1
</code></pre>
<p>这有两种使用场景。</p>
<p>第一种情况是，我们想用关键词当命名参数的名字：</p>
<pre><code class="language-crystal">def plan(begin begin_time, end end_time)
  puts &quot;计划日程，从 #{begin_time} 到 #{end_time}&quot;
end

plan begin: Time.now, end: 2.days.from_now
</code></pre>
<p>另一种情况是让方法形参在方法体内读起来更自然(相对地，外部名称就可以输起来更自然)：</p>
<pre><code class="language-crystal">def increment(value, by)
  # 行, 只是读着怪
  value + by
end

def increment(value, by amount)
  # 舒适
  value + amount
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符"><a class="header" href="#运算符">运算符</a></h1>
<p><code>+</code> 和 <code>-</code> 这样的运算符也是方法调用。例如：</p>
<pre><code class="language-crystal">a + b
</code></pre>
<p>等同于</p>
<pre><code class="language-crystal">a.+(b)
</code></pre>
<p>你可以如此定义一个运算符：</p>
<pre><code class="language-crystal">struct Vector2
  getter x, y

  def initialize(@x : Int32, @y : Int32)
  end

  def +(other)
    Vector2.new(x + other.x, y + other.y)
  end
end

v1 = Vector2.new(1, 2)
v2 = Vector2.new(3, 4)
v1 + v2               #=&gt; Vector2(@x=4, @y=6)
</code></pre>
<p>下面展示了所有的运算符及它们的意义。</p>
<h2 id="单目运算符"><a class="header" href="#单目运算符">单目运算符</a></h2>
<pre><code class="language-crystal">+   # 正号
-   # 负号
!   # 逻辑非
~   # 按位取反
</code></pre>
<p>它们的定义不带参数。例如：</p>
<pre><code class="language-crystal">struct Vector2
  def -
    Vector2.new(-x, -y)
  end
end

v1 = Vector2.new(1, 2)
-v1                    #=&gt; Vector2(@x=-1, @y=-2)
</code></pre>
<p><strong>注意:</strong> <code>!</code> (非) 不能被定义为方法，即它的意义不能被改变。</p>
<h2 id="双目运算符"><a class="header" href="#双目运算符">双目运算符</a></h2>
<ul>
<li><code>+</code> – 加法</li>
<li><code>-</code> – 减法</li>
<li><code>*</code> – 乘法</li>
<li><code>/</code> – 除法</li>
<li><code>%</code> – 取模</li>
<li><code>&amp;</code> – 位与</li>
<li><code>|</code> – 位或</li>
<li><code>^</code> – 位异或</li>
<li><code>**</code> – 指数</li>
<li><code>&lt;&lt;</code> – 左移，添加</li>
<li><code>&gt;&gt;</code> – 右移</li>
<li><code>==</code> – 等于</li>
<li><code>!=</code> – 不等于</li>
<li><code>&lt;</code> – 小于</li>
<li><code>&lt;=</code> – 小于等于</li>
<li><code>&gt;</code> – 大于</li>
<li><code>&gt;=</code> – 大于等于</li>
<li><code>&lt;=&gt;</code> – 三相比较</li>
<li><code>===</code> – <a href="syntax_and_semantics/case.html">匹配</a></li>
</ul>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<pre><code class="language-crystal">[]  # 数组/散列索引 (越界时抛出异常)
[]? # 数组/散列索引 (越界时返回nil)
[]= # 数组/散列索引赋值
</code></pre>
<p>例如：</p>
<pre><code class="language-crystal">class MyArray
  def [](index)
    # ...
  end

  def [](index1, index2, index3)
    # ...
  end

  def []=(index, value)
    # ...
  end
end

array = MyArray.new

array[1]       # 调用第一个方法
array[1, 2, 3] # 调用第二个方法
array[1] = 2   # 调用第三个方法

array.[](1)       # 调用第一个方法
array.[](1, 2, 3) # 调用第二个方法
array.[]=(1, 2)   # 调用第三个方法
</code></pre>
<h2 id="意义"><a class="header" href="#意义">意义</a></h2>
<p>你可以为运算符指定任何意义。但是为了代码可读性或者可解释性，你应当遵守上述约定。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可见性"><a class="header" href="#可见性">可见性</a></h1>
<p>方法默认是公开的：编译期总会让你调用它，即使你没加 <code>public</code>关键字。</p>
<p>方法可以被标记为 <code>private</code>或 <code>protected</code>。</p>
<h2 id="私有方法"><a class="header" href="#私有方法">私有方法</a></h2>
<p><code>private</code> 方法调用时不能有接受者。意思是没有点号前面的东西：</p>
<pre><code class="language-crystal">class Person
  private def say(message)
    puts message
  end

  def say_hello
    say &quot;hello&quot; # OK, 没有接受者
    self.say &quot;hello&quot; # 错误, self 是接受者

    other = Person.new &quot;Other&quot;
    other.say &quot;hello&quot; # 错误, 是接受者
  end
end
</code></pre>
<p>注意 <code>private</code> 方法对子类型可见：</p>
<pre><code class="language-crystal">class Employee &lt; Person
  def say_bye
    say &quot;bye&quot; # OK
  end
end
</code></pre>
<h2 id="私有类型"><a class="header" href="#私有类型">私有类型</a></h2>
<p>私有类型只能在它们被定义的命名空间中被提及，并且永远不能被完全注明(即从顶层命名空间找到)。</p>
<pre><code class="language-crystal">class Foo
  private class Bar
  end

  Bar      # OK
  Foo::Bar # Error
end

Foo::Bar # Error
</code></pre>
<p><code>private</code> 可以应用于 <code>class</code>，<code>module</code>，<code>lib</code>，<code>enum</code>，<code>alias</code>和常量：</p>
<pre><code class="language-crystal">class Foo
  private ONE = 1

  ONE # =&gt; 1
end

Foo::ONE # Error
</code></pre>
<h2 id="保护方法"><a class="header" href="#保护方法">保护方法</a></h2>
<p><code>protected</code>只能被这样调用：</p>
<ol>
<li>当前类型的实例</li>
<li>当前类型所在命名空间中的实例</li>
</ol>
<pre><code class="language-crystal">### 例 1

class Person
  protected def say(message)
    puts message
  end

  def say_hello
    say &quot;hello&quot; # OK, self 是 Person, 尽管没有写出
    self.say &quot;hello&quot; # OK, self 是 Person

    other = Person.new &quot;Other&quot;
    other.say &quot;hello&quot; # OK, other 是 Person
  end
end

class Animal
  def make_a_person_talk
    person = Person.new
    person.say &quot;hello&quot; # 错误, person 是 Person
                       # 但当前类型是 Animal
  end
end

one_more = Person.new &quot;One more&quot;
one_more.say &quot;hello&quot; # 错误, one_more 是 Person
                     # 但当前类型是 Program 整个程序

### 例 2

module Namespace
  class Foo
    protected def foo
      puts &quot;Hello&quot;
    end
  end

  class Bar
    def bar
      # 行, 因为 Foo 和 Bar 都处于 Namespace 中
      Foo.new.foo
    end
  end
end

Namespace::Bar.new.bar
</code></pre>
<p><code>protected</code> 类方法可以从实例方法调用，或是其他周转的方法：</p>
<pre><code class="language-crystal">class Person
  protected def self.say(message)
    puts message
  end

  def say_hello
    Person.say &quot;hello&quot; # OK
  end
end
</code></pre>
<h2 id="私有的顶层方法"><a class="header" href="#私有的顶层方法">私有的顶层方法</a></h2>
<p><code>private</code>顶层方法只在当前文档中可见。</p>
<pre><code class="language-crystal"># 在文件 one.cr 中
private def greet
  puts &quot;Hello&quot;
end

greet #=&gt; &quot;Hello&quot;

# 在文件 two.cr 中
require &quot;./one&quot;

greet # 未定义的局部变量或方法 'greet'
</code></pre>
<p>这可以帮助你把辅助方法局限在这个文档中，如果他们不应暴露出去。</p>
<h2 id="私有的顶层类型"><a class="header" href="#私有的顶层类型">私有的顶层类型</a></h2>
<p><code>private</code>顶层类型只在当前文档中可见。</p>
<pre><code class="language-crystal"># 在文件 one.cr 中
private class Greeter
  def self.greet
    &quot;Hello&quot;
  end
end

Greeter.greet #=&gt; &quot;Hello&quot;

# 在文件 two.cr 中
require &quot;./one&quot;

Greeter.greet # 未定义的常量 'Greeter'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="继承"><a class="header" href="#继承">继承</a></h1>
<p>每个类，除了 <code>Object</code>这个继承体系的根基，都继承于另一个类(它的超类)。如果你不指定它，那么它对类默认是<code>Reference</code>，对结构体默认是<code>Struct</code>。</p>
<p>一个类继承超类的所有成员变量，示例和类方法。包括它的构造函数 (<code>new</code>和 <code>initialize</code>)。</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end

  def greet
    puts &quot;Hi, I'm #{@name}&quot;
  end
end

class Employee &lt; Person
end

employee = Employee.new &quot;John&quot;
employee.greet # &quot;Hi, I'm John&quot;
</code></pre>
<p>如果一个类定义了 <code>new</code>或 <code>initialize</code>，那么它的超类的构造函数就不会被继承：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end
end

class Employee &lt; Person
  def initialize(@name : String, @company_name : String)
  end
end

Employee.new &quot;John&quot;, &quot;Acme&quot; # OK
Employee.new &quot;Peter&quot; # 错误: 参数个数不匹配
                     # 于 'Employee:Class#new' (所需 2, 已给 1)
</code></pre>
<p>你可以在派生类中覆盖方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hi, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg)
    puts &quot;Hello, #{msg}&quot;
  end
end

p = Person.new
p.greet &quot;everyone&quot; # &quot;Hi, everyone&quot;

e = Employee.new
e.greet &quot;everyone&quot; # &quot;Hello, everyone&quot;
</code></pre>
<p>你可以对方法指定类型限制将其特化，以避免重载超类的方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hi, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg : Int32)
    puts &quot;Hi, this is a number: #{msg}&quot;
  end
end

e = Employee.new
e.greet &quot;everyone&quot; # &quot;Hi, everyone&quot;

e.greet 1 # &quot;Hi, this is a number: 1&quot;
</code></pre>
<h2 id="超类"><a class="header" href="#超类">超类</a></h2>
<p>你可以用 <code>super</code> 指定调用超类的方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hello, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg)
    super # 等同于: super(msg)
    super(&quot;another message&quot;)
  end
end
</code></pre>
<p>如果没有参数或括号， <code>super</code>接受该方法相同的参数。如果有，它就会接受你指定给它的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚类型和抽象类型"><a class="header" href="#虚类型和抽象类型">虚类型和抽象类型</a></h1>
<p>当变量的类型是同一等级下的多种类型的组合时，它的类型就是<strong>虚类型</strong>。这对于除了<code>Reference</code>，<code>Value</code>，<code>Int</code> 和 <code>Float</code>之外的所有类型均适用。例如：</p>
<pre><code class="language-crystal">class Animal
end

class Dog &lt; Animal
  def talk
    &quot;Woof!&quot;
  end
end

class Cat &lt; Animal
  def talk
    &quot;Miau&quot;
  end
end

class Person
  getter pet

  def initialize(@name : String, @pet : Animal)
  end
end

john = Person.new &quot;John&quot;, Dog.new
peter = Person.new &quot;Peter&quot;, Cat.new
</code></pre>
<p>如果你加上 <code>tool hierarchy</code> 参数来编译该文档，你会发现，在 <code>Person</code>的部分：</p>
<pre><code>- class Object
  |
  +- class Reference
     |
     +- class Person
            @name : String
            @pet : Animal+
</code></pre>
<p>你可以看到 <code>@pet</code> 类型是 <code>Animal+</code>。 其中 <code>+</code> 意味着它是一个虚类型，意思是“任何继承 <code>Animal</code> 的类型，包括<code>Animal</code>”。</p>
<p>编译器总会把同一等级下的联合类型处理成虚类型：</p>
<pre><code>if some_condition
  pet = Dog.new
else
  pet = Cat.new
end

# pet : Animal+
</code></pre>
<p>同样地，编译器会尝试这些事情：如果多个类型在同一层类型体系下可以找到公共的超类(除了<code>Reference</code>，<code>Value</code>，<code>Int</code> 和 <code>Float</code>)，那么就把它的类型设为对应的虚类型。否则就保留联合类型。</p>
<p>编译器这么做的理由是为了免于创建多种相近的联合类型，更快地编译程序，同时使产生的代码减小。另一方面，这也有意义：在同一等级下的多个类应当有详尽的行为。</p>
<p>现在我们让 John 的宠物叫两声：</p>
<pre><code class="language-crystal">john.pet.talk # 错误: Animal 没有定义方法 'talk' 
</code></pre>
<p>这个错误之所以产生，是因为编译器把<code>@pet</code>视为<code>Animal+</code>，因此它可能是 <code>Animal</code>。可<code>Animal</code>下面又没有定义<code>talk</code>方法。</p>
<p>然而我们比编译器多知道： <code>Animal</code> 永远不会被实例化，因为这一个实例不会有任何意义。我们要用<code>abstract</code>关键字告诉编译器这个类是抽象的： </p>
<pre><code class="language-crystal">abstract class Animal
end
</code></pre>
<p>现在代码可以通过编译:</p>
<pre><code class="language-crystal">john.pet.talk #=&gt; &quot;Woof!&quot;
</code></pre>
<p>把类标记为抽象类可以阻止人创建它的示例:</p>
<pre><code class="language-crystal">Animal.new # 错误: 不能创建抽象类 Animal 的实例
</code></pre>
<p>如果我们要显式地说明 <code>Animal</code>必须定义有 <code>talk</code> 方法，我们可以把它作为抽象方法加进 <code>Animal</code> 里面：</p>
<pre><code class="language-crystal">abstract class Animal
  # 要求动物能叫，即定义方法 talk
  abstract def talk
end
</code></pre>
<p>只要我们把方法标注为 <code>abstract</code> ，编译器会知道所有继承这个类的类型都要包含这个方法，即使程序没有用到它</p>
<p>抽象方法也可以定义于模块中，这样编译器会检查所有包含这个模块的类型，要求它们必须定义这个方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类方法"><a class="header" href="#类方法">类方法</a></h1>
<p>类方法是类和模块本身所拥有的方法，而不是示例所拥有的。</p>
<pre><code class="language-crystal">module CaesarCipher
  def self.encrypt(string : String)
    string.chars.map{ |char| ((char.upcase.ord - 52) % 26 + 65).chr }.join
  end
end

CaesarCipher.encrypt(&quot;HELLO&quot;) # =&gt; &quot;URYYB&quot;
</code></pre>
<p>类方法可以以<code>类型名.方法名</code>的形式定义。</p>
<pre><code class="language-crystal">def CaesarCipher.decrypt(string : String)
  encrypt(string)
end
</code></pre>
<p>当在模块和类内部定义类方法时用 <code>self</code>代替类型名更加方便。</p>
<p>类方法可以由 <a href="syntax_and_semantics/modules.html#extend-self">extend 一个模块</a>的方式定义。</p>
<p>类方法可以由其定义时所用的名字调用 (<code>CaesarCipher.decrypt(&quot;HELLO&quot;)</code>)。当在同一个类和模块域调用时，接收者可以是 <code>self</code> 或者隐含的<code>self</code> (像 <code>encrypt(string)</code>)。</p>
<h1 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h1>
<p>构造函数也是类方法，但是拥有 <a href="syntax_and_semantics/new,_initialize_and_allocate.html">创建类的新实例</a>的功能。</p>
<p>Crystal中的所有类型一般至少有一个叫做 <code>new</code>的构造函数，但他们也可以定义不同名字的构造函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类变量"><a class="header" href="#类变量">类变量</a></h1>
<p>类变量由类所有，而不由对象所有。它们以双&quot;at&quot;(<code>@@</code>)开头。例如：</p>
<pre><code class="language-crystal">class Counter
  @@instances = 0

  def initialize
    @@instances += 1
  end

  def self.instances
    @@instances
  end
end

Counter.instances #=&gt; 0
Counter.new
Counter.new
Counter.new
Counter.instances #=&gt; 3
</code></pre>
<p>类变量可以由类方法和实例方法读写。</p>
<p>它们的类型也可以被 <a href="syntax_and_semantics/type_inference.html">全局类型推导规则</a>推导。</p>
<p>类变量也可以继承，并遵循如下规则：它们的名称是一样的，但是每个类都分别含有一个运行时的值。例如：</p>
<pre><code class="language-crystal">class Parent
  @@numbers = [] of Int32

  def self.numbers
    @@numbers
  end
end

class Child &lt; Parent
end

Parent.numbers # =&gt; []
Child.numbers # =&gt; []

Parent.numbers &lt;&lt; 1
Parent.numbers # =&gt; [1]
Child.numbers # =&gt; []
</code></pre>
<p>类变量也可以从属于模块和结构体，它们也以相同的方式被包含/派生的类型继承。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalize"><a class="header" href="#finalize">finalize</a></h1>
<p>如果一个类定义了 <code>finalize</code>方法，那么它会在该类型的一个实例被回收的时候调用：</p>
<pre><code class="language-crystal">class Foo
  def finalize
    # 当 Foo 被垃圾回收时调用
    # 用于释放未托管的资源 (比如 C 动态库或结构体)
  end
end
</code></pre>
<p>用这个方法释放没有被Crystal垃圾回收器直接管理的外部资源。</p>
<p>用例可见于 <a href="https://crystal-lang.org/api/IO/FileDescriptor.html#finalize-instance-method"><code>IO::FileDescriptor#finalize</code></a>
或 <a href="https://crystal-lang.org/api/OpenSSL/Digest.html#finalize-instance-method"><code>OpenSSL::Digest#finalize</code></a>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>只有被完整初始化的对象会调用<code>finalize</code> 方法。如果<code>initialize</code>的内部有异常抛出，<code>finalize</code>就不会被调用。如果你的类型定义了 <code>finalize</code>方法，记得揽住 <code>initialize</code>中任何可能出现的异常，并在处理异常时释放资源。</p>
</li>
<li>
<p>在垃圾回收期间创建新对象是未定义行为，这往往会导致程序整体崩溃。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<p>模块有两种功能：</p>
<ul>
<li>作为命名空间容纳类型，方法和常量的定义</li>
<li>作为部分类型，用于混入(mix in)其他类型。</li>
</ul>
<p>作为命名空间的例子：</p>
<pre><code class="language-crystal">module Curses
  class Window
  end
end

Curses::Window.new
</code></pre>
<p>库作者应当把它们的定义写到模块中，以避免名称冲突。标准库则因为其中的类型十分常用，就直接放到顶层命名空间，以避免写长名称。</p>
<p>用 <code>include</code>或 <code>extend</code>将模块作为部分类型使用。</p>
<p><code>include</code> 让类型的实例拥有模块中定义的方法：</p>
<pre><code class="language-crystal">module ItemsSize
  def size
    items.size
  end
end

class Items
  include ItemsSize

  def items
    [1, 2, 3]
  end
end

items = Items.new
items.size #=&gt; 3
</code></pre>
<p>上例中，效果好像我们把size里面的<code>size</code>方法从模块中粘到 <code>Items</code> 类里面一样。这个实际上是通过让每个类型有多个祖先来完成的。这些祖先以超类开头，所有的模块都添加在排超类的<strong>后面</strong>。当类型中找不到某个方法时它就会从祖先列表中依次查找。当调用<code>super</code>时，他会用祖先列表中的第一个。</p>
<p>模块也可以包含其他模块，因此当模块中没有某个方法时，他会从包含的模块中找这个方法。</p>
<p><code>extend</code> 让一个类本身拥有模块中的方法：</p>
<pre><code class="language-crystal">module SomeSize
  def size
    3
  end
end

class Items
  extend SomeSize
end

Items.size #=&gt; 3
</code></pre>
<p><code>include</code>和 <code>extend</code> 都让模块中的常量在被包含、补全的类型中可见。</p>
<p>他们也能用于顶层命名空间以避免重复表示命名空间(同时增加命名冲突的风险)：</p>
<pre><code class="language-crystal">module SomeModule
  class SomeType
  end

  def some_method
    1
  end
end

include SomeModule

SomeType.new # OK, 等同于 SomeModule::SomeType
some_method  # OK, 1
</code></pre>
<h2 id="extend-self"><a class="header" href="#extend-self">extend self</a></h2>
<p>模块的常见用法是 <code>extend self</code>:</p>
<pre><code class="language-crystal">module Base64
  extend self

  def encode64(string)
    # ...
  end

  def decode64(string)
    # ...
  end
end
</code></pre>
<p>这种情况模块自己就像一个对象，可以用<code>.</code>而不是<code>::</code>调取其中的方法：</p>
<pre><code class="language-crystal">Base64.encode64 &quot;hello&quot; #=&gt; &quot;aGVsbG8=&quot;
</code></pre>
<p>同时它也可以在程序中被包含，以省略命名空间：</p>
<pre><code class="language-crystal">include Base64

encode64 &quot;hello&quot; #=&gt; &quot;aGVsbG8=&quot;
</code></pre>
<p>为了充分利用这个功能，方法名应当能显示所在的模块，否则命名冲突的概率就会很高。</p>
<p>模块不能被实例化：</p>
<pre><code class="language-crystal">module Moo
end

Moo.new # 未定义方法 'new' 于 Moo:Class 中
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>泛型使你可以基于其他类型制定一个参数化类型。考虑这个 Box 类型：</p>
<pre><code class="language-crystal">class MyBox(T)
  def initialize(@value : T)
  end

  def value
    @value
  end
end

int_box = MyBox(Int32).new(1)
int_box.value # =&gt; 1 (Int32)

string_box = MyBox(String).new(&quot;hello&quot;)
string_box.value # =&gt; &quot;hello&quot; (String)

another_box = MyBox(String).new(1) # 错误, Int32 不匹配 String
</code></pre>
<p>泛型常用于制作集合类型。<code>Array</code>，<code>Hash</code>，<code>Set</code> 都是泛型， <code>Pointer</code>也是。</p>
<p>类型参数可以不止一个：</p>
<pre><code class="language-crystal">class MyDictionary(K, V)
end
</code></pre>
<p>任何类型都能做类型参数：</p>
<pre><code class="language-crystal">class MyDictionary(KeyType, ValueType)
end
</code></pre>
<h2 id="类型变量推导"><a class="header" href="#类型变量推导">类型变量推导</a></h2>
<p>当不指定类型参数时，编译器会尝试由构造函数中的变量类型推导泛型类型参数。例如：</p>
<pre><code class="language-crystal">MyBox.new(1)       # : MyBox(Int32)
MyBox.new(&quot;hello&quot;) # : MyBox(String)
</code></pre>
<p>上例中我们不必指定 <code>MyBox</code>缝纫类型参数，编译器会以如下的方式确定它：</p>
<ul>
<li><code>MyBox.new(value)</code> 委派给 <code>initialize(@value : T)</code></li>
<li><code>T</code> 还没有绑定到一个类型，所以编译器把它绑定到给出参数变量的类型</li>
</ul>
<p>这样设计和构造泛型就会变得更方便。</p>
<h2 id="泛型结构体和模块"><a class="header" href="#泛型结构体和模块">泛型结构体和模块</a></h2>
<p>结构体和模块也可以是泛型。当模块是泛型时你可以这样包括它：</p>
<pre><code class="language-crystal">module Moo(T)
  def t
    T
  end
end

class Foo(U)
  include Moo(U)

  def initialize(@value : U)
  end
end

foo = Foo.new(1)
foo.t # Int32
</code></pre>
<p>注意，上例中因为<code>Foo.new(1)</code> 表明了 <code>U</code> 是 <code>Int32</code>，所以 <code>T</code> 是 <code>Int32</code> ，继而在包含的模块中 <code>T</code> 也是 <code>Int32</code>。</p>
<h2 id="泛型类型继承"><a class="header" href="#泛型类型继承">泛型类型继承</a></h2>
<p>泛型类和结构体也可以继承。当继承时你可以指定一个泛型实例，也可以把类型变量传递出去：</p>
<pre><code class="language-crystal">class Parent(T)
end

class Int32Child &lt; Parent(Int32)
end

class GenericChild(T) &lt; Parent(T)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体structs"><a class="header" href="#结构体structs">结构体(Structs)</a></h1>
<p>除了用 <code>class</code>定义类型，你还可以用 <code>struct</code>：</p>
<pre><code class="language-crystal">struct Point
  property x, y

  def initialize(@x : Int32, @y : Int32)
  end
end
</code></pre>
<p>结构体和类的区别是：</p>
<ul>
<li>对结构体调用 <code>new</code> 会把它分配到栈上(而不是堆上)</li>
<li>结构体 <a href="http://crystal-lang.org/api/Value.html">按值传递</a>,而类按引用传递</li>
<li>结构体继承 <a href="http://crystal-lang.org/api/Struct.html">Struct</a>，而<code>Struct</code>又继承 <a href="http://crystal-lang.org/api/Value.html">Value</a>。类隐式地继承 <a href="http://crystal-lang.org/api/Reference.html">Reference</a>。</li>
<li>结构体不能继承一个非抽象的结构体。</li>
</ul>
<p>最后一点原因在于：结构体有准确的内存布局。例如，上面的 <code>Point</code> 占有 8字节。如果你有一个 points 数组，那么这些点就会被直接嵌到这个数组的空间中：</p>
<pre><code class="language-crystal"># 数组给每个Point分配8字节
ary = [] of Point
</code></pre>
<p>如果 <code>Point</code> 被继承，那么这个类型的数组必须知道它里面可能有类型的对象，所以每个元素的大小必须增长，以容纳这些对象，而这不是我们期望的。因此，非抽象的结构体不能被继承。对应地，抽象的结构体可以有子类，一个由它们构成的数组可以考虑其中所有可能的类型。</p>
<p>像类一样，结构体也可以包含模块，也可以是泛型。</p>
<p>结构体常用于优化性能：如果对象按值传递的代价也不大，那么直接在栈上分配它们可以减少频繁分配内存的损耗。</p>
<p>所以你要如何选择定义结构体还是类？凭经验来说，如果没有成员变量被重新赋值，即，你的类型是不可变的，那就定义成结构体；反之则定义成类。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量"><a class="header" href="#常量">常量</a></h1>
<p>常量可以在顶层或是其他类型内定义，它们必须以大写字母开头：</p>
<pre><code class="language-crystal">PI = 3.14

module Earth
  RADIUS = 6_371_000
end

PI #=&gt; 3.14
Earth::RADIUS #=&gt; 6_371_000
</code></pre>
<p>虽然编译器不强制，但常量往往以全大写 + 下划线构成。</p>
<p>常量定义中可以调用方法，也可以有复杂的逻辑：</p>
<pre><code class="language-crystal">TEN = begin
  a = 0
  while a &lt; 10
    a += 1
  end
  a
end

TEN #=&gt; 10
</code></pre>
<h1 id="伪常量"><a class="header" href="#伪常量">伪常量</a></h1>
<p>Crystal 提供了一些伪常量，以反射源代码中的信息：</p>
<p><code>__LINE__</code> 是当前执行中的crystal 文件中的当前行号。当 <code>__LINE__</code> 被声明为方法的默认值时，它表示方法调用时的行号。</p>
<p><code>__END_LINE__</code> 表示当前块的 <code>end</code> 所在的行号。它只能用于方法的默认值。</p>
<p><code>__FILE__</code> 当前所执行文档的完整路径。</p>
<p><code>__DIR__</code> 表示当前执行中的文件所在目录的完整路径。</p>
<pre><code class="language-crystal"># 假设这些代码保存于: /crystal_code/pseudo_constants.cr
#
def pseudo_constants(caller_line = __LINE__, end_of_caller = __END_LINE__)
  puts &quot;Called from line number: #{caller_line}&quot;
  puts &quot;Currently at line number: #{__LINE__}&quot;
  puts &quot;End of caller block is at: #{end_of_caller}&quot;
  puts &quot;File path is: #{__FILE__}&quot;
  puts &quot;Directory file is in: #{__DIR__}&quot;
end


begin
  pseudo_constants
end

# 程序输出:
# Called from line number: 13
# Currently at line number: 5
# End of caller block is at: 14
# File path is: /crystal_code/pseudo_constants.cr
# Directory file is in: /crystal_code
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>枚举是一系列与名称相绑定的整数值。例如：</p>
<pre><code class="language-crystal">enum Color
  Red
  Green
  Blue
end
</code></pre>
<p>以 <code>enum</code>关键字定义枚举。先写关键字，后面接名称。枚举体内包含它们的值，默认从<code>0</code>开始，每次加1，不过这个默认值可以覆盖：</p>
<pre><code class="language-crystal">enum Color
  Red         # 0
  Green       # 1
  Blue   = 5  # 覆盖到 5
  Yellow      # 6 (5 + 1)
end
</code></pre>
<p>枚举中的每个常量都属于该枚举类型：</p>
<pre><code class="language-crystal">Color::Red #:: Color
</code></pre>
<p>用 <code>value</code>取得它所代表的值：</p>
<pre><code class="language-crystal">Color::Green.value #=&gt; 1
</code></pre>
<p>枚举的底层类型默认是 <code>Int32</code> ，但可以修改：</p>
<pre><code class="language-crystal">enum Color : UInt8
  Red
  Green
  Blue
end

Color::Red.value #:: UInt8
</code></pre>
<p>只有整数枚举可以设置底层类型。</p>
<p>所有的枚举都继承 <a href="http://crystal-lang.org/api/Enum.html">Enum</a>。</p>
<h2 id="位枚举"><a class="header" href="#位枚举">位枚举</a></h2>
<p>枚举可以加 <code>@[Flags]</code> 属性。这会改变基础值和增加方式：</p>
<pre><code class="language-crystal">@[Flags]
enum IOMode
  Read # 1
  Write  # 2
  Async # 4
end
</code></pre>
<p><code>@[Flags]</code>属性让初始值设为 <code>1</code>，后继的每个值都是原值乘以 <code>2</code>的积。</p>
<p>这种枚举还会隐式地拥有两个额外变量 <code>None</code>和 <code>All</code>。 <code>None</code> 的值为 <code>0</code> ， <code>All</code>有所有常量(以位或运算)合并的积。</p>
<pre><code class="language-crystal">IOMode::None.value #=&gt; 0
IOMode::All.value  #=&gt; 7
</code></pre>
<p>同时， <code>Enum</code>的某些方法会查看 <code>@[Flags]</code> 属性，并改变自身的行为。例如：</p>
<pre><code class="language-crystal">puts(Color::Red)                    # 打印 &quot;Red&quot;
puts(IOMode::Write | IOMode::Async) # 打印 &quot;Write, Async&quot;
</code></pre>
<h2 id="从整数构造枚举"><a class="header" href="#从整数构造枚举">从整数构造枚举</a></h2>
<p>所有的枚举都可以由整数构造：</p>
<pre><code class="language-crystal">puts Color.new(1) #=&gt; 打印 &quot;Green&quot;
</code></pre>
<p>不是枚举中元素的的值也可以输入，同样拥有 <code>Color</code>类型。但是如果你打印它，就会得到它隐含的值：</p>
<pre><code class="language-crystal">puts Color.new(10) #=&gt; 打印 &quot;10&quot;
</code></pre>
<p>这个方法主要用于把C枚举转为Crystal枚举。</p>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>类似于结构体，你可以给枚举定义方法：</p>
<pre><code class="language-crystal">enum Color
  Red
  Green
  Blue

  def red?
    self == Color::Red
  end
end

Color::Red.red?  #=&gt; true
Color::Blue.red? #=&gt; false
</code></pre>
<p>枚举可以有类变量，但不可以有成员变量。</p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>枚举是类型安全的 <a href="http://crystal-lang.org/api/Symbol.html">符号</a>替代品。例如，一个 API的方法可以用枚举类型确定 <a href="syntax_and_semantics/type_restrictions.html">类型限制</a>：</p>
<pre><code class="language-crystal">def paint(color : Color)
  case color
  when Color::Red
    # ...
  else
    # 罕见，但有可能发生
    raise &quot;unknown color: #{color}&quot;
  end
end

paint Color::Red
</code></pre>
<p>上式也可以用 Symbol 实现：</p>
<pre><code class="language-crystal">def paint(color : Symbol)
  case color
  when :red
    # ...
  else
    raise &quot;unknown color: #{color}&quot;
  end
end

paint :red
</code></pre>
<p>但是，如果程序员错打成 <code>:reed</code>，那这个错误会在运行时出现，但尝试输入 <code>Color::Reed</code>会导致编译错误。</p>
<p>我们推荐在任何可能的地方都用枚举，只在API内部实现中使用符号，而避免在公共API中使用。不过你可以按你的意愿来决定如何使用它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="块和闭包"><a class="header" href="#块和闭包">块和闭包</a></h1>
<p>方法可以接受一个程序块，然后用 <code>yield</code>关键字执行它。例如：</p>
<pre><code class="language-crystal">def twice
  yield
  yield
end

twice do
  puts &quot;Hello!&quot;
end
</code></pre>
<p>上面的例子会打印 &quot;Hello!&quot;两次，每个 <code>yield</code>一次。</p>
<p>为了接受一个带有块的方法，只要在方法体中加入 <code>yield</code>，然后编译器会明白你的意图。 你可以加入一个块参数来让更明显地表述。块参数应当写在最后，并在名字前面加与号 (<code>&amp;</code>)：</p>
<pre><code class="language-crystal">def twice(&amp;block)
  yield
  yield
end
</code></pre>
<p>为了向这些方法传入块参数，你可以写 <code>do ... end</code> 或是 <code>{ ... }</code>，这两种写法等价：</p>
<pre><code class="language-crystal">twice() do
  puts &quot;Hello!&quot;
end

twice do
  puts &quot;Hello!&quot;
end

twice { puts &quot;Hello!&quot; }
</code></pre>
<p><code>do ... end</code> 和 <code>{ ... }</code> 之间的区别是 <code>do ... end</code> 绑定到最左面的调用，而 <code>{ ... }</code> 绑定到最右边的调用：</p>
<pre><code class="language-crystal">foo bar do
  something
end

# 上式等价于
foo(bar) do
  something
end

foo bar { something }

# 上式等价于

foo(bar { something })
</code></pre>
<p>这样你就可以用<code>do ... end</code>创建领域特定语言 (DSL) ，让他们看起来更像英语(或是你的母语)：</p>
<pre><code class="language-crystal">open file &quot;foo.cr&quot; do
  something
end

# 等同于:
open(file(&quot;foo.cr&quot;)) do
end
</code></pre>
<p>你不会喜欢写：</p>
<pre><code class="language-crystal">open(file(&quot;foo.cr&quot;) do
end)
</code></pre>
<h2 id="对于重载"><a class="header" href="#对于重载">对于重载</a></h2>
<p>如果两个方法名字相同，一个接受块，一个不接受，那么它们会被认为是两个不同的方法。详见<a href="syntax_and_semantics/overloading.html">重载</a> 一章。</p>
<h2 id="向块传递参数"><a class="header" href="#向块传递参数">向块传递参数</a></h2>
<p><code>yield</code> 表达式类似于调用，也可以接收参数。例如：</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  puts &quot;Got #{i}&quot;
end
</code></pre>
<p>它会打印 &quot;Got 1&quot; 和 &quot;Got 2&quot;。</p>
<p>也可以用花括号：</p>
<pre><code class="language-crystal">twice { |i| puts &quot;Got #{i}&quot; }
</code></pre>
<p>可以 <code>yield</code>多个值：</p>
<pre><code class="language-crystal">def many
  yield 1, 2, 3
end

many do |x, y, z|
  puts x + y + z
end

# 输出: 6
</code></pre>
<p>一个块可以不完全接受这些参数：</p>
<pre><code class="language-crystal">def many
  yield 1, 2, 3
end

many do |x, y|
  puts x + y
end

# 输出: 3
</code></pre>
<p>但如果接受超出了传送额度的参数，那就会产生错误：</p>
<pre><code class="language-crystal">def twice
  yield
  yield
end

twice do |i| # 错误: 块要求参数过多
end
</code></pre>
<p>每个块内变量的类型是该位置传进来所有变量类型的并。例如：</p>
<pre><code class="language-crystal">def some
  yield 1, 'a'
  yield true, &quot;hello&quot;
  yield 2, nil
end

some do |first, second|
  # first is Int32 | Bool
  # second is Char | String | Nil
end
</code></pre>
<p>快变量 <code>second</code> 也可以是 <code>Nil</code> ，因为最后一个 <code>yield</code> 表达式没有包含第二个参数。</p>
<h2 id="单参数块的简便写法"><a class="header" href="#单参数块的简便写法">单参数块的简便写法</a></h2>
<p>如果某个块只是接受一个参数，调用它的某个方法，那么有一个简便的方法表示它：</p>
<pre><code class="language-crystal">method do |argument|
  argument.some_method
end
</code></pre>
<p>可以这么写：</p>
<pre><code class="language-crystal">method &amp;.some_method
</code></pre>
<p>或是：</p>
<pre><code class="language-crystal">method(&amp;.some_method)
</code></pre>
<p>这只是个语法糖，不会产生性能损失。</p>
<p>也可以把参数传给 <code>some_method</code>：</p>
<pre><code class="language-crystal">method &amp;.some_method(arg1, arg2)
</code></pre>
<p>这也适用于运算符：</p>
<pre><code class="language-crystal">method &amp;.+(2)
method &amp;.[index]
</code></pre>
<h2 id="产出值"><a class="header" href="#产出值">产出值</a></h2>
<p><code>yield</code> 表达式本身也有值：块中的最后一个表达式的值。例如：</p>
<pre><code class="language-crystal">def twice
  v1 = yield 1
  puts v1

  v2 = yield 2
  puts v2
end

twice do |i|
  i + 1
end
</code></pre>
<p>上式会打印 &quot;2&quot; 和 &quot;3&quot;；</p>
<p><code>yield</code>表达式在变换换筛选值时尤其有用。最好的例子是 <a href="http://crystal-lang.org/api/Enumerable.html#map%28%26block%20%3A%20T%20-%3E%20U%29-instance-method">Enumerable#map</a> 和<a href="http://crystal-lang.org/api/Enumerable.html#select%28%26block%20%3A%20T%20-%3E%20%29-instance-method">Enumerable#select</a>：</p>
<pre><code class="language-crystal">ary = [1, 2, 3]
ary.map { |x| x + 1 }         #=&gt; [2, 3, 4]
ary.select { |x| x % 2 == 1 } #=&gt; [1, 3]
</code></pre>
<p>有一个形式上的转换方法：</p>
<pre><code class="language-crystal">def transform(value)
  yield value
end

transform(1) { |x| x + 1 } #=&gt; 2
</code></pre>
<p>最后一个表达式的结果是 <code>2</code>，因为 <code>transform</code>方法的最后一个表达式是 <code>yield</code>，它的值又是块的最后一个表达式。</p>
<h2 id="类型限制-1"><a class="header" href="#类型限制-1">类型限制</a></h2>
<p>使用 <code>yield</code> 的方法中，块的类型可以用 <code>&amp;block</code>的属性进行限制。例如：</p>
<pre><code class="language-crystal">def transform_int(start : Int32, &amp;block : Int32 -&gt; Int32)
  result = yield start
  result * 2
end

transform_int(3) { |x| x + 2 } #=&gt; 10
transform_int(3) { |x| &quot;foo&quot; } # 错误：块应该返回Int32，而不是String 
</code></pre>
<h2 id="break-1"><a class="header" href="#break-1">break</a></h2>
<p>块内的<code>break</code> 表达式可以提前跳出这个方法：</p>
<pre><code class="language-crystal">def thrice
  puts &quot;Before 1&quot;
  yield 1
  puts &quot;Before 2&quot;
  yield 2
  puts &quot;Before 3&quot;
  yield 3
  puts &quot;After 3&quot;
end

thrice do |i|
  if i == 2
    break
  end
end
</code></pre>
<p>上述程序打印 &quot;Before 1&quot;和 &quot;Before 2&quot;。这个 <code>thrice</code> 方法没有执行到 <code>puts &quot;Before 3&quot;</code>，因为 <code>break</code>让它早早地退出了。</p>
<p><code>break</code> 也可以接受参数，它将成为该方法的返回值。例如：</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice { |i| i + 1 } #=&gt; 3
twice { |i| break &quot;hello&quot; } #=&gt; &quot;hello&quot;
</code></pre>
<p>第一次方法调用的值是 3 ，因为 <code>twice</code>方法的最后一个表达式是 <code>yield</code>，它又从块中获得值。第二次调用的值是 &quot;hello&quot;，因为 <code>break</code>被执行了，它的参数成了返回值。</p>
<p>如果break在条件内，那么这个调用的返回类型会是块中所有可能返回的地方——比如<code>break</code>和最后一个表达式——的值类型的联合：</p>
<pre><code class="language-crystal">value = twice do |i|
  if i == 1
    break &quot;hello&quot;
  end
  i + 1
end
value #:: Int32 | String
</code></pre>
<p>如果<code>break</code> 接受了多个参数，那么它们自动组成一个 <a href="http://crystal-lang.org/api/Tuple.html">元组</a>:</p>
<pre><code class="language-crystal">values = twice { break 1, 2 }
values #=&gt; {1, 2}
</code></pre>
<p>如果<code>break</code> 没有收到参数，那么等同于接受一个 <code>nil</code>：</p>
<pre><code class="language-crystal">value = twice { break }
value #=&gt; nil
</code></pre>
<h2 id="next-1"><a class="header" href="#next-1">next</a></h2>
<p><code>next</code>表达式可以提前结束这个块 (而不是整个方法)。例如：</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  if i == 1
    puts &quot;Skipping 1&quot;
    next
  end

  puts &quot;Got #{i}&quot;
end

# 输出:
# Skipping 1
# Got 2
</code></pre>
<p><code>next</code> 表达式接收参数，这会传给<code>yield</code>的调用者：</p>
<pre><code class="language-crystal">def twice
  v1 = yield 1
  puts v1

  v2 = yield 2
  puts v2
end

twice do |i|
  if i == 1
    next 10
  end

  i + 1
end

# 输出
# 10
# 3
</code></pre>
<p>如果 <code>next</code>接收了多个参数，它们会自动组成一个 <a href="http://crystal-lang.org/api/Tuple.html">元组</a>。如果没有接收到值，那么等同于接受一个 <code>nil</code> 参数。</p>
<h2 id="with--yield"><a class="header" href="#with--yield">with ... yield</a></h2>
<p><code>yield</code>表达式可以用 <code>with</code> 关键字指定块中方法调用的接收者：</p>
<pre><code class="language-crystal">class Foo
  def one
    1
  end

  def yield_with_self
    with self yield
  end

  def yield_normally
    yield
  end
end

def one
  &quot;one&quot;
end

Foo.new.yield_with_self { one } # =&gt; 1
Foo.new.yield_normally { one }  # =&gt; &quot;one&quot;
</code></pre>
<h2 id="块参数解包"><a class="header" href="#块参数解包">块参数解包</a></h2>
<p>声明绿参数时可以用括号指定子参数：</p>
<pre><code class="language-crystal">array = [{1, &quot;one&quot;}, {2, &quot;two&quot;}]
array.each do |(number, word)|
  puts &quot;#{number}: #{word}&quot;
end
</code></pre>
<p>这是下面这种写法的语法糖：</p>
<pre><code class="language-crystal">array = [{1, &quot;one&quot;}, {2, &quot;two&quot;}]
array.each do |arg|
  number = arg[0]
  word = arg[1]
  puts &quot;#{number}: #{word}&quot;
end
</code></pre>
<p>这也意味着任何可以以整数为参数响应 <code>[]</code> 方法的对象都可以在这里解包。</p>
<h2 id="性能"><a class="header" href="#性能">性能</a></h2>
<p>当以 <code>yield</code>使用块时，这个块 <strong>总是</strong> 被内联：不会涉及闭包，调用，或是函数指针。这意味着：</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  puts &quot;Got: #{i}&quot;
end
</code></pre>
<p>等同于写：</p>
<pre><code class="language-crystal">i = 1
puts &quot;Got: #{i}&quot;
i = 2
puts &quot;Got: #{i}&quot;
</code></pre>
<p>例如，标准库对整数添加了 <code>times</code> 方法，你可以写：</p>
<pre><code class="language-crystal">3.times do |i|
  puts i
end
</code></pre>
<p>这看起来非常花哨，但是它确实和C的循环一样快，真的。</p>
<p>这是 <code>Int#times</code> 的定义：</p>
<pre><code class="language-crystal">struct Int
  def times
    i = 0
    while i &lt; self
      yield i
      i += 1
    end
  end
end
</code></pre>
<p>因为没有被捕获的块总是被内联，上面的方法调用 <strong>等同于</strong> 写：</p>
<pre><code class="language-crystal">i = 0
while i &lt; 3
  puts i
  i += 1
end
</code></pre>
<p>使用块不用担心它的性能问题，但确实能提升代码可读性和重用性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="捕捉块"><a class="header" href="#捕捉块">捕捉块</a></h1>
<p>一个块可以被捕捉，然后成为一个闭包(<code>Proc</code>)。相比于块，闭包还包含了它执行所需要的上下文：它包含了一部分数据。</p>
<p>为了捕获一个块，你必须把它列为方法的块参数，赋予名字，并写清楚它的输入和输出类型。例如：</p>
<pre><code class="language-crystal">def int_to_int(&amp;block : Int32 -&gt; Int32)
  block
end

proc = int_to_int { |x| x + 1 }
proc.call(1) #=&gt; 2
</code></pre>
<p>上述代码捕获一个闭包，把它作为 <code>block</code>传给 <code>int_to_int</code>，又把它返回来。这个 <code>proc</code>的类型是 <a href="http://crystal-lang.org/api/Proc.html">Proc(Int32, Int32)</a>即一个函数，输入一个 <code>Int32</code>，返回一个 <code>Int32</code>.</p>
<p>这样一个块就能作为回调保存：</p>
<pre><code class="language-crystal">class Model
  def on_save(&amp;block)
    @on_save_callback = block
  end

  def save
    if callback = @on_save_callback
      callback.call
    end
  end
end

model = Model.new
model.on_save { puts &quot;Saved!&quot; }
model.save # prints &quot;Saved!&quot;
</code></pre>
<p>这个例子中 <code>&amp;block</code>的类型没有确定，这只是意味着块不接受参数，也没有返回值。</p>
<p>注意，如果块的返回类型没有确定，那么什么东西都不会返回，即使这个块本来想返回些什么。</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt;)
  block
end

proc = some_proc { |x| x + 1 }
proc.call(1) # void
</code></pre>
<p>为了允许返回值，要么指出返回值的类型，要么留一个下划线，以表示什么返回类型都可以：</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt; _)
  block
end

proc = some_proc { |x| x + 1 }
proc.call(1) # 2

proc = some_proc { |x| x.to_s }
proc.call(1) # &quot;1&quot;
</code></pre>
<h2 id="break-和-next"><a class="header" href="#break-和-next">break 和 next</a></h2>
<p><code>return</code> 和 <code>break</code> 不能在一个捕获了的块中使用。 <code>next</code> 仍可以用，他会退出当前块，给出块执行完毕后的值。</p>
<h2 id="with--yield-1"><a class="header" href="#with--yield-1">with ... yield</a></h2>
<p>已捕获的块不能用 <code>with ... yield</code>改变接收者。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包字面量"><a class="header" href="#闭包字面量">闭包字面量</a></h1>
<p>一个捕获块等同于声明一个 <a href="syntax_and_semantics/literals/proc.html">闭包字面量</a> ，然后把它<a href="syntax_and_semantics/block_forwarding.html">传递</a> 给一个方法。</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt; Int32)
  block
end

x = 0
proc = -&gt;(i : Int32) { x += i }
proc = some_proc(&amp;proc)
proc.call(1)  #=&gt; 1
proc.call(10) #=&gt; 11
x #=&gt; 11
</code></pre>
<p>如<a href="syntax_and_semantics/literals/proc.html">闭包字面量</a>一篇所述，闭包也可以由已有方法构造：</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

adder = -&gt;add(Int32, Int32)
adder.call(1, 2) #=&gt; 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="传递块"><a class="header" href="#传递块">传递块</a></h1>
<p>为了把代码块传给其他方法，你应当注明块参数，在其前面加 <code>&amp;</code>：</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

def invoke(&amp;block)
  block.call
end

proc = capture { puts &quot;Hello&quot; }
invoke(&amp;proc) # 打印 &quot;Hello&quot;
</code></pre>
<p>上例中， <code>invoke</code> 接收块，我们不能把闭包直接传进它，因为它不接受一般的参数，只接受块参数。我们用 <code>&amp;</code> 指定“我们真的要把 <code>proc</code>当做块参数传进去”，否则会：</p>
<pre><code class="language-crystal">invoke(proc) # 错误: 'invoke' 参数数量匹配 (给出 1, 应有 0)
</code></pre>
<p>你可以把闭包传给使用 yield 的方法：</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

def twice
  yield
  yield
end

proc = capture { puts &quot;Hello&quot; }
twice &amp;proc
</code></pre>
<p>上述等同于：</p>
<pre><code class="language-crystal">proc = capture { puts &quot;Hello&quot; }
twice do
  proc.call
end
</code></pre>
<p>或者，结合 <code>&amp;</code> 和 <code>-&gt;</code> 的句法：</p>
<pre><code class="language-crystal">twice &amp;-&gt;{ puts &quot;Hello&quot; }
</code></pre>
<p>Or:</p>
<pre><code class="language-crystal">def say_hello
  puts &quot;Hello&quot;
end

twice &amp;-&gt;say_hello
</code></pre>
<h2 id="传递非捕获的块"><a class="header" href="#传递非捕获的块">传递非捕获的块</a></h2>
<p>要传递非捕获的块，你必须用 <code>yield</code>：</p>
<pre><code class="language-crystal">def foo
  yield 1
end

def wrap_foo
  puts &quot;Before foo&quot;
  foo do |x|
    yield x
  end
  puts &quot;After foo&quot;
end

wrap_foo do |i|
  puts i
end

# 输出:
# Before foo
# 1
# After foo
</code></pre>
<p>你也可以用 <code>&amp;block</code> 来传递块，但是你至少要指出块的输入类型，并且，产生的代码会包含一个闭包，因此也更慢。</p>
<pre><code class="language-crystal">def foo
  yield 1
end

def wrap_foo(&amp;block : Int32 -&gt; _)
  puts &quot;Before foo&quot;
  foo(&amp;block)
  puts &quot;After foo&quot;
end

wrap_foo do |i|
  puts i
end

# Output:
# Before foo
# 1
# After foo
</code></pre>
<p>如果 <code>yield</code> 够用，就尽量避免传递块。同时注意，在捕获的块中 <code>break</code> and <code>next</code> 都不能用。所以<code>&amp;block</code>不能在接下来的代码中正确运行：</p>
<pre><code class="language-crystal">foo_forward do |i|
  break # 错误
end
</code></pre>
<p>总之，当有 <code>yield</code> 时避免传递块<code>&amp;block</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包及其环境变量-closures"><a class="header" href="#闭包及其环境变量-closures">闭包及其环境变量 (Closures)</a></h1>
<p>捕获的块会和闭包字面量会把局部变量和 <code>self</code> 包含在自身环境内。举例子比较好理解：</p>
<pre><code class="language-crystal">x = 0
proc = -&gt;{ x += 1; x }
proc.call #=&gt; 1
proc.call #=&gt; 2
x         #=&gt; 2
</code></pre>
<p>或者是从方法中返回的闭包：</p>
<pre><code class="language-crystal">def counter
  x = 0
  -&gt;{ x += 1; x }
end

proc = counter
proc.call #=&gt; 1
proc.call #=&gt; 2
</code></pre>
<p>上例中，即使 <code>x</code>是局部变量，他也会被闭包捕获。这种情况编译器会把 <code>x</code>分配在堆上，用作闭包的环境信息。因为普通的局部变量分配在栈上，方法返回时它们就消失了。</p>
<h2 id="type-of-closured-variables"><a class="header" href="#type-of-closured-variables">Type of closured variables</a></h2>
<p>编译器处理一般的局部变量是比较聪明的。例如：</p>
<pre><code class="language-crystal">def foo
  yield
end

x = 1
foo do
  x = &quot;hello&quot;
end
x # : Int32 | String
</code></pre>
<p>编译器知道，在这个块执行之后， <code>x</code> 可以是 Int32 或 String (它本可以知道这一定是 String，因为这个方法总是执行传进来的块。 这个推断以后还能更精准)。</p>
<p>如果 <code>x</code> 被赋值成其他的变量，编译器会知道它被改变了：</p>
<pre><code class="language-crystal">x = 1
foo do
  x = &quot;hello&quot;
end
x # : Int32 | String

x = 'a'
x # : Char
</code></pre>
<p>然而，如果 <code>x</code> 被一个闭包捕获，它的类型就一定是所有赋值给它的类型之并：</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

x = 1
capture { x = &quot;hello&quot; }

x = 'a'
x # : Int32 | String | Char
</code></pre>
<p>这是因为捕获的块可能被存在类或是成员变量中，然后按照某个指令被另一个线程调用。编译器不会再穷尽分析下去，它只会认为如果一个变量被闭包捕闭包被执行的时间就不确定。</p>
<p>这也适用于常规的闭包字面量，即使这个闭包显然不会被储存或调用：</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

x = 1
-&gt;{ x = &quot;hello&quot; }

x = 'a'
x # : Int32 | String | Char
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alias--类型别名"><a class="header" href="#alias--类型别名">alias : 类型别名</a></h1>
<p>可以用 <code>alias</code> 给类型赋予别名：</p>
<pre><code class="language-crystal">alias PInt32 = Pointer(Int32)

ptr = PInt32.malloc(1) # : Pointer(Int32)
</code></pre>
<p>编辑器会把每个 alias 替换成其指代的类型。</p>
<p>别名使你得以避免写超长类型名，也可以用于描述递归类型：</p>
<pre><code class="language-crystal">alias RecArray = Array(Int32) | Array(RecArray)

ary = [] of RecArray
ary.push [1, 2, 3]
ary.push ary
ary #=&gt; [[1, 2, 3], [...]]
</code></pre>
<p>现实生活中一个递归类型的例子是 json:</p>
<pre><code class="language-crystal">module Json
  alias Type = Nil |
               Bool |
               Int64 |
               Float64 |
               String |
               Array(Type) |
               Hash(String, Type)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h1>
<p>Crystal处理错误的一般方法就是通过抛出和处理异常。</p>
<h2 id="抛出异常"><a class="header" href="#抛出异常">抛出异常</a></h2>
<p>你通过调用顶层的 <code>raise</code> 方法来抛出异常。 <code>raise</code>不是关键字，而只是正常的方法。它有两个重载，一个接受 <a href="http://crystal-lang.org/api/toplevel.html#raise%28message%20%3A%20String%29-class-method">字符串</a> ，另一个接受 <a href="http://crystal-lang.org/api/toplevel.html#raise%28ex%20%3A%20Exception%29-class-method"> Exception 实例</a>：</p>
<pre><code class="language-crystal">raise &quot;OH NO!&quot;
raise Exception.new(&quot;Some error&quot;)
</code></pre>
<p>字符串版本只是用它的消息创建了一个新的 <a href="http://crystal-lang.org/api/Exception.html">Exception</a> 实例。</p>
<p>只有 <code>Exception</code>及其子类的实例可以被抛出。</p>
<h2 id="自定义异常"><a class="header" href="#自定义异常">自定义异常</a></h2>
<p>你可以让你的类继承 <a href="http://crystal-lang.org/api/Exception.html">Exception</a>，这样它就会被视为一个异常：</p>
<pre><code class="language-crystal">class MyException &lt; Exception
end

class MyOtherException &lt; Exception
end
</code></pre>
<p>你可以，并且总是可以，给你的异常定义构造函数，或使用默认的那个。</p>
<h2 id="抢救异常"><a class="header" href="#抢救异常">抢救异常</a></h2>
<p>用 <code>begin ... rescue ... end</code> 表达式抢救异常：</p>
<pre><code class="language-crystal">begin
  raise &quot;OH NO!&quot;
rescue
  puts &quot;Rescued!&quot;
end

# 输出: Rescued!
</code></pre>
<p>在 <code>rescue</code>子句中添加变量，以获取抛出的异常:</p>
<pre><code class="language-crystal">begin
  raise &quot;OH NO!&quot;
rescue ex
  puts ex.message
end

# 输出: OH NO!
</code></pre>
<p>抢救某一类型的异常 (或它的任意子类)：</p>
<pre><code class="language-crystal">begin
  raise MyException.new(&quot;OH NO!&quot;)
rescue MyException
  puts &quot;抢救了 MyException&quot;
end

# 输出: 抢救了 MyException
</code></pre>
<p>为了取得它的实例，你可以用类型限制的语法标注它：</p>
<pre><code class="language-crystal">begin
  raise MyException.new(&quot;OH NO!&quot;)
rescue ex : MyException
  puts &quot;抢救了 MyException: #{ex.message}&quot;
end

# 输出: 抢救了 MyException: OH NO!
</code></pre>
<p>这个结构可以接多个 <code>rescue</code>子句：</p>
<pre><code class="language-crystal">begin
  # ...
rescue ex1 : MyException
  # 只接受 MyException...
rescue ex2 : MyOtherException
  # 只接受 MyOtherException...
rescue
  # 其他任意异常
end
</code></pre>
<p>你也可以用联合类型在一个字句中接受多个异常。</p>
<pre><code class="language-crystal">begin
  # ...
rescue ex : MyException | MyOtherException
  # 接受 MyException 或 MyOtherException
rescue
  # 其他任意异常
end
</code></pre>
<h2 id="else"><a class="header" href="#else">else</a></h2>
<p>这个结构可以接 <code>else</code> ，它会在没有任何异常被捕获的时候被执行：</p>
<pre><code class="language-crystal">begin
  something_dangerous
rescue
  # 如果有异常抛出，就执行
else
  # 如果没有异常抛出，就执行
end
</code></pre>
<p><code>else</code> 子句只能在指定了至少一个 <code>rescue</code> 子句后使用。</p>
<h2 id="ensure"><a class="header" href="#ensure">ensure</a></h2>
<p><code>ensure</code>子句接在 <code>begin ... end</code> 或 <code>begin ... rescue ... end</code> 表达式的后方，保证它的内容被执行，不论是否有异常抛出：</p>
<pre><code class="language-crystal">begin
  something_dangerous
ensure
  puts &quot;Cleanup...&quot;
end

# 会在调用 something_dangerous 之后执行 &quot;Cleanup...&quot; ,
# 不论是否有异常抛出
</code></pre>
<p>或者：</p>
<pre><code class="language-crystal">begin
  something_dangerous
rescue
  # ...
else
  # ...
ensure
  # 这总是会被执行
end
</code></pre>
<p><code>ensure</code> 通常用于清理现场，释放资源，等等。</p>
<h2 id="简短格式"><a class="header" href="#简短格式">简短格式</a></h2>
<p>异常处理有一个简短的格式：所有的方法或块定义可以视为隐含着一个 <code>begin ... end</code>表达式，所以可以直接指定 <code>rescue</code>， <code>else</code>，和 <code>ensure</code> 子句：</p>
<pre><code class="language-crystal">def some_method
  something_dangerous
rescue
  # 当有异常抛出时执行
end

# 上式等同于：
def some_method
  begin
    something_dangerous
  rescue
    # 当有异常抛出时执行
  end
end
</code></pre>
<p>加<code>ensure</code>：</p>
<pre><code class="language-crystal">def some_method
  something_dangerous
ensure
  # 总是执行
end

# 上式等同于:
def some_method
  begin
    something_dangerous
  ensure
    # 总是执行
  end
end

# 类似的，这种简便写法也适用于块：
(1..10).each do |n|
  # 潜在有危险的操作
rescue
  #..
else
  #..
ensure
  #..
end
</code></pre>
<h2 id="类型推导-1"><a class="header" href="#类型推导-1">类型推导</a></h2>
<p><code>begin</code>中定义的变量在 <code>rescue</code> 或 <code>ensure</code>中可能是 <code>Nil</code> 类型。例如：</p>
<pre><code class="language-crystal">begin
  a = something_dangerous_that_returns_Int32
ensure
  puts a + 1 # 错误， Nil 没有定义 '+' 方法 
end
</code></pre>
<p>即使 <code>something_dangerous_that_returns_Int32</code> 从不抛异常，这个错误也会发生。或者，如果 <code>a</code> 被赋以一个变量，后面又做了可能抛异常的操作，这种错误也会发生：</p>
<pre><code class="language-crystal">begin
  a = 1
  something_dangerous
ensure
  puts a + 1 # 错误， Nil 没有定义 '+' 方法 
end
</code></pre>
<p>即使 <code>a</code> 显然总是有被赋予一个值，编译器仍然很认为也许<code>a</code> 来不及初始化，程序就跑到了其他的地方。这种逻辑以后也许会被修复，但现在你最好把异常处理程序限制在最小的规模，这样程序的意图也会更清晰。</p>
<pre><code class="language-crystal">#这比上面的清晰： `a` 不需要放在异常处理代码中
a = 1
begin
  something_dangerous
ensure
  puts a + 1 # 能跑
end
</code></pre>
<h2 id="错误处理的另一种方法"><a class="header" href="#错误处理的另一种方法">错误处理的另一种方法</a></h2>
<p>尽管异常是一种处理错误的方法，但它不是唯一的方法。抛出异常意味着消耗内存，执行异常处理往往会减慢程序速度。</p>
<p>标准库通常提供一堆方法去做某事。出错时，它们一个抛出异常，另一个返回 <code>nil</code>。例如：</p>
<pre><code class="language-crystal">array = [1, 2, 3]
array[4]  # 抛出 IndexError
array[4]? # 返回 nil ，因为下标越界了
</code></pre>
<p>通常的约定是，一个以问号结尾的方法会在出错时返回 <code>nil</code>，而不是抛出异常。这样用户就可以决定他是否要处理异常，或是得到一个  <code>nil</code>。然而，这不只是对所有方法都如此。毕竟，异常仍然是推荐的处理，因为它不会污染正常代码的逻辑。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型语法"><a class="header" href="#类型语法">类型语法</a></h1>
<p>当：</p>
<ul>
<li>指定 <a href="syntax_and_semantics/type_restrictions.html">类型限制</a></li>
<li>指定 <a href="syntax_and_semantics/generics.html">类型参数</a></li>
<li><a href="syntax_and_semantics/declare_var.html">声明变量</a></li>
<li>声明 <a href="syntax_and_semantics/alias.html">别名</a></li>
<li>声明 <a href="syntax_and_semantics/c_bindings/type.html">C typedef</a></li>
<li><a href="syntax_and_semantics/is_a.html">is_a?</a> 伪方法的参数</li>
<li><a href="syntax_and_semantics/as.html">as</a> 表达式的参数</li>
<li><a href="syntax_and_semantics/sizeof.html">sizeof</a>表达式的参数</li>
<li><a href="syntax_and_semantics/instance_sizeof.html">instance_sizeof</a> 表达式的参数</li>
<li>方法的 <a href="syntax_and_semantics/return_types.html">返回类型</a></li>
</ul>
<p>对于常见的类型，我们提供了一些便捷语法。这在写 <a href="syntax_and_semantics/c_bindings/index.html">C 绑定</a>时尤其有用，但是可以用于任何的这些地方。</p>
<h2 id="路径paths-和泛型generics"><a class="header" href="#路径paths-和泛型generics">路径(Paths) 和泛型(generics)</a></h2>
<p>常规类型和泛型都可以用：</p>
<pre><code class="language-crystal">Int32
My::Nested::Type
Array(String)
</code></pre>
<h2 id="联合类型-1"><a class="header" href="#联合类型-1">联合类型</a></h2>
<pre><code class="language-crystal">alias Int32OrString = Int32 | String
</code></pre>
<p>类型之间的管道符 (<code>|</code>) 创建了一个联合类型。 <code>Int32 | String</code> 读作 &quot;Int32 或 String&quot;。通常代码中， <code>Int32 | String</code> 意思是以<code>String</code>为参数，调用 <code>Int32</code> 的<code>|</code> 方法。</p>
<h2 id="可空类型"><a class="header" href="#可空类型">可空类型</a></h2>
<pre><code class="language-crystal">alias Int32OrNil = Int32?
</code></pre>
<p>等同于:</p>
<pre><code class="language-crystal">alias Int32OrNil = Int32 | ::Nil
</code></pre>
<p>通常代码中， <code>Int32?</code> 是语法错误。</p>
<h2 id="指针"><a class="header" href="#指针">指针</a></h2>
<pre><code class="language-crystal">alias Int32Ptr = Int32*
</code></pre>
<p>等同于:</p>
<pre><code class="language-crystal">alias Int32Ptr = Pointer(Int32)
</code></pre>
<p>通常代码中，<code>Int32*</code> 意味着调用 <code>Int32</code>的 <code>*</code>方法。</p>
<h2 id="静态数组"><a class="header" href="#静态数组">静态数组</a></h2>
<pre><code class="language-crystal">alias Int32_8 = Int32[8]
</code></pre>
<p>等同于：</p>
<pre><code class="language-crystal">alias Int32_8 = StaticArray(Int32, 8)
</code></pre>
<p>通常代码中， <code>Int32[8]</code> 意味着以<code>8</code>为参数调用<code>Int32</code> 的 <code>[]</code>方法。</p>
<h2 id="元组"><a class="header" href="#元组">元组</a></h2>
<pre><code class="language-crystal">alias Int32StringTuple = {Int32, String}
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32StringTuple = Tuple(Int32, String)
</code></pre>
<p>通常代码中， <code>{Int32, String}</code> 是一个元组<strong>实例</strong>，包含 <code>Int32</code> 和 <code>String</code> 两个元素。这不同于上面的元组 <strong>类型</strong>。</p>
<h2 id="命名元组"><a class="header" href="#命名元组">命名元组</a></h2>
<pre><code class="language-crystal">alias Int32StringNamedTuple = {x: Int32, y: String}
</code></pre>
<p>等同于</p>
<pre><code class="language-crystal">alias Int32StringNamedTuple = NamedTuple(x: Int32, y: String)
</code></pre>
<p>通常代码中， <code>{x: Int32, y: String}</code> 是命名元组<strong>实例</strong>，把 <code>x</code>对应到<code>Int32</code>  , <code>y</code>对应到 <code>String</code> 。 这不同于上面的命名元组 <strong>类型</strong>。</p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<pre><code class="language-crystal">alias Int32ToString = Int32 -&gt; String
</code></pre>
<p>等同于</p>
<pre><code class="language-crystal">alias Int32ToString = Proc(Int32, String)
</code></pre>
<p>声明一个无参数的闭包：</p>
<pre><code class="language-crystal">alias ProcThatReturnsInt32 = -&gt; Int32
</code></pre>
<p>指定多个闭包参数：</p>
<pre><code class="language-crystal">alias Int32AndCharToString = Int32, Char -&gt; String
</code></pre>
<p>对于嵌套的闭包，可以用括号来分别层次，这不限于括号，适用于任何类型：</p>
<pre><code class="language-crystal">alias ComplexProc = (Int32 -&gt; Int32) -&gt; String
</code></pre>
<p>通常代码中， <code>Int32 -&gt; String</code>是语法错误。</p>
<h2 id="self"><a class="header" href="#self">self</a></h2>
<p><code>self</code> 可以用作类型，表示 <code>self</code>的类型。详见 <a href="syntax_and_semantics/type_restrictions.html">类型限制</a>一章。</p>
<h2 id="class"><a class="header" href="#class">class</a></h2>
<p><code>class</code> 用于指定<em>类</em> 类型，而不是实例类型。</p>
<p>例如：</p>
<pre><code class="language-crystal">def foo(x : Int32)
  &quot;instance&quot;
end

def foo(x : Int32.class)
  &quot;class&quot;
end

foo 1     # &quot;instance&quot;
foo Int32 # &quot;class&quot;
</code></pre>
<p><code>class</code> 也用于创建包含类类型的数组：</p>
<pre><code class="language-crystal">class Parent
end

class Child1 &lt; Parent
end

class Child2 &lt; Parent
end

ary = [] of Parent.class
ary &lt;&lt; Child1
ary &lt;&lt; Child2
</code></pre>
<h2 id="下划线"><a class="header" href="#下划线">下划线</a></h2>
<p>下划线用于类型限制时，表示“任何类型：</p>
<pre><code class="language-crystal"># 等同于不写类型限制，用处不大
def foo(x : _)
end

# 有点用处: 指定输入任意两个类型，返回 Int32：
def foo(x : _, _ -&gt; Int32)
end
</code></pre>
<h2 id="typeof"><a class="header" href="#typeof">typeof</a></h2>
<p><code>typeof</code> 可以用于类型语法，表示其传入所有变量的类型之并：</p>
<pre><code class="language-crystal">typeof(1 + 2) # =&gt; Int32
typeof(1, &quot;a&quot;) # =&gt; (Int32 | String)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型反射"><a class="header" href="#类型反射">类型反射</a></h1>
<p>Crystal 对类型反射,转换和内省提供了基本的方法：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_a"><a class="header" href="#is_a">is_a?</a></h1>
<p>伪方法 <code>is_a?</code> 确定了这个变量的运行时类型是否继承或包含其他的类型。例如：</p>
<pre><code class="language-crystal">a = 1
a.is_a?(Int32)          #=&gt; true
a.is_a?(String)         #=&gt; false
a.is_a?(Number)         #=&gt; true
a.is_a?(Int32 | String) #=&gt; true
</code></pre>
<p>这是一个伪方法，，因为编译器认识它，且它会改变变量的类型信息，详见 <a href="syntax_and_semantics/if_varis_a.html">if var.is_a?(...)</a>。另外，它接受一个 <a href="syntax_and_semantics/type_grammar.html">类型</a>，这必须在编译时确定。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nil-1"><a class="header" href="#nil-1">nil?</a></h1>
<p>伪方法 <code>nil?</code> 确定一个变量的运行时类型是不是 <code>Nil</code>。例如：</p>
<pre><code class="language-crystal">a = 1
a.nil?          # =&gt; false

b = nil
b.nil?          # =&gt; true
</code></pre>
<p>这是个伪方法，因为编译器认识它，并且使用它会改变变量的类型信息，见 <a href="syntax_and_semantics/if_var_nil.html">if var.nil?(...)</a>。</p>
<p>它和 <code>is_a?(Nil)</code>效果相同，但是更短，更容易读，写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="responds_to"><a class="header" href="#responds_to">responds_to?</a></h1>
<p>伪方法 <code>responds_to?</code> 确定一个类型是否响应某个方法。例如：</p>
<pre><code class="language-crystal">a = 1
a.responds_to?(:abs)    #=&gt; true
a.responds_to?(:size) #=&gt; false
</code></pre>
<p>它是伪方法，因为它只接受符号字面量，并且别编译器特殊对待，见 <a href="syntax_and_semantics/if_varresponds_to.html">if var.responds_to?(...)</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as"><a class="header" href="#as">as</a></h1>
<p><code>as</code> 伪方法可以限制表达式的类型。比如：</p>
<pre><code class="language-crystal">if some_condition
  a = 1
else
  a = &quot;hello&quot;
end

# a : Int32 | String
</code></pre>
<p>在上述代码中，<code>a</code> 是或类型 <code>Int32 | String</code>。如果在 <code>if</code> 表达式之后还要把 <code>a</code> 用作 <code>Int32</code> ，我们可以强制编译器把它视为 <code>Int32</code>：</p>
<pre><code class="language-crystal">a_as_int = a.as(Int32)
a_as_int.abs          # 行，编译器知道 a_as_int 是 Int32
</code></pre>
<p><code>as</code>伪方法会在运行时检查： 如果<code>a</code> 不是 <code>Int32</code>，就抛出一个 <a href="syntax_and_semantics/exception_handling.html">exception</a>。 raised.</p>
<p>表达式的形参是一个 <a href="syntax_and_semantics/type_grammar.html">类型</a>.</p>
<p>如果一个类型不可能攒成另一个类型，那么会产生编译错误：</p>
<pre><code class="language-crystal">1.as(String) # 编译错误
</code></pre>
<p><strong>注意：</strong> 你不能用 <code>as</code> 把一个类型转成不相关的另一个： <code>as</code> 不是其他语言中的 <code>cast</code>。整数，浮点数，字符都为这些转换提供了方法。不过，可以对指针进行转换，方法如下：</p>
<h2 id="指针类型互转"><a class="header" href="#指针类型互转">指针类型互转</a></h2>
<p><code>as</code> 伪方法也用于转换不同类型的指针：</p>
<pre><code class="language-crystal">ptr = Pointer(Int32).malloc(1)
ptr.as(Int8*)                    #:: Pointer(Int8)
</code></pre>
<p>这种情况不会要求运行时检查：指针本来就不安全，并且这种转换往往用于绑定C函数或其他更底层的代码。</p>
<h2 id="指针与其他类型互转"><a class="header" href="#指针与其他类型互转">指针与其他类型互转</a></h2>
<p>指针也可以与成其他类型互相转换：</p>
<pre><code class="language-crystal">array = [1, 2, 3]

# object_id 返回这个对象在内存中的地址
# 所以我们用这个地址创建指针
ptr = Pointer(Void).new(array.object_id)

# 我们把指针转换成别的类型，但是它们指向的地址一样，因此是相等的。
array2 = ptr.as(Array(Int32))
array2.same?(array) #=&gt; true
</code></pre>
<p>由于涉及指针，这里没有进行运行时检查。这种用法比上一个更少见，但是允许Crystal自己去实现一些核心类型(比如String)，由此也可以把引用类型当做void*传给C函数。</p>
<h2 id="转换到更弱的类型"><a class="header" href="#转换到更弱的类型">转换到更弱的类型</a></h2>
<p>The <code>as</code> 伪方法可以把表达式转给<em>更弱的</em>类型。比如：</p>
<pre><code class="language-crystal">a = 1
b = a.as(Int32 | Float64)
b #:: Int32 | Float64
</code></pre>
<p>也许不那么有用。但有时也能派上用场，比如映射数组中的元素：</p>
<pre><code class="language-crystal">ary = [1, 2, 3]

# 通过数组 1, 2, 3 构建 Int32 | Float64 数组
ary2 = ary.map { |x| x.as(Int32 | Float64) }

ary2 #:: Array(Int32 | Float64)
ary2 &lt;&lt; 1.5 # OK
</code></pre>
<p><code>Array#map</code> 方法认为block的返回类型就是数组的类型。如果没有 <code>as</code> 伪方法，推到出来的类型就是 <code>Int32</code>我们就不能把 <code>Float64</code>加进去。</p>
<h2 id="如果编译器推导不出块的类型"><a class="header" href="#如果编译器推导不出块的类型">如果编译器推导不出块的类型</a></h2>
<p>有时编译器推导不出块的类型，比如递归调用互相依赖起来的时候。此时你可以用 <code>as</code>提醒编译器：</p>
<pre><code class="language-crystal">some_call { |v| v.method.as(ExpectedType) }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-1"><a class="header" href="#as-1">as?</a></h1>
<p><code>as?</code>伪方法类似于 <code>as</code>,除了当类型不匹配时它返回 <code>nil</code>，而不是抛出异常。它也可以用于转换指针类型和其他类型。</p>
<p>例如：</p>
<pre><code class="language-crystal">value = rand &lt; 0.5 ? -3 : nil
result = value.as?(Int32) || 10

value.as?(Int32).try &amp;.abs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typeof-1"><a class="header" href="#typeof-1">typeof</a></h1>
<p><code>typeof</code>表达式返回原表达式的类型：</p>
<pre><code class="language-crystal">a = 1
b = typeof(a) #=&gt; Int32
</code></pre>
<p>它接受多个参数，返回的结果是这些参数类型的并：</p>
<pre><code class="language-crystal">typeof(1, &quot;a&quot;, 'a') #=&gt; (Int32 | String | Char)
</code></pre>
<p>这常用于泛型代码，来利用编译器的类型推导功能：</p>
<pre><code class="language-crystal">hash = {} of Int32 =&gt; String
another_hash = typeof(hash).new #:: Hash(Int32, String)
</code></pre>
<p>因为<code>typeof</code> 并不事实上对参数表达式求值，它可以用于编译时的方法。在这个例子中，它被用于从嵌套的类型参数中递归地构建出一个联合类型：</p>
<pre><code class="language-crystal">class Array
  def self.elem_type(typ)
    if typ.is_a?(Array)
      elem_type(typ.first)
    else
      typ
    end
  end
end

nest = [1, [&quot;b&quot;, [:c, ['d']]]]
flat = Array(typeof(Array.elem_type(nest))).new
typeof(nest) #=&gt; Array(Int32 | Array(String | Array(Symbol | Array(Char))))
typeof(flat) #=&gt; Array(String | Int32 | Symbol | Char)
</code></pre>
<p>这个表达式也可用于<a href="syntax_and_semantics/type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<p>宏在编译时接受AST节点,产生代码,并复制进原程序。例如：</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name}}
    {{content}}
  end
end

# 产生:
#
#     def foo
#       1
#     end
define_method foo, 1

foo #=&gt; 1
</code></pre>
<p>宏的定义体就像普通的Crystal代码一样，除了用于操作AST的特殊语法。产出的代码必须是有效的Crystal代码，即你不能产出<code>def</code>而不配对<code>end</code>，或是一个单独的 <code>when</code> 而没有 <code>case</code>， 因为这不是完整的语法结构. 详见<a href="syntax_and_semantics/macros.html#pitfalls">Pitfalls</a>.</p>
<h2 id="定义域"><a class="header" href="#定义域">定义域</a></h2>
<p>顶层定义的宏做任何地方都可见，如果顶层宏标注为  <code>private</code> 那他只在文档内可见</p>
<p>它们也可以定义在类和模块里，只在这些域中可见。祖先链中的宏也会被查找到（超类和包含的模块）。</p>
<p>比如，块，被一个对象来调用  <code>with ... yield</code> 时，也可以找到对象的祖先链中的宏：</p>
<pre><code class="language-crystal">class Foo
  macro emphasize(value)
    &quot;***#{ {{value}} }***&quot;
  end

  def yield_with_self
    with self yield
  end
end

Foo.new.yield_with_self { emphasize(10) } #=&gt; &quot;***10***&quot;
</code></pre>
<p>类和模块里面的宏也可以在外面调用：</p>
<pre><code class="language-crystal">class Foo
  macro emphasize(value)
    &quot;***#{ {{value}} }***&quot;
  end
end

Foo.emphasize(10) # =&gt; &quot;***10***&quot;
</code></pre>
<h2 id="插值interpolation"><a class="header" href="#插值interpolation">插值(Interpolation)</a></h2>
<p>你可以用 <code>{{...}}</code>去粘贴、插入一个 AST 节点, 如上所示.</p>
<p>注意：粘贴的方法遵循“如同(as-is)”规则.如果上一个例子中我们放入一个符号，产出的代码将出错：</p>
<pre><code class="language-crystal"># This generates:
#
#     def :foo
#       1
#     end
define_method :foo, 1
</code></pre>
<p>注意 <code>:foo</code> 是插值的结果，因为传到宏里面的就是它。这种情况你可以调用 <code>ASTNode#id</code>,得到它对应的字符(identifier)。</p>
<h2 id="宏调用"><a class="header" href="#宏调用">宏调用</a></h2>
<p>你可以编译时调用AST节点的方法的一些<strong>固定的子集</strong>。这些方法记录在一个假想的 <a href="http://crystal-lang.org/api/Crystal/Macros.html">Crystal::Macros</a> 模块。</p>
<p>例如在上面的问题里面调用 <code>ASTNode#id</code>：</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name.id}}
    {{content}}
  end
end

# 正确的输出是：
#
#     def foo
#       1
#     end
define_method :foo, 1
</code></pre>
<h2 id="模块和类"><a class="header" href="#模块和类">模块和类</a></h2>
<p>宏也可以用于产生模块，类和结构体：</p>
<pre><code class="language-crystal">macro define_class(module_name, class_name, method, content)
  module {{module_name}}
    class {{class_name}}
      def initialize(@name : String)
      end

      def {{method}}
        {{content}} + @name
      end
    end
  end
end

# 输出为：
#     module Foo
#       class Bar
#         def initialize(@name : String)
#         end
#
#         def say
#           &quot;hi &quot; + @name
#         end
#       end
#     end
define_class Foo, Bar, say, &quot;hi &quot;

p Foo::Bar.new(&quot;John&quot;).say # =&gt; &quot;hi John&quot;
</code></pre>
<h2 id="条件"><a class="header" href="#条件">条件</a></h2>
<p>你可以用 <code>{% if condition %}</code> ... <code>{% end %}</code> 为产生代码设定条件：</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name}}
    {% if content == 1 %}
      &quot;one&quot;
    {% elsif content == 2 %}
      &quot;two&quot;
    {% else %}
      {{content}}
    {% end %}
  end
end

define_method foo, 1
define_method bar, 2
define_method baz, 3

foo #=&gt; one
bar #=&gt; two
baz #=&gt; 3
</code></pre>
<p>类似于常规代码, <code>Nop</code>, <code>NilLiteral</code> 和一个假 <code>BoolLiteral</code> 被认为 <em>是假的</em>，其他所有东西都是真的。</p>
<p>宏条件在宏定义外面也可以用：</p>
<pre><code class="language-crystal">{% if env(&quot;TEST&quot;) %}
  puts &quot;我们在测试模式&quot;
{% end %}
</code></pre>
<h2 id="迭代"><a class="header" href="#迭代">迭代</a></h2>
<p>你可以迭代有限次：</p>
<pre><code class="language-crystal">macro define_constants(count)
  {% for i in (1..count) %}
    PI_{{i.id}} = Math::PI * {{i}}
  {% end %}
end

define_constants(3)

PI_1 #=&gt; 3.14159...
PI_2 #=&gt; 6.28318...
PI_3 #=&gt; 9.42477... 
</code></pre>
<p>迭代一个 <code>ArrayLiteral</code>:</p>
<pre><code class="language-crystal">macro define_dummy_methods(names)
  {% for name, index in names %}
    def {{name.id}}
      {{index}}
    end
  {% end %}
end

define_dummy_methods [foo, bar, baz]

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<p>上例中 <code>index</code>变量是可选的.</p>
<p>迭代一个 <code>HashLiteral</code>:</p>
<pre><code class="language-crystal">macro define_dummy_methods(hash)
  {% for key, value in hash %}
    def {{key.id}}
      {{value}}
    end
  {% end %}
end
define_dummy_methods({foo: 10, bar: 20})
foo #=&gt; 10
bar #=&gt; 20
</code></pre>
<p>迭代在宏定义外面也可以用：</p>
<pre><code class="language-crystal">{% for name, index in [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] %}
  def {{name.id}}
    {{index}}
  end
{% end %}

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<h2 id="可变数量参数和-嵌入splatting"><a class="header" href="#可变数量参数和-嵌入splatting">可变数量参数和 嵌入(splatting)</a></h2>
<p>宏可以接受可变数量参数：</p>
<pre><code class="language-crystal">macro define_dummy_methods(*names)
  {% for name, index in names %}
    def {{name.id}}
      {{index}}
    end
  {% end %}
end

define_dummy_methods foo, bar, baz

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<p>这些参数被装进一个 <code>ArrayLiteral</code> 传给宏。</p>
<p>另外 <code>*</code>前缀可以把 <code>ArrayLiteral</code>里面的项用逗号相连，然后放出来:</p>
<pre><code class="language-crystal">macro println(*values)
  print {{*values}}, '\n'
end

println 1, 2, 3 # 输出 123\n
</code></pre>
<h2 id="类型信息"><a class="header" href="#类型信息">类型信息</a></h2>
<p>调用宏时你可以用<code>@type</code>这个特殊的实例变量访问这个区域的类型、域。它自己的类型是 <code>TypeNode</code>用于在编译时给你类型信息。</p>
<p>注意 <code>@type</code> 总是 <em>实例</em> 类型, 即使宏是在类方法中调用。</p>
<p>例如：</p>
<pre><code class="language-crystal">macro add_describe_methods
  def describe
    &quot;类型是: &quot; + {{ @type.stringify }}
  end
  
  def self.describe
    &quot;类型是: &quot; + {{ @type.stringify }}
  end
end

class Foo
  add_describe_methods
end

Foo.new.describe #=&gt; &quot;类型是 Foo&quot;
Foo.describe #=&gt; &quot;类型是 Foo&quot;
</code></pre>
<h2 id="常量-1"><a class="header" href="#常量-1">常量</a></h2>
<p>宏可以访问常量，例如：</p>
<pre><code class="language-crystal">VALUES = [1, 2, 3]

{% for value in VALUES %}
  puts {{value}}
{% end %}
</code></pre>
<p>如果常量是类型，你会得到 <code>TypeNode</code>.</p>
<h2 id="嵌套宏"><a class="header" href="#嵌套宏">嵌套宏</a></h2>
<p>你甚至可以定义一个宏来产生更多的宏定义。你必须把里面的宏行与行之间用反斜杠&quot;\&quot;连接起来，以防止它被外面的宏求值</p>
<pre><code class="language-crystal">macro define_macros(*names)
  {% for name in names %}
    macro greeting_for_{{name.id}}(greeting)
      \{% if greeting == &quot;hola&quot; %}
        &quot;¡hola {{name.id}}!&quot;
      \{% else %}
        &quot;\{{greeting.id}} {{name.id}}&quot;
      \{% end %}
    end
  {% end %}
end

# 输出为：
#
#     macro greeting_for_alice
#       {% if greeting == &quot;hola&quot; %}
#         &quot;¡hola alice!&quot;
#       {% else %}
#         &quot;{{greeting.id}} alice&quot;
#       {% end %}
#     end
#     macro greeting_for_bob
#       {% if greeting == &quot;hola&quot; %}
#         &quot;¡hola bob!&quot;
#       {% else %}
#         &quot;{{greeting.id}} bob&quot;
#       {% end %}
#     end
define_macros alice, bob

greeting_for_alice &quot;hello&quot;  #=&gt; &quot;hello alice&quot;
greeting_for_bob &quot;hallo&quot;    #=&gt; &quot;hallo bob&quot;
greeting_for_alice &quot;hej&quot;    #=&gt; &quot;hej alice&quot;
greeting_for_bob &quot;hola&quot;     #=&gt; &quot;¡hola bob!&quot;
</code></pre>
<h2 id="切记"><a class="header" href="#切记">切记</a></h2>
<p>写宏时切记宏产生的代码必须，在插入原位置之前，自己就是合法的Crystal代码。例如，宏里面如果没有<code>case</code>作为表达式开头,那就不能有孤立的<code>when</code>。</p>
<p>这是个不合法的宏：</p>
<pre><code class="language-crystal">case 42
{% for klass in [Int32, String] %}
  when {{klass.id}}
    p &quot;is {{klass}}&quot;
{% end %}
end
</code></pre>
<p>注意 <code>case</code>不在宏里面。这个宏产生孤立的 <code>when</code> 表达式，就不是合法的。你必须用<code>begin</code>和<code>end</code>来把 <code>case</code>包进去:</p>
<pre><code class="language-crystal">{% begin %}
  case 42
  {% for klass in [Int32, String] %}
    when {{klass.id}}
      p &quot;is {{klass}}&quot;
  {% end %}
  end
{% end %}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏方法macro-methods"><a class="header" href="#宏方法macro-methods">宏方法(Macro methods)</a></h1>
<p>宏方法可以帮助你在继承链中为每一个子类添加方法，而只用在基类中定义一次。</p>
<p>一个 <code>def</code> 如果含有涉及<code>@type</code>的宏展开式，那么就会隐式地成为 <code>macro def</code>。例如：</p>
<pre><code class="language-crystal">class Object
  def instance_vars_names
    {{ @type.instance_vars.map &amp;.name.stringify }}
  end
end

class Person
  def initialize(@name : String, @age : Int32)
  end
end

person = Person.new &quot;John&quot;, 30
person.instance_vars_names #=&gt; [&quot;name&quot;, &quot;age&quot;]
</code></pre>
<p>宏定义中参数以AST节点的格式传递，你可以用展开式 (<code>{{ 宏参数 }}</code>)取得它。但是这一点对对宏方法不行。这里的参数列表属于宏方法所产生的方法，你不能在编译时期取得它的值。</p>
<pre><code class="language-crystal">class Object
  def has_instance_var?(name) : Bool
    # 我们不能取得宏展开式里面的 name 
    # 而是通过宏展开创建一个array
    # 然后在运行时做包含检查
    {{ @type.instance_vars.map &amp;.name.stringify }}.includes? name
  end
end

person = Person.new &quot;John&quot;, 30
person.has_instance_var?(&quot;name&quot;) #=&gt; true
person.has_instance_var?(&quot;birthday&quot;) #=&gt; false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="钩子hooks"><a class="header" href="#钩子hooks">钩子(Hooks)</a></h1>
<p>在编译期，一些特殊的宏会作为钩子，在特定的时期调用：</p>
<ul>
<li><code>inherited</code> 当子类定义时调用。 <code>@type</code> 是继承它的类型。</li>
<li><code>included</code> 当模块被包含时调用。 <code>@type</code> 是包含它的类型。</li>
<li><code>extended</code> 当模块被扩展时调用 <code>@type</code> 是扩展它的类型。</li>
<li><code>method_missing</code> 当方法没有找到时调用。</li>
<li><code>method_added</code> 当当前域有新方法添加时调用。</li>
</ul>
<p><code>inherited</code>的例子</p>
<pre><code class="language-crystal">class Parent
  macro inherited
    def lineage
      &quot;{{@type.name.id}} &lt; Parent&quot;
    end
  end
end

class Child &lt; Parent
end

Child.new.lineage #=&gt; &quot;Child &lt; Parent&quot;
</code></pre>
<p><code>method_missing</code>的例子：</p>
<pre><code class="language-crystal">macro method_missing(call)
  print &quot;尝试调用 &quot;, {{call.name.id.stringify}}, &quot; 用 &quot;, {{call.args.size}}, &quot; 个参数&quot;, '\n'
end

foo          # 输出: 尝试调用 foo 用 0 个参数
bar 'a', 'b' # 输出: 尝试调用 bar 用 2 个参数
</code></pre>
<p><code>method_added</code>的例子：</p>
<pre><code class="language-crystal">macro method_added(method)
  {% puts &quot;方法添加:&quot;, method.name.stringify %}
end

def generate_random_number
  4
end
#=&gt; 方法添加: generate_random_number 
</code></pre>
<p><code>method_missing</code> 和 <code>method_added</code> 都只在宏被定义的域内调用。或者，如果宏在顶层定义，那就在顶层调用。例如：</p>
<pre><code class="language-crystal">macro method_missing(call)
  puts &quot;在外部域, 得到调用: &quot;, {{ call.name.stringify }}
end

class SomeClass
  macro method_missing(call)
    puts &quot;在某类内, 尝试调用: &quot;, {{ call.name.stringify }}
  end
end

class OtherClass
end

# 这次调用被外部的`method_missing`处理
foo #=&gt; 在外部域, 得到调用: foo

obj = SomeClass.new
# 这个由在类内的`method_missing`处理
obj.bar #=&gt; 在某类内, 尝试调用: bar

other = OtherClass.new
# 不论是OtherClass还是它的父类都没有定义 `method_missing`
other.baz #=&gt; 错误: 未定义的方法 'baz' 于 OtherClass 中
</code></pre>
<p><code>finished</code> 在类型被完全定义时调用------即是类型的每一处扩展都完成的时候。看如下程序：</p>
<pre><code class="language-crystal">macro print_methods
  {% puts @type.methods.map &amp;.name %}
end

class Foo
  macro finished
    {% puts @type.methods.map &amp;.name %}
  end
  print_methods
end

class Foo
  def bar
    puts &quot;我是一个方法！&quot;
  end
end

Foo.new.bar
</code></pre>
<p><code>print_methods</code> 宏在遇到的时候就调用——然后打出一个空列表，因为这时候<code>Foo</code>里面还没有什么方法。当  <code>Foo</code> 的第二次也是最后一次被定义时， <code>finished</code> 宏会被调用，然后打出 <code>[bar]</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏内变量fresh-variables"><a class="header" href="#宏内变量fresh-variables">宏内变量(Fresh variables)</a></h1>
<p>宏一旦展开，它就会像正常的Crystal代码一样被分析，里面的代码可能涉及原作用域中已定义的变量。</p>
<p>用例子更好理解：</p>
<pre><code class="language-crystal">macro update_x
  x = 1
end

x = 0
update_x
x #=&gt; 1
</code></pre>
<p>有时候这个很有用，你不必特地去读/写局部变量了，不过它也可能不小心覆盖局部变量。你可以用 <code>%name</code> 创建一个宏内变量来避免这个事故：</p>
<pre><code class="language-crystal">macro dont_update_x
  %x = 1
  puts %x
end

x = 0
dont_update_x # outputs 1
x #=&gt; 0
</code></pre>
<p>上例中，我们定义的 <code>%x</code> 在编译器保证不会覆盖到现有作用域的任何一个局部变量。</p>
<p>另外，涉及其他AST节点的宏内变量可以用 <code>%var{key1, key2, ..., keyN}</code>声明。例如：</p>
<pre><code class="language-crystal">macro fresh_vars_sample(*names)
  # First declare vars
  {% for name, index in names %}
    print &quot;声明: &quot;, &quot;%name{index}&quot;, '\n'
    %name{index} = {{index}}
  {% end %}

  # Then print them
  {% for name, index in names %}
    print &quot;%name{index}: &quot;, %name{index}, '\n'
  {% end %}
end

fresh_vars_sample a, b, c

# 样例输出:
# 声明: __temp_255
# 声明: __temp_256
# 声明: __temp_257
# __temp_255: 0
# __temp_256: 1
# __temp_257: 2
</code></pre>
<p>如上，三个下标变量被生成，求值，然后打印，表示它们对应的下标。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性"><a class="header" href="#属性">属性</a></h1>
<p>一些类型和方法可以被标注属性。这些属性暂时是固定的，但是我们最终(也许)会添加用户自定义的属性。</p>
<h2 id="link"><a class="header" href="#link">Link</a></h2>
<p>指示编译器如何链接一个C库。这会在 <a href="syntax_and_semantics/c_bindings/lib.html">lib</a>章解释。</p>
<h2 id="extern"><a class="header" href="#extern">Extern</a></h2>
<p>标明某个 Crystal 结构体可以在库定义中应用：</p>
<pre><code class="language-crystal">@[Extern]
struct MyStruct
end

lib MyLib
  fun my_func(s : MyStruct) # OK (如果没有 Extern 属性，就会报错)
end
</code></pre>
<p>你也可以让结构体看起来像 C 的联合体(union) ,尽管这个真的不安全：</p>
<pre><code class="language-crystal"># 一个结构体，来简单地在 Int32 码点和 Char 之间做转化。
@[Extern(union: true)]
struct Int32OrChar
  property int = 0
  property char = '\0'
end

s = Int32OrChar.new
s.char = 'A'
s.int # =&gt; 65

s.int = 66
s.char # =&gt; 'B'
</code></pre>
<h2 id="threadlocal"><a class="header" href="#threadlocal">ThreadLocal</a></h2>
<p><code>@[ThreadLocal]</code>属性可以加给类变量和外部C变量。这会让他们变成线程局部变量。</p>
<pre><code class="language-crystal">class DontUseThis
  # 每个线程分别有一份
  @[ThreadLocal]
  @@values = [] of Int32
end
</code></pre>
<p>线程局部变量在标准库中使用，用于实现运行时。此外它不应该被用到。</p>
<h2 id="packed"><a class="header" href="#packed">Packed</a></h2>
<p>标志一个 <a href="syntax_and_semantics/c_bindings/struct.html">C 结构体</a> 是紧密的，这样结构体的域之间就不会被填充用于对齐的字节。这个当C结构体显式地要求紧密结构体时使用。 </p>
<h2 id="alwaysinline"><a class="header" href="#alwaysinline">AlwaysInline</a></h2>
<p>提示编译器总是内联该方法：</p>
<pre><code class="language-crystal">@[AlwaysInline]
def foo
  1
end
</code></pre>
<h2 id="noinline"><a class="header" href="#noinline">NoInline</a></h2>
<p>指示编译器不要内联一个方法调用。这不适用于带有<code>yield</code>的方法,因为它们总是被内联。</p>
<pre><code class="language-crystal">@[NoInline]
def foo
  1
end
</code></pre>
<h2 id="returnstwice"><a class="header" href="#returnstwice">ReturnsTwice</a></h2>
<p>标志一个方法或 <a href="syntax_and_semantics/c_bindings/fun.html">C库函数</a> 返回两次。 C 的 <code>setjmp</code> 是这种函数的一个例子。</p>
<h2 id="raises"><a class="header" href="#raises">Raises</a></h2>
<p>标志一个方法或<a href="syntax_and_semantics/c_bindings/fun.html">C库函数</a>可能扔出一个异常。这在 <a href="syntax_and_semantics/c_bindings/callbacks.html">C 回调函数</a>一章有解释。</p>
<h2 id="callconvention"><a class="header" href="#callconvention">CallConvention</a></h2>
<p>指示 <a href="syntax_and_semantics/c_bindings/fun.html">C库函数</a>的调用约定。例如：</p>
<pre><code class="language-crystal">lib LibFoo
  @[CallConvention(&quot;X86_StdCall&quot;)]
  fun foo : Int32
end
</code></pre>
<p>目前可用的调用约定有：</p>
<ul>
<li>C (默认值)</li>
<li>Fast</li>
<li>Cold</li>
<li>WebKit_JS</li>
<li>AnyReg</li>
<li>X86_StdCall</li>
<li>X86_FastCall</li>
</ul>
<p>它们在<a href="http://llvm.org/docs/LangRef.html#calling-conventions">这里</a>有解释。</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<p>标志一个<a href="syntax_and_semantics/enum.html">枚举</a> 是 &quot;位枚举&quot;，这会改变一些方法的行为，如 <code>to_s</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="底层原语"><a class="header" href="#底层原语">底层原语</a></h1>
<p>Crystal 提供了一些底层原语，它们在调用C库函数和编写底层代码时尤其有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointerof"><a class="header" href="#pointerof">pointerof</a></h1>
<p>表达式 <code>pointerof</code> 返回指向这个变量的<a href="http://crystal-lang.org/api/Pointer.html">指针</a>。</p>
<p>对变量的例子：</p>
<pre><code class="language-crystal">a = 1

ptr = pointerof(a)
ptr.value = 2

a #=&gt; 2
</code></pre>
<p>对实例变量的例子：</p>
<pre><code class="language-crystal">class Point
  def initialize(@x : Int32, @y : Int32)
  end

  def x
    @x
  end

  def x_ptr
    pointerof(@x)
  end
end

point = Point.new 1, 2

ptr = point.x_ptr
ptr.value = 10

point.x #=&gt; 10
</code></pre>
<p>因为 <code>pointerof</code> 涉及指针操作，它被认为是 <a href="syntax_and_semantics/unsafe.html">不安全</a>的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sizeof"><a class="header" href="#sizeof">sizeof</a></h1>
<p>表达式<code>sizeof</code>返回一个 <code>Int32</code>,表示该类型变量以字节计占空间的大小。例如:</p>
<pre><code class="language-crystal">sizeof(Int32)  #=&gt; 4
sizeof(Int64)  #=&gt; 8
</code></pre>
<p>对于引用(<a href="http://crystal-lang.org/api/Reference.html">Reference</a> )类型，这个大小等同于指向它的指针的大小 ：</p>
<pre><code class="language-crystal"># 在 64 位机上
sizeof(Pointer(Int32)) #=&gt; 8
sizeof(String)         #=&gt; 8
</code></pre>
<p>这是因为引用类型变量的内存是在堆上分配的，传递时只传递它的指针。为了得到一个类的真正大小，请用 <a href="syntax_and_semantics/instance_sizeof.html">instance_sizeof</a>。</p>
<p>sizeof 的参数是一个 <a href="syntax_and_semantics/type_grammar.html">类型</a> ，往往与 <a href="syntax_and_semantics/typeof.html">typeof</a>配合使用：</p>
<pre><code class="language-crystal">a = 1
sizeof(typeof(a)) #=&gt; 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance_sizeof"><a class="header" href="#instance_sizeof">instance_sizeof</a></h1>
<p><code>instance_sizeof</code> 表达式返回一个 <code>Int32</code>，表示这个类实例的空间大小。例如：</p>
<pre><code class="language-crystal">class Point
  def initialize(@x, @y)
  end
end

Point.new 1, 2

# 2 x Int32 = 2 x 4 = 8
instance_sizeof(Point) #=&gt; 12
</code></pre>
<p>即使这个实例只有两个 <code>Int32</code>字段，编译器总会添加一个额外的 <code>Int32</code> 字段，表示这个对象的类型 id。因此这个实例的大小是12，而不是8。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明未初始化的变量"><a class="header" href="#声明未初始化的变量">声明未初始化的变量</a></h1>
<p>Crystal 允许你声明变量，而不初始化它：</p>
<pre><code class="language-crystal">x = uninitialized Int32
x #=&gt; 一些随机而无用的信息，不要假设它有任何行为。
</code></pre>
<p>这是<a href="syntax_and_semantics/unsafe.html">不安全的</a>代码，并且总是用于底层代码的适配。最常见的例子是声明一个未初始化的 <a href="http://crystal-lang.org/api/StaticArray.html">StaticArray</a> (静态数组) 做缓冲区，而不必担心性能开销：</p>
<pre><code class="language-crystal">buffer = uninitialized UInt8[256]
</code></pre>
<p>这个缓冲区会在栈上分配，不会分配在堆上。</p>
<p><code>uninitialized</code> 关键字之后的类型应符合 <a href="syntax_and_semantics/type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译时标记"><a class="header" href="#编译时标记">编译时标记</a></h1>
<p>类型，方法，或是其他任何代码都可以依赖编译时标记给出的信息。这些标志一般从宿主的 <a href="http://llvm.org/docs/LangRef.html#target-triple">LLVM 目标三元组</a>按 <code>-</code>分割而来。为了得到这些信息，你可以执行 <code>llvm-config --host-target</code>.</p>
<pre><code class="language-bash">$ llvm-config --host-target
x86_64-unknown-linux-gnu

# 所以这些标志是: x86_64, unknown, linux, gnu
</code></pre>
<p>为了定义一个标志，只需要用 <code>--define</code> 或 <code>-D</code> 选项，例如：</p>
<pre><code class="language-bash">$ crystal some_program.cr -Dflag
</code></pre>
<p>另外，如果程序以 <code>--release</code>编译，那也会添加 <code>release</code>标志。</p>
<p>你可以用<code>flag?</code>查看一个标志是否被定义：</p>
<pre><code class="language-crystal">{% if flag?(:x86_64) %}
  # 对 64 位平台特化的代码
{% else %}
  # 对非 64 位平台特化的代码
{% end %}
</code></pre>
<p><code>flag?</code> 返回一个布尔值，所以你可以配合 <code>&amp;&amp;</code> 和 <code>||</code>使用：</p>
<pre><code class="language-crystal">{% if flag?(:linux) &amp;&amp; flag?(:x86_64) %}
  # 对 64 linux 特化的代码  
{% end %}
</code></pre>
<p>这些标志往往用于C绑定，以条件性地定义类型和函数。例如，著名的 <code>size_t</code>类型在 Crystal 中是这样定义的：</p>
<pre><code class="language-crystal">lib C
  {% if flag?(:x86_64) %}
    alias SizeT = UInt64
  {% else %}
    alias SizeT = UInt32
  {% end %}
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<p>Crystal 支持基础形式的 <a href="http://en.wikipedia.org/wiki/Cross_compiler">交叉编译</a>.</p>
<p>为了使用这个功能，编译器提供了两个标志：</p>
<ul>
<li><code>--cross-compile</code>：启用交叉编译模式</li>
<li><code>--target</code>: 设置目标的 <a href="http://llvm.org/docs/LangRef.html#target-triple">LLVM 目标三元组</a>，这会改变 <a href="syntax_and_semantics/compile_time_flags.html">编译时标志</a>的默认设置</li>
</ul>
<p>如果LLVM的版本在3.5及以上，你可以用 <code>llvm-config --host-target</code> 命令得到 <code>--target</code> 标志。对 linux，它可能是 &quot;x86_64-unknown-linux-gnu&quot;。</p>
<p>如果你需要设置<code>--target</code> 之外的标志，你可以用<code>-D</code>命令行标志进行设置。</p>
<p>用这两个参数，你可以在 Mac 上编译程序，然后在 Linux 上运行：</p>
<pre><code class="language-bash">crystal build your_program.cr --cross-compile --target &quot;x86_64-unknown-linux-gnu&quot;
</code></pre>
<p>这会创建一个 <code>.o</code> (<a href="http://en.wikipedia.org/wiki/Object_file">对象文件</a>) ，然后打出一个命令行，你应该在目标系统上执行它。例如：</p>
<pre><code class="language-bash">cc your_program.o -o your_program -lpcre -lrt -lm -lgc -lunwind
</code></pre>
<p>你应当把这个 <code>.o</code> 文件复制到目标系统，然后执行这个命令。然后这个.o文件才会真正地被链接成为可执行文件。</p>
<p>这个过程通常由编译器自己完成，用于把编译器移植到一个尚没有编译器的系统。编译Crystal需要一个先前的Crystal编译器，但是如果没有编译器呢？那就只有两种办法：</p>
<ul>
<li>检查用 Ruby 写成的最新版本的编译器，用它编译下一个版本，下下一个版本，直到当前的版本。</li>
<li>生成一个目标系统的 <code>.o</code> 文件，然后向目标系统链接它。</li>
</ul>
<p>第一个过程又长又累人，第二个相比就比较简单了。</p>
<p>交叉编译也可以用于其他的程序，但主要的目标是编译器。如果有些系统不支持Crystal，你就可以自己编译一个编译器出来。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c语言绑定"><a class="header" href="#c语言绑定">C语言绑定</a></h1>
<p>Crystal 允许你绑定C语言库中的函数,而不用写一行C代码。</p>
<p>另外，她提供了 <code>out</code>和 <code>to_unsafe</code>之类的简便写法，以尽可能减少绑定的痛苦。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lib"><a class="header" href="#lib">lib</a></h1>
<p>用<code>lib</code>声明某个库的一系列C函数和类型。</p>
<pre><code class="language-crystal">@[Link(&quot;pcre&quot;)]
lib LibPCRE
end
</code></pre>
<p>尽管编译器不强制，一个 <code>lib</code>的名称往往以 <code>Lib</code>开头。</p>
<p>编译器会根据<code>lib</code>头上的属性找到它要链接的外部库：</p>
<ul>
<li><code>@[Link(&quot;pcre&quot;)]</code> 会把 <code>-lpcre</code> 标志传递给链接器，但编译器会首先尝试使用 <a href="http://en.wikipedia.org/wiki/Pkg-config">pkg-config</a>。</li>
<li><code>@[Link(ldflags: &quot;...&quot;)]</code> 会直接把标志原样传给链接器。例如： <code>@[Link(ldflags: &quot;-lpcre&quot;)]</code>。常见的方法是使用反引号来执行命令： <code>@[Link(ldflags: &quot;`pkg-config libpcre --libs`&quot;)]</code>。</li>
<li><code>@[Link(framework: &quot;Cocoa&quot;)]</code> 会把 <code>-framework Cocoa</code> 传给链接器 (只在 Mac OS X 上有用)。</li>
</ul>
<p>当这个库已经被隐式地链接时，属性会被忽略。例如libc。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fun"><a class="header" href="#fun">fun</a></h1>
<p>在 <code>lib</code> 内部，用 <code>fun</code>声明一个 C 函数。</p>
<pre><code class="language-crystal">lib C
  # 在 C 中: double cos(double x)
  fun cos(value : Float64) : Float64
end
</code></pre>
<p>只要绑定完成，这个函数就能像<code>C</code>类型的一个类方法一样被调用：</p>
<pre><code class="language-crystal">C.cos(1.5) #=&gt; 0.0707372
</code></pre>
<p>如果函数没有参数，你可以省略括号 (当然在调用中也可以省略)：</p>
<pre><code class="language-crystal">lib C
  fun getch : Int32
end

C.getch
</code></pre>
<p>如果返回类型是空的，你可以省略它：</p>
<pre><code class="language-crystal">lib C
  fun srand(seed : UInt32)
end

C.srand(1_u32)
</code></pre>
<p>你可以绑定到可变参数数目的函数：</p>
<pre><code class="language-crystal">lib X
  fun variadic(value : Int32, ...) : Int32
end

X.variadic(1, 2, 3, 4)
</code></pre>
<p>注意，调用C函数时参数不会进行任何的隐式转换 (除了 <code>to_unsafe</code>，下面将会解释)：你必须准确地传递所需类型。对于整数和浮点数，你可以使用 <code>to_...</code>系列方法。</p>
<h2 id="函数名"><a class="header" href="#函数名">函数名</a></h2>
<p>不同于 <code>lib</code>外的方法，<code>lib</code> 内的函数名可以以大写字母开头(相对地，<code>lib</code>外的方法只能以小写字母开头)。</p>
<p>Crystal 里的函数名可以与 C 中的函数名不同。下面的例子展示了如何把 C 函数 <code>SDL_Init</code> 绑定到 Crystal 的<code>LibSDL.init</code>。</p>
<pre><code class="language-crystal">lib LibSDL
  fun init = SDL_Init(flags : UInt32) : Int32
end
</code></pre>
<p>如果 C 函数名不是有效的标识符，他们应该用引号括起来：</p>
<pre><code class="language-crystal">lib LLVMIntrinsics
  fun ceil_f32 = &quot;llvm.ceil.f32&quot;(value : Float32) : Float32
end
</code></pre>
<p>这也用于给C函数起一个更短，更好听的名字，因为它们往往很长，前面还带有库的名称。</p>
<h2 id="c-绑定中的类型"><a class="header" href="#c-绑定中的类型">C 绑定中的类型</a></h2>
<p>C 绑定中可以用的类型有：</p>
<ul>
<li>原始类型 (<code>Int8</code>, ..., <code>Int64</code>, <code>UInt8</code>, ..., <code>UInt64</code>, <code>Float32</code>, <code>Float64</code>)</li>
<li>指针类型 (<code>Pointer(Int32)</code>, 也可以写成 <code>Int32*</code>)</li>
<li>静态数组 (<code>StaticArray(Int32, 8)</code>, 也可以写成 <code>Int32[8]</code>)</li>
<li>函数类型 (<code>Function(Int32, Int32)</code>, 也可以写成 <code>Int32 -&gt; Int32</code>)</li>
<li>其他先前已经定义的 <code>struct</code>, <code>union</code>, <code>enum</code>, <code>type</code> 或 <code>alias</code> 。</li>
<li><code>Void</code>: 表示没有返回值。</li>
<li><code>NoReturn</code>: 类似于 <code>Void</code>，但编译器知道它调用后绝不返回。</li>
<li>标有 <code>@[Extern]</code> 属性的Crystal结构体</li>
</ul>
<p>fun 中类型的记名参见 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a>。</p>
<p>标准库定义了 <a href="https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr">LibC</a> 库，内含C中常见的类型，如 <code>int</code>, <code>short</code>, <code>size_t</code>。 它们可以这样使用：</p>
<pre><code class="language-crystal">lib MyLib
  fun my_fun(some_size : LibC::SizeT)
end
</code></pre>
<p><strong>注意:</strong> C 中的 <code>char</code> 在 Crystal 中是<code>UInt8</code> , 因此 <code>char*</code> 或 <code>const char*</code> 应当是 <code>UInt8*</code>。 Crystal中的 <code>Char</code>类型表示 unicode codepoint ，所以它占四个字节，类似于 <code>Int32</code>，而不是 <code>UInt8</code>。如果搞不明白，直接用别名 <code>LibC::Char</code>就行了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="out"><a class="header" href="#out">out</a></h1>
<p>考虑 <a href="http://www.gnu.org/software/libc/manual/html_node/Process-Completion.html">waitpid</a> 这个函数：</p>
<pre><code class="language-crystal">lib C
  fun waitpid(pid : Int32, status_ptr : Int32*, options : Int32) : Int32
end
</code></pre>
<p>这个函数的文档说：</p>
<pre><code>子程序的状态信息会储存到status_ptr指向的对象，除非status_ptr是空指针。
</code></pre>
<p>我们可以这样使用它：</p>
<pre><code class="language-crystal">pid = ...
options = ...
status_ptr = uninitialized Int32

C.waitpid(pid, pointerof(status_ptr), options)
</code></pre>
<p>这样我们给 <code>status_ptr</code>传递了一个指针，让他填充值。</p>
<p>不过有一种简便的方法，那就是 <code>out</code>参数：</p>
<pre><code class="language-crystal">pid = ...
options = ...

C.waitpid(pid, out status_ptr, options)
</code></pre>
<p>编译器会自动声明一个<code>Int32</code>类型的变量 <code>status_ptr</code>，因为参数类型是 <code>Int32*</code>。</p>
<p>这对任何类型都适用，只要参数是指针类型。 (当然这个函数要真的填充这个变量)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to_unsafe"><a class="header" href="#to_unsafe">to_unsafe</a></h1>
<p>如果类型定义了 <code>to_unsafe</code>方法，当传递给 C 函数时，这个方法会被自动调用。例如：</p>
<pre><code class="language-crystal">lib C
  fun exit(status : Int32) : NoReturn
end

class IntWrapper
  def initialize(@value)
  end

  def to_unsafe
    @value
  end
end

wrapper = IntWrapper.new(1)
C.exit(wrapper) # 不是 Int32, 但是它的 to_unsafe 方法返回值是
                # 所以 wrapper.to_unsafe会被传进去
</code></pre>
<p>这用于定义C类型的包装类，而对C使用它们的时候又不用手动拆包。</p>
<p>例如 <code>String</code> 类实现了 <code>to_unsafe</code> 方法，返回 <code>UInt8*</code>：</p>
<pre><code class="language-crystal">lib C
  fun printf(format : UInt8*, ...) : Int32
end

a = 1
b = 2
C.printf &quot;%d + %d = %d\n&quot;, a, b, a + b
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">struct</a></h1>
<p>在<code>lib</code>中用<code>struct</code> 声明一个C结构体。</p>
<pre><code class="language-crystal">lib C
  # C 中:
  #
  #  struct TimeZone {
  #    int minutes_west;
  #    int dst_time;
  #  };
  struct TimeZone
    minutes_west : Int32
    dst_time     : Int32
  end
end
</code></pre>
<p>你也能声明多个同类型的成员变量：</p>
<pre><code class="language-crystal">lib C
  struct TimeZone
    minutes_west, dst_time : Int32
  end
end
</code></pre>
<p>递归的结构体如你所想的那样起效：</p>
<pre><code class="language-crystal">lib C
  struct LinkedListNode
    prev, _next : LinkedListNode*
  end
  
  struct LinkedList
    head : LinkedListNode*
  end
end
</code></pre>
<p>用 <code>new</code>创建结构体实例：</p>
<pre><code class="language-crystal">tz = C::TimeZone.new
</code></pre>
<p>这会在栈上分配结构体。</p>
<p>C 结构体刚声明是，所有的成员都会被设为 &quot;零&quot;： 整数和浮点数是零，指针指向地址位置 0，诸如此类。</p>
<p>你可以用 <code>uninitialized</code>避免这样的初始化：</p>
<pre><code class="language-crystal">tz = uninitialized C::TimeZone
tz.minutes_west #=&gt; 无意义值
</code></pre>
<p>它的成员都可以被读写：</p>
<pre><code class="language-crystal">tz = C::TimeZone.new
tz.minutes_west = 1
tz.minutes_west #=&gt; 1
</code></pre>
<p>如果被赋予的值不正好是成员的值，它会尝试匹配 <a href="syntax_and_semantics/c_bindings/to_unsafe.html">to_unsafe</a>方法。</p>
<p>你也可以用类似于<a href="syntax_and_semantics/c_bindings/../default_and_named_arguments.html">命名参数</a>的语法初始化结构体的某些域：</p>
<pre><code class="language-crystal">tz = C::TimeZone.new minutes_west: 1, dst_time: 2
tz.minutes_west #=&gt; 1
tz.dst_time     #=&gt; 2
</code></pre>
<p>C 结构体按值(复制地)传入函数的方法，返回时也总是按值返回：</p>
<pre><code class="language-crystal">def change_it(tz)
  tz.minutes_west = 1
end

tz = C::TimeZone.new
change_it tz
tz.minutes_west #=&gt; 0
</code></pre>
<p>成员类型的声明参见 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union"><a class="header" href="#union">union</a></h1>
<p>在 <code>lib</code> 中用<code>union</code>声明C的联合体：</p>
<pre><code class="language-crystal">lib U
  # C中:
  #
  #  union IntOrFloat {
  #    int some_int;
  #    double some_float;
  #  };
  union IntOrFloat
    some_int : Int32
    some_float : Float64
  end
end
</code></pre>
<p>用 <code>new</code>创建联合体的实例:</p>
<pre><code class="language-crystal">value = U::IntOrFloat.new
</code></pre>
<p>这会在栈上分配联合体。</p>
<p>C联合体初始化时所有的域都是 &quot;零&quot;: 整数和浮点数是零，指针指向地址零。</p>
<p>你可以用<code>uninitialized</code>纸面这样的初始化：</p>
<pre><code class="language-crystal">value = uninitialized U::IntOrFloat
value.some_int #=&gt; 无意义值
</code></pre>
<p>你可以读写其中的成员：</p>
<pre><code class="language-crystal">value = U::IntOrFloat.new
value.some_int = 1
value.some_int #=&gt; 1
value.some_float #=&gt; 4.94066e-324
</code></pre>
<p>如果这个赋值的类型并不正好是属性的值，那么会尝试调用 <a href="syntax_and_semantics/c_bindings/to_unsafe.html">to_unsafe</a>方法，然后把返回值传进去。</p>
<p>C联合体按值(复制地)传递给函数和方法，并且也总是按值返回：</p>
<pre><code class="language-crystal">def change_it(value)
  value.some_int = 1
end

value = U::IntOrFloat.new
change_it value
value.some_int #=&gt; 0
</code></pre>
<p>成员类型的声明详见 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">enum</a></h1>
<p>在<code>lib</code> 中用<code>enum</code>声明C的枚举：</p>
<pre><code class="language-crystal">lib X
  # C 中:
  #
  #  enum SomeEnum {
  #    Zero,
  #    One,
  #    Two,
  #    Three,
  #  };
  enum SomeEnum
    Zero
    One
    Two
    Three
  end
end
</code></pre>
<p>如同C的枚举, 第一个成员的值为零，随后每个成员数目增加1。</p>
<p>使用一个值：</p>
<pre><code class="language-crystal">X::SomeEnum::One #=&gt; One
</code></pre>
<p>你可以指定成员的值：</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    Ten = 10
    Twenty = 10 * 2
    ThirtyTwo = 1 &lt;&lt; 5
  end
end
</code></pre>
<p>如你所见，枚举的值可以用成员的值可以做一些基本的数值运算： <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&amp;</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code> 和 <code>%</code>。</p>
<p>枚举成员的类型默认是 <code>Int32</code> ，即使你在单个成员中使用了不同的类型：</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    A = 1_u32
  end
end

X::SomeEnum #=&gt; 1_i32
</code></pre>
<p>不过你可以改变基础类型：</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum : Int8
    Zero,
    Two = 2
  end
end

X::SomeEnum::Zero #=&gt; 0_i8
X::SomeEnum::Two  #=&gt; 2_i8
</code></pre>
<p>你可以被枚举作为 <code>fun</code> 的参数，和 <code>struct</code> 或 <code>union</code> 的成员:</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    One
    Two
  end

  fun some_fun(value : SomeEnum)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>C库中暴露的变量可以用全局变量的形式在 <code>lib</code> 中定义：</p>
<pre><code class="language-crystal">lib C
  $errno : Int32
end
</code></pre>
<p>而后他可以进行读写：</p>
<pre><code class="language-crystal">C.errno #=&gt; some value
C.errno = 0
C.errno #=&gt; 0
</code></pre>
<p>可以用属性把变量设为线程局部变量：</p>
<pre><code class="language-crystal">lib C
  @[ThreadLocal]
  $errno : Int32
end
</code></pre>
<p>外部变量的类型定义也如同 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量-2"><a class="header" href="#常量-2">常量</a></h1>
<p>你也可以在 <code>lib</code> 中声明常量：</p>
<pre><code class="language-crystal">@[Link(&quot;pcre&quot;)]
lib PCRE
  INFO_CAPTURECOUNT = 2
end

PCRE::INFO_CAPTURECOUNT #=&gt; 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type"><a class="header" href="#type">type</a></h1>
<p><code>lib</code> 中的 <code>type</code> 声明类似于C的 <code>typedef</code>，但是更强：</p>
<pre><code class="language-crystal">lib X
  type MyInt = Int32
end
</code></pre>
<p>不同于 C， <code>Int32</code> 和 <code>MyInt</code> 不能互通：</p>
<pre><code class="language-crystal">lib X
  type MyInt = Int32

  fun some_fun(value : MyInt)
end

X.some_fun 1 # 错误: 'X#some_fun' 的参数 'value'  
             # 必须是 X::MyInt, 而不是 Int32
</code></pre>
<p>因此， <code>type</code> 可以在C绑定中定义隐晦的类型。一个例子是C 的<code>FILE</code> 类型，你可以用 <code>fopen</code>获得。</p>
<p>这种类型的定义也如同 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h1>
<p><code>lib</code> 中的 <code>alias</code> 声明类似于C的 <code>typedef</code>：</p>
<pre><code class="language-crystal">lib X
  alias MyInt = Int32
end
</code></pre>
<p>这里 <code>Int32</code> 和 <code>MyInt</code> 是互通的：</p>
<pre><code class="language-crystal">lib X
  alias MyInt = Int32

  fun some_fun(value : MyInt)
end

X.some_fun 1 # OK
</code></pre>
<p><code>alias</code> 最适合用来避免写超长类型声明，同时创建一个编译时类型标志：</p>
<pre><code class="language-crystal">lib C
  {% if flag?:(x86_64) %}
    alias SizeT = Int64
  {% else %}
    alias SizeT = Int32
  {% end %}

  fun memcmp(p1 : Void*, p2 : Void*, size : C::SizeT) : Int32
end
</code></pre>
<p>类型别名的定义也如同 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回调"><a class="header" href="#回调">回调</a></h1>
<p>你可以在C 库中声明函数类型：</p>
<pre><code class="language-crystal">lib X
  # In C:
  #
  #    void callback(int (*f)(int));
  fun callback(f : Int32 -&gt; Int32)
end
</code></pre>
<p>而后你可以这样传递一个函数 (<a href="http://crystal-lang.org/api/Proc.html">Proc</a>)：</p>
<pre><code class="language-crystal">f = -&gt;(x : Int32) { x + 1 }
X.callback(f)
</code></pre>
<p>如果你在调用时只写了一个块，那你可以不写类型，让编译器根据<code>fun</code>的签名替你标出来：</p>
<pre><code class="language-crystal">X.callback -&gt;(x) { x + 1 }
</code></pre>
<p>但是，注意，这些传递给C的函数不能形成闭包。如果编译器发现这个函数是一个闭包，它会报错：</p>
<blockquote>
<p>因为C的函数不过是一个函数指针,它就没有带其运行所需的环境。</p>
</blockquote>
<pre><code class="language-crystal">y = 2
X.callback -&gt;(x) { x + y } # 错误: 不能向C的函数传递闭包
</code></pre>
<p>如果编译器在编译时没有发现，那就会在运行时产生异常。</p>
<p>回调所需的函数类型详见 <a href="syntax_and_semantics/c_bindings/../type_grammar.html">类型语法</a> </p>
<p>如果你不想传递回调函数，而只是传递 <code>NULL</code>(空指针)，你可以传 <code>nil</code>：</p>
<pre><code class="language-crystal"># 等同于C中的 callback(NULL) 
X.callback nil
</code></pre>
<h3 id="向-c-函数中传递闭包"><a class="header" href="#向-c-函数中传递闭包">向 C 函数中传递闭包</a></h3>
<p>C 在设置回调函数时往往允许附带一个void指针，用来传递这个函数所需的环境。举个例子，如果有个C函数每一刻都要执行某个函数，同时每次都需要刻的序号：</p>
<pre><code class="language-crystal">lib LibTicker
  fun on_tick(callback : (Int32, Void* -&gt;), data : Void*)
end
</code></pre>
<p>To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it.</p>
<pre><code class="language-crystal">module Ticker
  @@box : Box(Int32 -&gt;)

  # 用户用的回调不用带 Void*
  def self.on_tick(&amp;callback : Int32 -&gt;)
    # 因为 Proc 本质上就是 {Void*, Void*}, 我们不能把缩减成一个 Void*,
    # 所以我们把它&quot;包起来&quot; : 我们在这里分配内存,存储 Proc 的环境
    boxed_data = Box.box(callback)

    # 我们必须在 Crystal的地盘存储这个函数和它的内存,以免 GC 收走他(*)
    @@box = boxed_data

    # 我们把Process分成两份传递,一份是单独的函数指针,另一份是函数所需的环境
    LibTicker.on_tick(-&gt;(tick, data) {
      # 我们用 Box.unbox 把数据还给 Proc
      data_as_callback = Box(typeof(callback)).unbox(data)
      # 现在我们才调用用户层的回调函数
      data_as_callback.call(tick)
    }, boxed_data)
  end
end

Ticker.on_tick do |tick|
  puts tick
end
</code></pre>
<p>注意我们用在 <code>@@box</code>中存储了包装起来的回调函数。这是因为如果我们不这么做，我们的代码就引用不到它了， GC就会把它收走。C库当然会存储这个回调，但是 Crystal 的 GC 不可能知道这些。</p>
<h2 id="raises-属性"><a class="header" href="#raises-属性">Raises 属性</a></h2>
<p>如果 C 函数所执行的用户回调可能抛异常，他就必须加以 <code>@[Raises]</code> 属性。</p>
<p>即使你没有加<code>@[Raises]</code> ，却在回调(或是回调的子函数)中确实抛出了异常，编译器也会替你加上它。</p>
<p>但是，有些C函数存储回调函数，以供其他C函数使用。例如，考虑一个假想的库：</p>
<pre><code class="language-crystal">lib LibFoo
  fun store_callback(callback : -&gt;)
  fun execute_callback
end

LibFoo.store_callback -&gt;{ raise &quot;OH NO!&quot; }
LibFoo.execute_callback
</code></pre>
<p>如果<code>store_callback</code>存储的这个回调函数会抛异常，那么 <code>execute_callback</code> 也会抛异常。然而，编译器不知道这个 <code>execute_callback</code> 也可能抛异常(因为他没有标注<code>@[Raises]</code>，编译器也没有其他的线索猜出来)，这时你必须手动把它标出来：</p>
<pre><code class="language-crystal">lib LibFoo
  fun store_callback(callback : -&gt;)

  @[Raises]
  fun execute_callback
end
</code></pre>
<p>如果你不标它，这个函数周围的 <code>begin/rescue</code> 块可能会产生意想不到的麻烦。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不安全的unsafe-代码"><a class="header" href="#不安全的unsafe-代码">不安全的(Unsafe) 代码</a></h1>
<p>语言的这些部分被认为是不安全的：</p>
<ul>
<li>涉及裸指针： <a href="http://crystal-lang.org/api/Pointer.html">Pointer</a> 类型和 <a href="syntax_and_semantics/pointerof.html">pointerof</a>.</li>
<li><a href="syntax_and_semantics/new,_initialize_and_allocate.html">allocate</a> 类方法.</li>
<li>涉及C绑定</li>
<li><a href="syntax_and_semantics/declare_var.html">声明未初始化的变量</a></li>
</ul>
<p>&quot;Unsafe&quot; 意味着可能出现内存崩坏，段错误或程序崩溃。例如：</p>
<pre><code class="language-crystal">a = 1
ptr = pointerof(a)
ptr[100_000] = 2   # 未定义行为，可能出现段错误
</code></pre>
<p>然而，正常的程序往往用不到手动操纵指针或是未初始化的变量。C函数的安全绑定也往往包括空指针和界限检查。</p>
<p>没有语言 100% 安全：总有部分注定要和底层打交道，与操作系统交互，涉及指针操作。但是只要你建立了抽象，在更高的层面进行操作，并且假设底下的地基是安全的(通过测试和形式证明来证实)，那么你就可以认为整个代码也是安全的。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="约定"><a class="header" href="#约定">约定</a></h1>
<p>这些约定有助于其他人理解你的代码。</p>
<ul>
<li>使用<a href="conventions/coding_style.html">标准代码风格</a>，这样镖人就能方便地读懂你项目的结构和内容。</li>
<li>写 <a href="conventions/documenting_code.html">文档</a> 来表示你代码的意图，同时方便 <code>crystal doc</code> 从你的注释产生文档。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码风格"><a class="header" href="#代码风格">代码风格</a></h1>
<p>这是标准库的代码风格。你可以使用它，这样其他开发者也会熟悉你的项目。</p>
<h2 id="命名"><a class="header" href="#命名">命名</a></h2>
<p><strong>类名</strong>用大驼峰。例如：</p>
<pre><code class="language-crystal">class ParseError &lt; Exception
end

module HTTP
  class RequestHandler
  end
end

alias NumericValue = Float32 | Float64 | Int32 | Int64

lib LibYAML
end

struct TagDirective
end

enum Time::DayOfWeek
end
</code></pre>
<p><strong>方法名</strong>用下划线连接。例如：</p>
<pre><code class="language-crystal">class Person
  def first_name
  end

  def date_of_birth
  end

  def homepage_url
  end
end
</code></pre>
<p>变量名也用下划线式。例如：</p>
<pre><code class="language-crystal">class Greeting
  @@default_greeting = &quot;Hello world&quot;

  def initialize(@custom_greeting = nil)
  end

  def print_greeting
    greeting = @custom_greeting || @@default_greeting
    puts greeting
  end
end
</code></pre>
<p><strong>常量</strong>全大写。例如： </p>
<pre><code class="language-crystal">LUCKY_NUMBERS     = [3, 7, 11]
DOCUMENTATION_URL = &quot;http://crystal-lang.org/docs&quot;
</code></pre>
<h3 id="缩写"><a class="header" href="#缩写">缩写</a></h3>
<p>类名里面：字母缩写 <em>全大写</em>。比如 <code>HTTP</code>或 <code>LibXML</code>。</p>
<p>方法名里面： 字母缩写 <em>全小写</em>。比如 <code>#from_json</code>， <code>#to_io</code>。</p>
<h3 id="libs"><a class="header" href="#libs">Libs</a></h3>
<p><code>Lib</code> 就用 <code>Lib</code>做前缀。比如。<code>LibC</code>， <code>LibEvent2</code>。</p>
<h3 id="路径和文件名"><a class="header" href="#路径和文件名">路径和文件名</a></h3>
<p>项目内：</p>
<ul>
<li><code>/</code> 含有 readme, 构建选项， (比如 CI 编辑器设置)，和其他项目级文件。 (比如 修改日志 或 贡献指南).</li>
<li><code>src/</code> 含有项目源代码。</li>
<li><code>spec/</code> 含有 <a href="conventions/../guides/testing.html">项目测试</a>，它可以用 <code>crystal spec</code>执行。</li>
<li><code>bin/</code> 含有可执行文件。</li>
</ul>
<p>文件以其类或命名空间的名字一致，用<em>下划线</em>分隔。</p>
<p>比如， <code>HTTP::WebSocket</code> 定义于 <code>src/http/web_socket.cr</code>。</p>
<h2 id="空格"><a class="header" href="#空格">空格</a></h2>
<p>用 <strong>双空格</strong> 缩进命名空间，方法，块或其他作用域内部的代码。例如：</p>
<pre><code class="language-crystal">module Scorecard
  class Parser
    def parse(score_text)
      begin
        score_text.scan(SCORE_PATTERN) do |match|
          handle_match(match)
        end
      rescue err : ParseError
        # 处理错误 ...
      end
    end
  end
end
</code></pre>
<p>类内，用<strong>一行</strong>分隔方法定义，常量，和内部类定义。比如：</p>
<pre><code class="language-crystal">module Money
  CURRENCIES = {
    &quot;EUR&quot; =&gt; 1.0,
    &quot;ARS&quot; =&gt; 10.55,
    &quot;USD&quot; =&gt; 1.12,
    &quot;JPY&quot; =&gt; 134.15,
  }

  class Amount
    getter :currency, :value

    def initialize(@currency, @value)
    end
  end

  class CurrencyConversion
    def initialize(@amount, @target_currency)
    end

    def amount
      # 完成转换 ...
    end
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码注释"><a class="header" href="#代码注释">代码注释</a></h1>
<p>Crystal 文档注释使用<a href="https://daringfireball.net/projects/markdown/">Markdown</a>的子集。</p>
<ul>
<li>文档应当放在类，模块，方法的正上方，中间不留空格。</li>
</ul>
<pre><code class="language-crystal"># 独角兽是一种 **传奇生物** (见 `Legendary`模块) 
# 古籍中记载它们额头长有大而尖的角。
class Unicorn
end

# 不好: 这没有附加到任何类之上。

class Legendary
end
</code></pre>
<ul>
<li>
<p>方法的文档应当包含方法概述和方法细节两部分。概述只包含第一行，后者包含整个文档注释。推荐的写法是：</p>
<ol>
<li>第一行解释方法的意图和功能。</li>
<li>后接它的细节和用处。</li>
</ol>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-crystal"># 返回独角兽角的数量。
#
# ```
# Unicorn.new.horns # =&gt; 1
# ```
def horns
  @horns
end
</code></pre>
<ul>
<li>使用第三人称: <code>Returns the number of horns this unicorn has</code> instead of <code>Return the number of horns this unicorn has</code>。</li>
</ul>
<blockquote>
<p>译注： 汉语没有第三人称相关的变格法，不过我们仍应当用客观的视角描述对象。我们说<code>返回独角兽角的数量</code>就可以了。</p>
</blockquote>
<ul>
<li>参数应当为 <em>斜体</em> (用单星号 <code>*</code> 或下划线 <code>_</code>包围)：</li>
</ul>
<pre><code class="language-crystal"># 创建独角兽，用 *horns* 指定角的数量。
def initialize(@horns = 1)
  raise &quot;Not a unicorn&quot; if @horns != 1
end
</code></pre>
<ul>
<li>Crystal 代码块应当用三个反引号<code>```</code> 包括，或是用四空格缩进。</li>
</ul>
<pre><code class="language-crystal"># ```
# unicorn = Unicorn.new
# unicorn.speak
# ```
</code></pre>
<p>或</p>
<pre><code class="language-crystal">#     unicorn = Unicorn.new
#     unicorn.speak
</code></pre>
<ul>
<li>文本块必须用三反引号包括，后接&quot;text&quot;关键字。这可以用于展示程序输出。</li>
</ul>
<pre><code class="language-crystal"># ```text
# &quot;I'm a unicorn&quot;
# ```
</code></pre>
<ul>
<li>用单反引号包含其他类型，可以自动引用到该类型。</li>
</ul>
<pre><code class="language-crystal"># `Legendary` 模块
</code></pre>
<ul>
<li>
<p>用井号接方法名来自动链接到当前类型的方法，并用单反引号包括起来。如 <code>#horns</code> 或 <code>#index(char)</code>。</p>
</li>
<li>
<p>用 <code>OtherType#method(arg1, arg2)</code> 或 <code>OtherType#method</code>的写法来自动链接到其他类型的方法，同样地，用单反引号包括起来。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-crystal"># 用 `#horns`检查角的数量
# 用 `Unicorn#speak`显示独角兽会说什么。
</code></pre>
<ul>
<li>用 <code># =&gt;</code>指示代码框中表达式的值。</li>
</ul>
<pre><code class="language-crystal">1 + 2             # =&gt; 3
Unicorn.new.speak # =&gt; &quot;I'm a unicorn&quot;
</code></pre>
<ul>
<li>用 <code>ditto</code> 表示和上一个注释相同的内容。</li>
</ul>
<pre><code class="language-crystal"># ditto
def number_of_horns
  horns
end
</code></pre>
<ul>
<li>用 <code>:nodoc:</code> 隐藏它的文档。私有和保护变量总是被隐藏。</li>
</ul>
<pre><code class="language-crystal">class Unicorn
  # :nodoc:
  class Helper
  end
end
</code></pre>
<h3 id="给类模块方法做标志"><a class="header" href="#给类模块方法做标志">给类，模块，方法做标志</a></h3>
<p>给出一个有效的关键字， Crystal 就会自动的创建可视化标签，以帮助显示问题和特殊事件。</p>
<p>目前支持的标志有：</p>
<ul>
<li>BUG</li>
<li>DEPRECATED</li>
<li>FIXME</li>
<li>NOTE</li>
<li>OPTIMIZE</li>
<li>TODO</li>
</ul>
<p>标志关键字必须是它们所在行的第一个词，且必须为全大写。为增强可读性，后面可以接一个冒号。</p>
<pre><code class="language-crystal"># 让独角兽向 STDOUT 讲话
#
# NOTE: 虽然独角兽平时不说话，但这只是特殊的。
# TODO: 检查它是否在睡觉。如果它不能说话，就抛出异常。
# TODO: 造另外一个 `speak`方法，接受并打印一个字符串。
def speak
  puts &quot;I'm a unicorn&quot;
end

# 让独角兽对 STDOUT 讲话
#
# DEPRECATED: 请改用 `speak`
def talk
  puts &quot;I'm a unicorn&quot;
end
</code></pre>
<h3 id="使用-crystal-的代码格式化器"><a class="header" href="#使用-crystal-的代码格式化器">使用 Crystal 的代码格式化器</a></h3>
<p>Crystal 有内置的格式化器，它不只能格式化你自己的代码，还能格式化文档代码块中的代码样例。</p>
<p>这会在 <code>crystal tool format</code>被调用的时候自动执行。它默认会格式化当前文件夹里所有的 <code>.cr</code> 文档。</p>
<p>格式化单个文档：</p>
<pre><code>$ crystal tool format file.cr
</code></pre>
<p>格式化某个目录下的 <code>.cr</code> 文档：</p>
<pre><code>$ crystal tool format src/
</code></pre>
<p>用这个工具可以同一代码风格，也可以给Crystal自己的库函数补充文档。</p>
<p>这个格式化器相当快，所以一次格式化一整个项目也不费多少时间。</p>
<h3 id="完整的例子"><a class="header" href="#完整的例子">完整的例子</a></h3>
<pre><code class="language-crystal"># 独角兽是一种 **传奇生物** (见 `Legendary`模块) 
# 古籍中记载它们额头长有大而尖的角。
#
# 创建一只独角兽:
#
# ```
# unicorn = Unicorn.new
# unicorn.speak
# ```
#
# 上式会产生:
#
# ```text
# &quot;I'm a unicorn&quot;
# ```
#
# 用 `#horns`检查它角的数量。
class Unicorn
  include Legendary

  # 创建独角兽，用 *horns*指定角的数量
  def initialize(@horns = 1)
    raise &quot;Not a unicorn&quot; if @horns != 1
  end

  # 返回独角兽角的数量
  #
  # ```
  # Unicorn.new.horns # =&gt; 1
  # ```
  def horns
    @horns
  end

  # ditto
  def number_of_horns
    horns
  end

  # 让独角兽对 STDOUT 说话
  def speak
    puts &quot;I'm a unicorn&quot;
  end

  # :nodoc:
  class Helper
  end
end
</code></pre>
<h3 id="创建文档"><a class="header" href="#创建文档">创建文档</a></h3>
<p>为了给某个项目创建文档，只需要调用 <code>crystal docs</code>。这会在 <code>docs</code>目录创建一个静态网页形式的文档，以 <code>docs/index.html</code>作为入口点。所有 <code>src</code>目录下的代码都会被考虑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库"><a class="header" href="#数据库">数据库</a></h1>
<p>要访问一个关系数据库，你需要一个用于访问目标数据库的shard。 <a href="https://github.com/crystal-lang/crystal-db">crystal-lang/crystal-db</a> 包为不同的驱动提供了统一的API。</p>
<p>下列包与 crystal-db 兼容：</p>
<ul>
<li><a href="https://github.com/crystal-lang/crystal-sqlite3">crystal-lang/crystal-sqlite3</a> 用于 sqlite</li>
<li><a href="https://github.com/crystal-lang/crystal-mysql">crystal-lang/crystal-mysql</a> 用于 mysql &amp; mariadb</li>
<li><a href="https://github.com/will/crystal-pg">will/crystal-pg</a> 用于 postgres</li>
</ul>
<p>这份指导展示了 crystal-db 的api。鉴于postgres, mysql 与 sqlite 各不相同，同样的SQL命令需要数据库驱动以合适的方式阐述。</p>
<p>一些驱动还有额外的功能，例如 postgres 的 <code>LISTEN</code>/<code>NOTIFY</code>。</p>
<h2 id="安装shard"><a class="header" href="#安装shard">安装shard</a></h2>
<p>从上面选择合适的驱动，把它像普通shard一样加进你应用的 <code>shard.yml</code>。</p>
<p>不必显式依赖<code>crystal-lang/crystal-db</code>。</p>
<p>这份指南将以 <code>crystal-lang/crystal-mysql</code>为例进行展示。</p>
<pre><code class="language-yaml">dependencies:
  mysql:
    github: crystal-lang/crystal-mysql
</code></pre>
<h2 id="打开数据库"><a class="header" href="#打开数据库">打开数据库</a></h2>
<p><code>DB.open</code> 允许你通过目标uri来简便地连接数据库。uri 的样式决定了所期待的驱动。这个例子连接到本地的 mysql 数据库，以root用户的身份，密码为空。</p>
<pre><code class="language-crystal">require &quot;db&quot;
require &quot;mysql&quot;

DB.open &quot;mysql://root@localhost/test&quot; do |db|
  # ... 用 db 进行查询
end
</code></pre>
<p>其他的连接uri如：</p>
<ul>
<li><code>sqlite3:///path/to/data.db</code></li>
<li><code>mysql://user:password@server:port/database</code></li>
<li><code>postgres://server:port/database</code></li>
</ul>
<p>你还可以选用非 yield 版的 <code>DB.open</code>，只要你最后调用 <code>Database#close</code> 来关闭数据库。</p>
<pre><code class="language-crystal">require &quot;db&quot;
require &quot;mysql&quot;

db = DB.open &quot;mysql://root@localhost/test&quot;
begin
  # ... 用 db 进行查询
ensure
  db.close
end
</code></pre>
<h2 id="exec"><a class="header" href="#exec">Exec</a></h2>
<p>用 <code>Database#exec</code> 执行 sql 命题。</p>
<pre><code class="language-crystal">db.exec &quot;create table contacts (name varchar(30), age int)&quot;
</code></pre>
<p>用括号包裹发送的数据，以避免sql注入。</p>
<pre><code class="language-crystal">db.exec &quot;insert into contacts values (?, ?)&quot;, &quot;John&quot;, 30
db.exec &quot;insert into contacts values (?, ?)&quot;, &quot;Sarah&quot;, 33
</code></pre>
<p>注：使用 pg 驱动时，用 <code>$1</code>, <code>$2</code>, 等等，而不是 <code>?</code>。</p>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<p>用<code>Database#query</code>进行查询，得到结果。参数的用法如同 <code>Database#exec</code>.</p>
<p><code>Database#query</code> 返回的是 <code>ResultSet</code> ，t它也需要被关闭。如同 <code>Database#open</code>，如果用含块的格式调用，这个 <code>ResultSet</code> 会隐式地被关闭。</p>
<pre><code class="language-crystal">db.query &quot;select name, age from contacts order by age desc&quot; do |rs|
  rs.each do
    # ... 对 ResultSet 的每一行做一些什么。
  end
end
</code></pre>
<p>从数据库读取值时，crystal无从知道数据的类型信息，你可以用你想要的类型参数<code>T</code>调用  <code>rs.read(T)</code>来获取信息。</p>
<pre><code class="language-crystal">db.query &quot;select name, age from contacts order by age desc&quot; do |rs|
  rs.each do
    name = rs.read(String)
    age = rs.read(Int32)
    puts &quot;#{name} (#{age})&quot;
    # =&gt; Sarah (33)
    # =&gt; John Doe (30)
  end
end
</code></pre>
<p>基于 <code>#query</code> 还有很多便捷的查询方法。</p>
<p>你可以一次读很多列：</p>
<pre><code class="language-crystal">name, age = rs.read(String, Int32)
</code></pre>
<p>或者一次一行：</p>
<pre><code class="language-crystal">name, age = db.query_one &quot;select name, age from contacts order by age desc limit 1&quot;, as: { String, Int32 }
</code></pre>
<p>或者读取一个标量值，而不用直接处理 ResultSet：</p>
<pre><code class="language-crystal">max_age = db.scalar &quot;select max(age) from contacts&quot;
</code></pre>
<p>所有用于执行命题的方法都在 <code>DB::QueryMethods</code>中定义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-pool"><a class="header" href="#connection-pool">Connection pool</a></h1>
<p>When a connection is established it usually means opening a TCP connection or Socket. The socket will handle one statement at a time. If a program needs to perform many queries simultaneously, or if it handles concurrent requests that aim to use a database, it will need more than one active connection.</p>
<p>Since databases are separate services from the application using them, the connections might go down, the services might be restarted, and other sort of things the program might not want to care about.</p>
<p>To address this issues usually a connection pool is a neat solution.</p>
<p>When a database is opened with <code>crystal-db</code> there is already a connection pool working. <code>DB.open</code> returns a <code>DB::Database</code> object which manages the whole connection pool and not just a single connection.</p>
<pre><code class="language-crystal">DB.open(&quot;mysql://root@localhost/test&quot;) do |db|
  # db is a DB::Database
end
</code></pre>
<p>When executing statements using <code>db.query</code>, <code>db.exec</code>, <code>db.scalar</code>, etc. the algorithm goes:</p>
<ol>
<li>Find an available connection in the pool.
<ol>
<li>Create one if needed and possible.</li>
<li>If the pool is not allowed to create a new connection, wait a for a connection to become available.
<ol>
<li>But this wait should be aborted if it takes too long.</li>
</ol>
</li>
</ol>
</li>
<li>Checkout that connection from the pool.</li>
<li>Execute the SQL command.</li>
<li>If there is no <code>DB::ResultSet</code> yielded, return the connection to the pool. Otherwise, the connection will be returned to the pool when the ResultSet is closed.</li>
<li>Return the statement result.</li>
</ol>
<p>If a connection can't be created, or if a connection loss occurs while the statement is performed the above process is repeated.</p>
<blockquote>
<p>The retry logic only happens when the statement is sent through the <code>DB::Database</code> . If it is sent through a <code>DB::Connection</code> or <code>DB::Transaction</code> no retry is performed since the code will state that certain connection object was expected to be used.</p>
</blockquote>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Default value</th></tr></thead><tbody>
<tr><td style="text-align: left">initial_pool_size</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">max_pool_size</td><td style="text-align: left">0 (unlimited)</td></tr>
<tr><td style="text-align: left">max_idle_pool_size</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">checkout_timeout</td><td style="text-align: left">5.0 (seconds)</td></tr>
<tr><td style="text-align: left">retry_attempts</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left">retry_delay</td><td style="text-align: left">1.0 (seconds)</td></tr>
</tbody></table>
</div>
<p>When <code>DB::Database</code> is opened an initial number of <code>initial_pool_size</code> connections will be created. The pool will never hold more than <code>max_pool_size</code> connections. When returning/releasing a connection to the pool it will be closed if there are already <code>max_idle_pool_size</code> idle connections.</p>
<p>If the <code>max_pool_size</code> was reached and a connection is needed, wait up to <code>checkout_timeout</code> seconds for an existing connection to become available.</p>
<p>If a connection is lost or can't be established retry at most <code>retry_attempts</code> times waiting <code>retry_delay</code> seconds between each try.</p>
<h2 id="sample"><a class="header" href="#sample">Sample</a></h2>
<p>The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions.</p>
<pre><code class="language-crystal"># file: sample.cr
require &quot;mysql&quot;

DB.open &quot;mysql://root@localhost?retry_attempts=8&amp;retry_delay=3&quot; do |db|
  loop do
    pp db.scalar(&quot;SELECT NOW()&quot;)
    sleep 0.5
  end
end
</code></pre>
<pre><code>$ crystal sample.cr
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:57
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:57
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:58
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:58
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:59
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:59
# stop mysql server for some seconds
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:06
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:06
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:07
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导引"><a class="header" href="#导引">导引</a></h1>
<p>这些导引帮助你激发Crystal的全部能力.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能-1"><a class="header" href="#性能-1">性能</a></h1>
<p>这些提示有助于你发挥程序的全部能力,不论是速度还是内存占用。</p>
<h2 id="过早优化"><a class="header" href="#过早优化">过早优化</a></h2>
<p>Donald Knuth 说过：</p>
<blockquote>
<p>我们应当放过细小的瑕疵，因为 97% 的场合中，过早优化都是万恶之源。但是也不要错过最关键的 3%。</p>
</blockquote>
<p>不过，如果你在写程序的时候就意识到两种方法是等效的，那就直接写成更好的那种。这样后来的改动就会更少。</p>
<p>同时也记得测试你的程序，以得知他的瓶颈。在Mac上， <a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Instrument-TimeProfiler.html">Instruments Time Profiler</a>是不错的测试工具，一般与 XCode 配合使用。 Linux上， 任何能测试 C/C++ 程序的工具都可以用，比如 <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> 或者 <a href="http://valgrind.org/docs/manual/cl-manual.html">Callgrind</a>。</p>
<p>记着测试程序的时候以 <code>--release</code>模式编译，这会开启优化。</p>
<h2 id="避免内存分配"><a class="header" href="#避免内存分配">避免内存分配</a></h2>
<p>最好的优化方法之一就是避免过多的、无用的内存分配。当创建 <strong>class</strong> 实例时，就会有堆上的内存被分配。而创建 <strong>struct</strong> 在栈上分配内存，这样就能避免一部分性能损失。如果你不知道堆内存和栈内存的区别， <a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">看这里</a>。</p>
<p>分配堆内存是缓慢的，也会给垃圾收集器带来更多压力，因为你每一片分配的内存总是要让垃圾收集器来收场。</p>
<p>有多种方法来避免分配内存，标准库的设计也帮助你这么做。</p>
<h3 id="写-io-时不要创建中间字符串"><a class="header" href="#写-io-时不要创建中间字符串">写 IO 时不要创建中间字符串</a></h3>
<p>你可以这样向标准输出打印数字：</p>
<pre><code>puts 123
</code></pre>
<p>在许多语言中，这会导致一个对象调用自己的 <code>to_s</code> 方法——或是什么把自己转成字符串的操作——然后向标准输出打印这个字符串。这么做可以，但是有个缺点：它在堆内存里创建了中间的字符串，并且写一遍就扔了。这白白浪费了一次内存分配，GC又有活干了。 </p>
<p>Crystal中, <code>puts</code> 会调用对象的 <code>to_s(io)</code>操作，把IO传给这个对象，让它自己决定如何输出。</p>
<p>所以，你永远不用这么做：</p>
<pre><code>puts 123.to_s
</code></pre>
<p>因为这样创建了一个中间字符串，反而增加了开销。直接让对象向IO写就完事了。</p>
<p>当输出自定义类型时，一定要重载 <code>to_s(io)</code>,而不是 <code>to_s</code>, 并且避免在这个方法里创建中间字符串。例如：</p>
<pre><code class="language-crystal">class MyClass
  # 好
  def to_s(io)
    # 向IO 中追加了 &quot;1, 2&quot; ，而不用创建中间字符串
    x = 1
    y = 2
    io &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y
  end

  # 坏
  def to_s(io)
    x = 1
    y = 2
    # 用字符串插值创建了中间字符串，这应该避免。
    io &lt;&lt; &quot;#{x}, #{y}&quot;
  end
end
</code></pre>
<p>相比创建中间字符串，这种直接向IO写的思想能得到更好的性能，你在定义自己的API时也应该这么做。</p>
<p>比较一下用时：</p>
<pre><code class="language-crystal"># io_benchmark.cr
require &quot;benchmark&quot;

io = IO::Memory.new

Benchmark.ips do |x|
  x.report(&quot;不用 to_s&quot;) do
    io &lt;&lt; 123
    io.clear
  end

  x.report(&quot;用 to_s&quot;) do
    io &lt;&lt; 123.to_s
    io.clear
  end
end
</code></pre>
<p>输出:</p>
<pre><code>$ crystal run --release io_benchmark.cr
    不用 to_s  77.11M ( 12.97ns) (± 1.05%)       fastest
      用 to_s  18.15M ( 55.09ns) (± 7.99%)  4.25× slower
</code></pre>
<p>不仅减少了用时，还减少了内存消耗。</p>
<h3 id="用字符串插值而不是拼接"><a class="header" href="#用字符串插值而不是拼接">用字符串插值，而不是拼接</a></h3>
<p>有时你要把字符串字面量和其他的值拼接起来，你不要用 <code>String#+(String)</code> ，而应该用 <a href="guides/syntax_and_semantics/literals/string.html">字符串插值</a> ，后者还能被表达式嵌到字符串里面。 <code>&quot;Hello, #{name}&quot;</code> 比 <code>&quot;Hello, &quot; +  name.to_s</code>好。</p>
<p>字符串插值会被编译器转换成 IO ，这样就不会涉及中间字符串了。上面的例子会变成： <code>(StringBuilder.new &lt;&lt; &quot;Hello, &quot; &lt;&lt; name).to_s</code>。</p>
<h3 id="创建字符串时避免io分配"><a class="header" href="#创建字符串时避免io分配">创建字符串时避免IO分配</a></h3>
<p><code>String.build</code> 对字符串有优化，所以不要另外分配 <code>IO::Memory</code>。</p>
<pre><code class="language-crystal">require &quot;benchmark&quot;

Benchmark.ips do |x|
  x.report(&quot;String.build&quot;) do
    String.build do |io|
      99.times do
        io &lt;&lt; &quot;hello world&quot;
      end
    end
  end
  x.report(&quot;IO::Memory&quot;) do
    io = IO::Memory.new
    99.times do
      io &lt;&lt; &quot;hello world&quot;
    end
    io.to_s
  end
end
</code></pre>
<p>输出：</p>
<pre><code>$ crystal run --release str_benchmark.cr
String.build 597.57k (  1.67µs) (± 5.52%)       fastest
  IO::Memory 423.82k (  2.36µs) (± 3.76%)  1.41× slower
</code></pre>
<h3 id="避免重复创建临时对象"><a class="header" href="#避免重复创建临时对象">避免重复创建临时对象</a></h3>
<p>考虑这个程序：</p>
<pre><code class="language-crystal">lines_with_language_reference = 0
while line = gets
  if [&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;].any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<p>这个程序能运行，但是有一个重大的性能问题：每次迭代时都会创建一个包含 <code>[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]</code>的数组。记住：数组字面量只不过是创建数组，把值放进去的一个语法糖。这会在每一次迭代时都发生一遍。</p>
<p>有两种方法来解决它：</p>
<ol>
<li>用元组。 如果在程序里写 <code>{&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;}</code> ，它仍然会这么运行，但是因为元组不涉及堆内存，它会快一些，编译器也有更多机会去优化程序。</li>
</ol>
<pre><code class="language-crystal">lines_with_language_reference = 0
while line = gets
  if {&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;}.any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<ol start="2">
<li>把数组拖出去，写成一个常量</li>
</ol>
<pre><code class="language-crystal">LANGS = [&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]

lines_with_language_reference = 0
while line = gets
  if LANGS.any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<p>一般推荐写元组。</p>
<p>循环中，显式的数组字面量是一种创建临时对象的方法，同样的规律也适用于方法调用。例如，<code>Hash#keys</code> 每次调用都会返回一个包含键的数组。你可以用 <code>Hash#each_key</code>, <code>Hash#has_key?</code> 或其他方法来替换它。</p>
<h3 id="尽可能用结构体"><a class="header" href="#尽可能用结构体">尽可能用结构体</a></h3>
<p>如果你把一个类型声明为 <strong>struct</strong> 而不是 <strong>class</strong>， 创建一个实例只会使用栈内存，这比对内存便宜得多，也不会增加GC压力。</p>
<p>不过你不应该总是用结构体。结构体按值传递。如果你把它传给一个方法，这个方法又修改了它，调用者不会知道有这些修改。这可能会产生bug。最好的办法是对可变对象用结构体，尤其对于细小的对象。</p>
<p>例如：</p>
<pre><code class="language-crystal"># class_vs_struct.cr
require &quot;benchmark&quot;

class PointClass
  getter x
  getter y

  def initialize(@x : Int32, @y : Int32)
  end
end

struct PointStruct
  getter x
  getter y

  def initialize(@x : Int32, @y : Int32)
  end
end

Benchmark.ips do |x|
  x.report(&quot;class&quot;) { PointClass.new(1, 2) }
  x.report(&quot;struct&quot;) { PointStruct.new(1, 2) }
end
</code></pre>
<p>Output:</p>
<pre><code>$ crystal run --release class_vs_struct.cr
 class  28.17M (± 2.86%) 15.29× slower
struct 430.82M (± 6.58%)       fastest
</code></pre>
<h2 id="字符串迭代"><a class="header" href="#字符串迭代">字符串迭代</a></h2>
<p>Crystal 的字符串包含的是以 UTF-8 格式编码的字节。 UTF-8 是变长编码：尽管ASCII字符都是一个字节的， 另一些字符(比如汉字)可能会占据多个字节。因此，用 <code>String#[]</code> 索引字符串不是 <code>O(1)</code> 操作，因为找到对应位置的字符总是要把之前的字符都解码一遍。虽然 Crystal的 <code>String</code> 做了一些优化：如果他知道每个字符都是 ASCII的，那么 <code>String#[]</code> 就可以以 <code>O(1)</code>实现。然而，这不总是成立。</p>
<p>印制，这样遍历一个字符串不是优化的。相反，它有 <code>O(n^2)</code>复杂度：</p>
<pre><code class="language-crystal">string = ...
while i &lt; string.size
  char = string[i]
  # ...
end
</code></pre>
<p>上面的写法还有一个问题：计算String的 <code>size</code> 也是很慢的，因为它不是字符串中字节的数量(<code>bytesize</code>)。不过，只要它被计算过一次，它就会被缓存起来。</p>
<p>要提升性能,要么用迭代方法 (<code>each_char</code>, <code>each_byte</code>, <code>each_codepoint</code>), 要么用更底层的 <code>Char::Reader</code>结构体。例如，用 <code>each_char</code>：</p>
<pre><code class="language-crystal">string = ...
string.each_char do |char|
  # ...
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发"><a class="header" href="#并发">并发</a></h1>
<h2 id="并发-vs-并行"><a class="header" href="#并发-vs-并行">并发 vs. 并行</a></h2>
<p>“并发”和“并行”的定义有时会混杂起来，但根本上来说它们不一样。</p>
<p>一个并发系统是可以做多个任务的系统，至于是否真的在同时执行尚在其次。你可以想象你在厨房做饭：你切洋葱，把它扔进锅里炸，炸的同时你又在切西红柿。如此种种时你没有同时做所有事情，你只是把时间分配到不同的任务上。至于并行，就是你一只手在炸洋葱，另一只手又在切西红柿。</p>
<p>此文写成之时， Crystal仍没有支持并行。只是支持并发。多个任务都能执行，每个都能分配到一些时间，但是两个任务绝不会同时执行。</p>
<blockquote>
<p>译注: 1.5版本(2022年)的crystal文档中没有说明多线程并行，然而相关代码在2019年已经<a href="https://github.com/crystal-lang/crystal/pull/8112">合并</a>到crystal的主分支</p>
</blockquote>
<p>一个 Crystal 程序运行在一个操作系统线程上,只有&quot;标记——清扫&quot;型垃圾收集器是并行的(目前是 <a href="http://www.hboehm.info/gc/">Boehm GC</a>)。</p>
<h3 id="纤程fibers"><a class="header" href="#纤程fibers">纤程(Fibers)</a></h3>
<p>为了实现并发， Crystal 添加了纤程 (fibers)。一个 纤程类似于操作系统线程,但是更加轻量，并且由进程内部管理。因此一个程序可以启动多个纤程，并且Crystal会保证在合适的时候执行它们。</p>
<h3 id="事件循环"><a class="header" href="#事件循环">事件循环</a></h3>
<p>每个有关 I/O 的对象都配有一个事件循环。有些耗时的操作会被委派给它们, 当事件循环等待这个操作执行时，程序可以执行其他的纤程。一个简单的例子是等待从 socket中传来的数据。</p>
<h3 id="管道channels"><a class="header" href="#管道channels">管道(Channels)</a></h3>
<p>Crystal有受<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>启发而得的管道 (Channels)。它们可以在纤程间传递信息而不用手动传递内存，因此编程时也不用担心锁，信号量等结构和问题。</p>
<blockquote>
<p>译注: 原文不便访问，<a href="https://zhuanlan.zhihu.com/p/455843256">这篇文档</a>讲了Actor和CSP两种并发模型。</p>
</blockquote>
<h2 id="一个程序的执行流程"><a class="header" href="#一个程序的执行流程">一个程序的执行流程</a></h2>
<p>当一个程序启动时，他会启动在你顶层代码执行的主纤程。一个纤程可以启动其他纤程。程序大概由这几部分组成：</p>
<ul>
<li>运行时调度器：在合适的时间执行所有纤程</li>
<li>事件循环：它也是另一个纤程，用来管理异步任务，例如文件，socket，管道(pipes)，信号量和计时器(比如执行 <code>sleep</code>)。</li>
<li>管道：用以在纤程间传递数据。运行时调度器会协调纤程和管道之间的通讯。</li>
<li>垃圾收集器: 清理 &quot;不再有用&quot;的内存。</li>
</ul>
<h3 id="纤程fiber"><a class="header" href="#纤程fiber">纤程fiber)</a></h3>
<p>纤程(fiber)是程序执行的单元，但是比线程更轻量。它就是一个关联到一个of 8MB  <a href="https://en.wikipedia.org/wiki/Call_stack">栈</a> 的小对象, 而栈则被分配给一个操作系统线程。</p>
<p>纤程是协作式的，这一点与线程不同。线程是抢占式的：操作系统可能在任何时候打断一个线程其执行另一个。一个纤程必须显式地通知调度器去执行其他纤程。举个例子，如果一个纤程要等待 I/O 操作， 它会告诉调度器： “看，我要等这个 I/O 操作可用，你先执行其他纤程，等这个 I/O 好的时候再叫我。”</p>
<p>协作式执行的好处是：这避免了切换上下文(切换纤程时所必须)的一大堆开销。</p>
<p>纤程比一线程轻量之处在于：即使它被分配了 8MB的栈空间，他一开始也只是一个 4KB的小栈。</p>
<p>在 64位机器上我们可以启动不计其数的纤程，而在32位机上我们最多启动 512个纤程。不过32位机现在已经濒临过时，我们以后就只注重64位机。</p>
<h3 id="运行时调度器"><a class="header" href="#运行时调度器">运行时调度器</a></h3>
<p>调度区用一个队列容纳：</p>
<ul>
<li>就绪的纤程：比如你启动一个纤程时，他就是就绪的，可以执行。</li>
<li>事件循环： 其实也是纤程. 当没有其他可执行的纤程时事件循环会检查有没有异步操作完成，如果有，就执行依赖于它的纤程。事件循环目前是由 <code>libevent</code>实现，它是<code>epoll</code> 或 <code>kqueue</code>等机制的抽象。</li>
<li>自发要求等待的纤程：这可以由 <code>Fiber.yield</code>指定，意思是 “我本可以继续执行，但是我给你机会去执行其他的纤程。”</li>
</ul>
<h3 id="数据交流"><a class="header" href="#数据交流">数据交流</a></h3>
<p>因为现在只有一个事实的线程在执行程序，多个纤程获取和更改同一个类变量暂时没有问题。但是一旦语言中实现了多线程 (并行) 它就可能有隐患。因此不要这样传递数据，而是建立管道，通过管道发送消息。在内部，一个管道实现了加锁机制以避免数据竞争，然而在外部，你把它当做交流的基本方式。这样你(用户)就不必手动加锁。</p>
<h2 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h2>
<h3 id="生成一个纤程"><a class="header" href="#生成一个纤程">生成一个纤程</a></h3>
<p>用 <code>spawn</code> 加一个块来生成纤程：</p>
<pre><code class="language-crystal">spawn do
  # ...
  socket.gets
  # ...
end

spawn do
  # ...
  sleep 5.seconds
  #  ...
end
</code></pre>
<p>现在我们有了两个纤程：一个从socket中读取消息，另一个只是做 <code>sleep</code>。当第一个纤程到达 <code>socket.gets</code> 一行，它就会被挂起，事件循环会记得在socket有消息后执行这个纤程。然后程序会执行第二个纤程。这个纤程想要睡5秒，因此事件循环会记得在5秒后执行这个纤程。如果此时没有其他纤程可执行，事件循环会等到这些事件发生，而不用占用CPU时间。</p>
<p><code>socket.gets</code> 和 <code>sleep</code> 表现如此的原因是它们的实现直接面对运行时调度器，这不是什么玄学。只是标准库往往已经包揽了这些工作，你不用手动做而已。</p>
<p>然而注意，纤程不会在创建时立刻执行。例如：</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end
</code></pre>
<p>运行这些代码，程序就会利己退出，什么输出也不会有。</p>
<p>这是因为纤程并不会在创建时立即执行。因此，主纤程创建了这个纤程，自己执行，然后整个程序就退了出。</p>
<p>一个解决方案是加 <code>sleep</code>：</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

sleep 1.second
</code></pre>
<p>这个程序会在一秒内持续打印打印 &quot;Hello!&quot;，然后退出。这是因为 <code>sleep</code>会让主纤程等到一秒后才被执行，这时程序会执行另一个就绪的纤程，即上面一直打 &quot;Hello!&quot;的那个。</p>
<p>另一种方法是：</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

Fiber.yield
</code></pre>
<p>这次 <code>Fiber.yield</code> 会告诉调度器去执行其他纤程。这会打印 &quot;Hello!&quot; 直到标准输出阻塞 (系统调用会告诉我们等到标准输出可用的时候)，然后主纤程恢复执行，程序退出。这里标准输出<em>也许</em> 不会阻塞，于是程序就会一直执行下去。</p>
<p>如果我们想要永远执行一个所创建的纤程，我们可以使用不加参数的 <code>sleep</code>：</p>
<blockquote>
<p>译注 : 永眠 ()</p>
</blockquote>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

sleep
</code></pre>
<p>当然这个程序根本用不着 <code>spawn</code>，直接写循环就行了。 <code>sleep</code> 在创建多个纤程时更有用。</p>
<h3 id="生成方法调用"><a class="header" href="#生成方法调用">生成方法调用</a></h3>
<p>你也可以生成一个纤程去调用方法，而不是执行块。你可以看这个例子来明白它的用处：</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  spawn do
    puts(i)
  end
  i += 1
end

Fiber.yield
</code></pre>
<p>上面的程序会打印 &quot;10&quot; 十次。问题在于所有创建的纤程都指向同一个变量 <code>i</code> ，当 <code>Fiber.yield</code>执行时，它的值是 10。</p>
<p>解决方法是：</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  proc = -&gt;(x : Int32) do
    spawn do
      puts(x)
    end
  end
  proc.call(i)
  i += 1
end

Fiber.yield
</code></pre>
<p>现在它正常的打印了。因为我们创建了 <a href="http://crystal-lang.org/api/Proc.html">闭包</a> 来捕获 <code>i</code>，然后调用它，所以这个值被复制了，被创建的纤程得到的是原数的备份。</p>
<p>为了避免写样板代码，标准库提供了 <code>spawn</code> 宏。它接受一个调用表达式，然后把它重写成上面的样子。使用它，我们得到了：</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  spawn puts(i)
  i += 1
end

Fiber.yield
</code></pre>
<p>这在局部变量碎迭代更改时非常有用。这不会用于块参数。例如，这个程序也能正常输出：</p>
<pre><code class="language-crystal">10.times do |i|
  spawn do
    puts i
  end
end

Fiber.yield
</code></pre>
<h3 id="生成一个纤程等待它完成"><a class="header" href="#生成一个纤程等待它完成">生成一个纤程，等待它完成</a></h3>
<p>为此我们可以使用管道：</p>
<pre><code class="language-crystal">channel = Channel(Nil).new

spawn do
  puts &quot;Before send&quot;
  channel.send(nil)
  puts &quot;After send&quot;
end

puts &quot;Before receive&quot;
channel.receive
puts &quot;After receive&quot;
</code></pre>
<p>This prints:</p>
<pre><code class="language-text">Before receive
Before send
After receive
</code></pre>
<p>首先程序创建了一个纤程，但不立刻执行它。当我们调用 <code>channel.receive</code>时，主纤程阻塞，这个被创建的纤程开始执行。然后 <code>channel.send(nil)</code> 被调用，继而 <code>channel.receive</code>被执行，他等待的值终于来了。然后主纤程继续执行，直到结束，随后程序退出，其他纤程来不及机会打印&quot;After send&quot;就被清理了。</p>
<p>上例中我们使用 <code>nil</code>只是为了告诉他人纤程的结束。我们也可以用管道在纤程之间传值：</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

spawn do
  puts &quot;Before first send&quot;
  channel.send(1)
  puts &quot;Before second send&quot;
  channel.send(2)
end

puts &quot;Before first receive&quot;
value = channel.receive
puts value # =&gt; 1

puts &quot;Before second receive&quot;
value = channel.receive
puts value # =&gt; 2
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Before first receive
Before first send
1
Before second receive
Before second send
2
</code></pre>
<p>注意当程序执行一个 <code>receive</code>时，纤程阻塞，另一个纤程执行。当执行 <code>send</code>时，控制流回到等待这个值的纤程。</p>
<p>这里我们在发送字面量，但是被创建的纤程可以用多种方式得到这个值。比如读一个文档，或是等待来自socket的消息。 当这个纤程必须等待 I/O时，其他的纤程可以趁这个机会执行，直到 I/O 完成。然后这个值终于通过管道传给了主纤程。例如：</p>
<pre><code class="language-crystal">require &quot;socket&quot;

channel = Channel(String).new

spawn do
  server = TCPServer.new(&quot;0.0.0.0&quot;, 8080)
  socket = server.accept
  while line = socket.gets
    channel.send(line)
  end
end

spawn do
  while line = gets
    channel.send(line)
  end
end

3.times do
  puts channel.receive
end
</code></pre>
<p>上述程序创建了两个纤程。第一个创建了 TCPServer，等待一个连接，并且从中按行读取文本，把它们发给管道。第二个纤程从标准输入按行读取文本，主纤程从管道读取前三条消息息——而不管它从标准输入还是TCP服务器——然后程序退出 。 <code>gets</code>会阻塞纤程，告诉调度器有消息来了再启动它。</p>
<p>类似地我们可以等待多个纤程去完成执行，然后获取它们的值：</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

10.times do |i|
  spawn do
    channel.send(i * 2)
  end
end

sum = 0
10.times do
  sum += channel.receive
end
puts sum # =&gt; 90
</code></pre>
<p>当然，你可以在创建的纤程内使用 <code>receive</code>：</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

spawn do
  puts &quot;Before send&quot;
  channel.send(1)
  puts &quot;After send&quot;
end

spawn do
  puts &quot;Before receive&quot;
  puts channel.receive
  puts &quot;After receive&quot;
end

puts &quot;Before yield&quot;
Fiber.yield
puts &quot;After yield&quot;
</code></pre>
<p>输出:</p>
<pre><code class="language-text">Before yield
Before send
Before receive
1
After receive
After send
After yield
</code></pre>
<p>此处 <code>channel.send</code> 先执行，但是因为目前没有纤程想要这个值，它就先挂起该纤程，等其他纤程执行。后来第二个纤程执行。它从管道中取值的时候，里面正好有一个值。于是它获得这个值，继续执行。接下来先执行第一个纤程，然后是主纤程，因为 <code>Fiber.yield</code> 把一个纤程放在执行队列的最后面。</p>
<h3 id="缓存管道"><a class="header" href="#缓存管道">缓存管道</a></h3>
<p>上例中我们用的是无缓存的管道：当发送值时，如果一个纤程在等待这个值，那控制流就会转到那个纤程上。</p>
<p>通过使用带缓存的管道时，调用 <code>send</code> 不会利己跳到另外的纤程，除非缓存区已满：</p>
<pre><code class="language-crystal"># 容量为 2 的缓存管道
channel = Channel(Int32).new(2)

spawn do
  puts &quot;Before send 1&quot;
  channel.send(1)
  puts &quot;Before send 2&quot;
  channel.send(2)
  puts &quot;Before send 3&quot;
  channel.send(3)
  puts &quot;After send&quot;
end

3.times do |i|
  puts channel.receive
end
</code></pre>
<p>输出：</p>
<pre><code>Before send 1
Before send 2
Before send 3
1
2
After send
3
</code></pre>
<p>注意前两次发送执行时，控制流没有跑到其他纤程上，然而，在第三次发送时，管道的缓存已经满了，所以控制流回到了主纤程。主纤程收到两个值之后，管道又空了，所以第三次执行<code>receive</code>时，主纤程阻塞，控制流回到上面的纤程，它发送信息，然后结束。然后主纤程又去做接下来的事情。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试crystal代码"><a class="header" href="#测试crystal代码">测试Crystal代码</a></h1>
<p>Crystal 的 <a href="https://crystal-lang.org/api/latest/Spec.html"><code>Spec</code>模块</a>自带一个功能完全的测试库。它提供了描述代码如何运行的语法结构。</p>
<p>启发于 <a href="http://rspec.info/">Rspec</a>，它包含一种领域特定语言 (DSL)来用类似于英语的方法来描述测试用例。</p>
<p>一个最基本的样例长这样：</p>
<pre><code class="language-crystal">require &quot;spec&quot;

describe Array do
  describe &quot;#size&quot; do
    it &quot;正确表示数组中元素的数目&quot; do
      [1, 2, 3].size.should eq 3
    end
  end

  describe &quot;#empty?&quot; do
    it &quot;当数组中没有元素时为真&quot; do
      ([] of Int32).empty?.should be_true
    end

    it &quot;当数组中有元素时为假&quot; do
      [1].empty?.should be_false
    end
  end
end
</code></pre>
<h2 id="剖析测试文件"><a class="header" href="#剖析测试文件">剖析测试文件</a></h2>
<p>为了使用 spec 模块和 DSL，你需要在测试文件中加入 <code>require &quot;spec&quot;</code> 。许多项目都有一个自定义的 <a href="guides/testing.html#spec-helper">spec helper</a>来组织这些包含文件。</p>
<p>具体的测试内容在 <code>it</code>块从定义。一个可选的(但强烈建议写) 描述字符串表示它的目的，后面接一个块，包含测试的基本逻辑。</p>
<p>已经定义或预订，但是还没有保证能工作的情形可以以 <code>pending</code>定义，而不必是 <code>it</code>。 它们不会被运行，但是会在测试报告中以“待实现”的形式表示出来。</p>
<p><code>it</code> 块包含一段代码。运行它，然后指定期望的结果。每个例子可以指定多个期待，但是最好每个块测试一种特定的行为。</p>
<p>当 <code>spec</code>被包含时, 每个对象都会含有实例方法 <code>#should</code>和 <code>#should_not</code>。这些方法被所期待的元素调用。如果期待满足，代码就会继续运行；否则这个测试宣告失败，这个块中后续的代码就不再会运行。</p>
<p>在测试文件中，样例以样例组的格式整理起来。每组样例以 <code>describe</code>或 <code>context</code>开头。 基本上，一个顶层 <code>describe</code>定义一个外部单元(such 比如一个类)的行为。 <code>describe</code> 可以更深入地嵌套起来，以指定一个更小单元的行为 (比如一个实例方法)。</p>
<p>单元测试中有个被一直遵守的传统：外部 <code>describe</code>是指定类，内部 <code>describe</code>指定方法。实例方法以 <code>#</code>开头, 类方法以 <code>.</code>开头。</p>
<p>为了建立特定的情景——比如 <em>空数组</em> 对于 <em>有元素的数组</em>—— <code>context</code>方法有助于向读者解释这一点。他和 <code>describe</code>名字不一样，但是行为一样。</p>
<p><code>describe</code> 和 <code>context</code> 用一个元素做描述(往往是一个字符串) ，后带一个块，包含样例或是嵌套的样例组。</p>
<h2 id="期望"><a class="header" href="#期望">期望</a></h2>
<p>期待为测试的值设下规范，看测试值是不是<em>真的</em>符合预期。</p>
<h3 id="等价同一类型匹配"><a class="header" href="#等价同一类型匹配">等价，同一，类型匹配</a></h3>
<p>这些方法用于创建等价 (<code>eq</code>), 同一 (<code>be</code>), 类型匹配 (<code>be_a</code>), 空 (<code>be_nil</code>)方面的期望。</p>
<p>注意，判断同一性用的是 <code>.same?</code> 方法，它判断两个对象的 <a href="https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method"><code>#object_id</code></a> 是否是一样的。这仅当两个引用指向的是 <em>同一个对象</em> ，而非 <em>等价的两个对象</em>时，才会成立. 这仅能检查引用类型的对象，不能检查值类型的对象，比如结构体或数字。</p>
<pre><code class="language-crystal">actual.should eq(expected)    # 当 actual == expected     时匹配
actual.should be(expected)    # 当 actual.same?(expected) 时匹配
actual.should be_a(expected)  # 当 actual.is_a?(expected) 时匹配
actual.should be_nil          # 当 actual.nil?            时匹配
</code></pre>
<h3 id="真性"><a class="header" href="#真性">真性</a></h3>
<pre><code class="language-crystal">actual.should be_true         # 当 actual == true   时匹配
actual.should be_false        # 当 actual == false  时匹配
actual.should be_truthy       # 当 actual 是真的     时匹配 (不是 nil, false, 或 Pointer.null)
actual.should be_falsey       # 当 actual 是假的     时匹配 (nil, false 或 Pointer.null)
</code></pre>
<h3 id="比较"><a class="header" href="#比较">比较</a></h3>
<pre><code class="language-crystal">actual.should be &lt;  expected  # 当 actual &lt;  expected 时匹配
actual.should be &lt;= expected  # 当 actual &lt;= expected 时匹配
actual.should be &gt;  expected  # 当 actual &gt;  expected 时匹配
actual.should be &gt;= expected  # 当 actual &gt;= expected 时匹配
</code></pre>
<h3 id="其他的匹配方式"><a class="header" href="#其他的匹配方式">其他的匹配方式</a></h3>
<pre><code class="language-crystal">actual.should be_close(expected, delta) # 当 actual 在 expected 的 delta 邻域内 时匹配:
                                        #   即 (actual - expected).abs &lt;= delta
actual.should contain(expected)         # 当 actual.includes?(expected)   时匹配
actual.should match(expected)           # 当 actual =~ expected           时匹配
</code></pre>
<h3 id="期待错误"><a class="header" href="#期待错误">期待错误</a></h3>
<p>这些标志声明的块当抛出特定异常时匹配。</p>
<pre><code class="language-crystal">expect_raises(MyError) do
  # 当块抛出 MyError 类型的异常时匹配。
end

expect_raises(MyError, &quot;error message&quot;) do
  # 要求块抛出 MyError 类型的异常
  # 并且错误内容包含 &quot;error message&quot;
end

expect_raises(MyError, /error \w{7}/) do
  # 要求块抛出 MyError 类型的异常
  # 并且错误内容匹配于这个表达式
end
</code></pre>
<p>它们返回那个被挽救的异常，以用于后续的其他期许，如指定这个异常的属性等。</p>
<h2 id="运行测试"><a class="header" href="#运行测试">运行测试</a></h2>
<p>Crystal 编译器有一个 <code>spec</code> 命令来运行测试，同时指定测试范围，裁剪输出格式。 <code>crystal spec</code> 会编译运行项目内的所有测试文件。</p>
<p>传统上，测试文件在项目的 <code>spec/</code> 目录。测试文件必须以 <code>_spec.cr</code> 结尾，来让编译器认识到。</p>
<p>你可以从目录树，单独的文件，文件的某一行来指定测试的范围。</p>
<pre><code class="language-bash"># 运行匹配于 spec/**/*_spec.cr 的所有文件
crystal spec

# 运行匹配于 spec/my/test/**/*_spec.cr 的所有文件
crystal spec spec/my/test/

# 运行 spec/my/test/file_spec.cr 内的所有测试
crystal spec spec/my/test/file_spec.cr

# 运行 spec/my/test/file_spec.cr 于 14 行定义的一组测试
crystal spec spec/my/test/file_spec.cr:14
</code></pre>
<p>如果指定的行号是 <code>describe</code>或 <code>context</code>分区的开头，里面的所有测试例子都会被检验。</p>
<p>基础的格式化器会输出失败样例的文件位置和行号，以便于重试这个错误的例子。</p>
<h2 id="测试辅助文件"><a class="header" href="#测试辅助文件">测试辅助文件</a></h2>
<p>许多项目都包含一个测试辅助文件，通常叫 <code>spec/spec_helper.cr</code>。</p>
<p>这个文件常用于包含<code>spec</code> 和其他项目中所需的包含文件。这里也适合定义测试用全局变量和方法，以简化测试过程，减少代码重复。 </p>
<pre><code class="language-crystal"># spec/spec_helper.cr
require &quot;spec&quot;
require &quot;../src/my_project.cr&quot;

def create_test_object(name)
  project = MyProject.new(option: false)
  object = project.create_object(name)
  object
end

# spec/my_project_spec.cr
require &quot;./spec_helper&quot;

describe &quot;MyProject::Object&quot; do
  it &quot;被创建&quot; do
    object = create_test_object(name)
    object.should_not be_nil
  end
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写-shard"><a class="header" href="#编写-shard">编写 Shard</a></h1>
<p>这篇文章讲述了如何编写 Crystal Shard。</p>
<h2 id="什么是-shard"><a class="header" href="#什么是-shard"><em>什么是 Shard?</em></a></h2>
<p>简单来说， Shard 是 Crystal 代码包， 用于共享给其他项目使用。</p>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>这篇教程中，我们会制作一个叫 <em>palindrome-example</em> 的代码库.</p>
<blockquote>
<p>给不认识它的人：回文(palindrome)是一种从前到后和从后到前读都一样的词。例如： racecar, kayak, madam，“信言不美，美言不信”，“落花闲院春衫薄，薄衫春院闲花落”</p>
</blockquote>
<h3 id="要求"><a class="header" href="#要求">要求</a></h3>
<p>为了按照教程发布一个 Crystal Shard，你需要这些东西：</p>
<ul>
<li>一个可用的 <a href="guides/../using_the_compiler/README.html">Crystal 编译器</a></li>
<li>一个可用的 <a href="https://git-scm.com">Git</a></li>
<li>一个 <a href="https://github.com">GitHub</a> 账户</li>
</ul>
<h3 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h3>
<p>用<a href="guides/../using_the_compiler/README.html">Crystal 编译器</a>的 <code>init lib</code> 命令，以标准目录结构创建Crystal库.</p>
<p>在终端中输入： <code>crystal init lib &lt;YOUR-SHARD-NAME&gt;</code></p>
<p>例如：</p>
<pre><code class="language-bash"> $  crystal init lib palindrome-example
      create  palindrome-example/.gitignore
      create  palindrome-example/.editorconfig
      create  palindrome-example/LICENSE
      create  palindrome-example/README.md
      create  palindrome-example/.travis.yml
      create  palindrome-example/shard.yml
      create  palindrome-example/src/palindrome-example.cr
      create  palindrome-example/src/palindrome-example/version.cr
      create  palindrome-example/spec/spec_helper.cr
      create  palindrome-example/spec/palindrome-example_spec.cr
Initialized empty Git repository in /&lt;YOUR-DIRECTORY&gt;/.../palindrome-example/.git/
</code></pre>
<p>...然后 <code>cd</code> 进这个目录：</p>
<p>如：</p>
<pre><code class="language-bash">cd palindrome-example
</code></pre>
<p>然后用 <code>add</code> &amp; <code>commit</code> 把文件加入进Git档案：</p>
<pre><code class="language-bash"> $  git add -A
 $  git commit -am &quot;First Commit&quot;
[master (root-commit) 77bad84] First Commit
 10 files changed, 102 insertions(+)
 create mode 100644 .editorconfig
 create mode 100644 .gitignore
 create mode 100644 .travis.yml
 create mode 100644 LICENSE
 create mode 100644 README.md
 create mode 100644 shard.yml
 create mode 100644 spec/palindrome-example_spec.cr
 create mode 100644 spec/spec_helper.cr
 create mode 100644 src/palindrome-example.cr
 create mode 100644 src/palindrome-example/version.cr
</code></pre>
<h3 id="编写代码"><a class="header" href="#编写代码">编写代码</a></h3>
<p>怎么写代码取决于你自己，但是你写的成果会决定别人是否愿意用你的库，还有你如何维护它。</p>
<h4 id="测试代码"><a class="header" href="#测试代码">测试代码</a></h4>
<ul>
<li>测试你的代码，全部。这是让所有人确定它是否如期工作的唯一方法，包括你自己。</li>
<li>Crystal有 <a href="https://crystal-lang.org/api/Spec.html">内置的测试库</a>，用它就行了。</li>
</ul>
<h4 id="文档"><a class="header" href="#文档">文档</a></h4>
<ul>
<li>用规范的注释解释你的代码，全部，即使是私有方法。</li>
<li>Crystal有 <a href="guides/../conventions/documenting_code.html">内置的文档生成器</a>，用它就行了。</li>
</ul>
<p>运行 <code>crystal docs</code> 来把你的代码和注释转换为带链接的API文档。你可以用浏览器打开<code>/docs/</code> 目录来查看它。</p>
<p>下面讲述了如何把你编译器产生的文档连接到 GitHub Pages。</p>
<p>只要你的文档写完了，并且可以达到，就把这个文档链接加入到你的README.md，这样用户就知道它们。
(记得对应地更改 <code>&lt;LINK-TO-YOUR-DOCUMENTATION&gt;</code> )</p>
<pre><code class="language-Markdown">[![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](&lt;LINK-TO-YOUR-DOCUMENTATION&gt;) 
</code></pre>
<h3 id="写-readme"><a class="header" href="#写-readme">写 README</a></h3>
<p>README 是你项目的脸面，对项目的成败都有重大影响。
<a href="https://github.com/matiassingers/awesome-readme">Awesome README</a> 是这方面的一个优秀例子，并且提供了充分的资源。</p>
<p>最重要的，你的 README 应当解释： </p>
<ol>
<li>你的库是什么</li>
<li>它干什么</li>
<li>怎么用它</li>
</ol>
<p>这些解释都应当有良好的结构，辅以充实的样例。</p>
<p>注意： 一定要把Crystal创建的 README 模板里的 <code>[your-github-name]</code> 改成你自己的 GitHub 用户名。</p>
<h4 id="代码风格-1"><a class="header" href="#代码风格-1">代码风格</a></h4>
<ul>
<li>有自己的代码风格是好事，不过遵循 <a href="guides/../conventions/coding_style.html">Crystal 团队指定的核心准则</a>有助于增强代码一致性，可读性，也便于他人阅读和使用。</li>
<li>利用Crystal的 <a href="guides/../conventions/documenting_code.html">内置格式化器</a> 可以自动格式化某个目录中的所有 <code>.cr</code>文件。</li>
</ul>
<p>例如： </p>
<pre><code>crystal tool format
</code></pre>
<p>在命令参数中加 <code>--check</code> 可以检查你的代码是否已被正确格式化，即格式化起是否没有产生任何影响。</p>
<p>例如： </p>
<pre><code>crystal tool format --check
</code></pre>
<p>下面的 Travis CI 会教你如何 below to implement this in your build.</p>
<h3 id="编写-shardyml"><a class="header" href="#编写-shardyml">编写 <code>shard.yml</code></a></h3>
<p>以<a href="https://github.com/crystal-lang/shards/blob/master/SPEC.md#names">spec</a> 为准。</p>
<h4 id="名称"><a class="header" href="#名称">名称</a></h4>
<p>你的 <code>shard.yml</code>的 <code>name</code> 属性应当准确地概括你的库。</p>
<ul>
<li>搜索 <a href="https://crystalshards.xyz/">crystalshards.xyz</a>来检查你的名字是否已经被占用。</li>
</ul>
<p>例如</p>
<pre><code class="language-YAML">name: palindrome-example
</code></pre>
<h4 id="描述"><a class="header" href="#描述">描述</a></h4>
<p><code>shard.yml</code>中的 <code>description</code>域是对你Shard的大致描述。</p>
<p><code>description</code> 是用于找到你的Shard的一行概述。</p>
<p>描述应当：</p>
<ol>
<li>翔实</li>
<li>浅显</li>
</ol>
<h4 id="优化"><a class="header" href="#优化">优化</a></h4>
<p>如果其他人压根找不到你的项目,那就很难用到它。
<a href="https://crystalshards.xyz/">crystalshards.xyz</a> 目前是 Crystal 库的索引，我们将对它作出优化。</p>
<p>人们会询问库的<em>大致</em>功能和<em>准确</em>功能。
比如， Bob 想要一个回文数库，但是 Felipe 想要一个涉及文本的库， Susan 又想要一个拼写检查库。</p>
<p>我们的 <code>name</code>域已经是 Bob想要的 &quot;palindrome&quot;，所以我们就不用重复 <em>palindrome</em> 关键词。另外，我们要满足 Susan搜索的 &quot;spelling&quot;和 Felipe搜索的 &quot;text&quot;。</p>
<pre><code class="language-YAML">description: |
  A textual algorithm to tell if a word is spelled the same way forwards as it is backwards.
</code></pre>
<h3 id="github"><a class="header" href="#github">GitHub</a></h3>
<ul>
<li>
<p>创建一个仓， <code>name</code>和 <code>description</code>都和你的 <code>shard.yml</code>相同。</p>
</li>
<li>
<p>加入所需的代码</p>
</li>
</ul>
<pre><code class="language-bash">$ git add -A &amp;&amp; git commit -am &quot;shard complete&quot;
</code></pre>
<ul>
<li>设置远程仓: (记得对应地修改 <code>&lt;YOUR-GITHUB-USERNAME&gt;</code>和 <code>&lt;YOUR-REPOSITORY-NAME&gt;</code>)</li>
</ul>
<p>注意： 你可以随意把 <code>public</code>替换为 <code>origin</code>，或是其他你喜欢的名字。</p>
<pre><code class="language-bash">$ git remote add public https://github.com/&lt;YOUR-GITHUB-NAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.git
</code></pre>
<ul>
<li>Push 上去： </li>
</ul>
<pre><code class="language-bash">$ git push public master
</code></pre>
<h4 id="github-releases"><a class="header" href="#github-releases">GitHub Releases</a></h4>
<p>GitHub Releases 是个好的实践。</p>
<p>在你的README中加入编译提示，来提醒用户 release 的位置：
(记得对应地修改 <code>&lt;YOUR-GITHUB-USERNAME&gt;</code>和 <code>&lt;YOUR-REPOSITORY-NAME&gt;</code>)</p>
<pre><code class="language-Markdown">[![GitHub release](https://img.shields.io/github/release/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.svg)](https://github.com/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;/releases)
</code></pre>
<p>一开始线把它设为你的 <em>releases</em> 页面。</p>
<ul>
<li>它们在 <code>https://github.com/&lt;YOUR-GITHUB-NAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;/releases</code></li>
</ul>
<p>点击 &quot;Create a new release&quot;.</p>
<p>根据 <a href="https://github.com/crystal-lang/shards/blob/master/README.md"> Crystal Shards README</a>, </p>
<blockquote>
<p>当库在 repositories发布时, 这个仓应当有 semver式的版本标签，以 <code>v</code>为前缀。例如： v1.2.3, v2.0.0-rc1 或 v2017.04.1</p>
</blockquote>
<p>相应地，在 <code>tag version</code>输入你的版本, 比如 <code>v0.1.0</code>，这一定要与  <code>shard.yml</code> 中的<code>version</code>匹配。写上 <code>v0.1.0</code>，然后写一小段发布通告。 </p>
<p>点击 &quot;Publish release&quot;，完成。</p>
<p>你现在就会注意到README 里面的 GitHub Release badge已经更新了。</p>
<p>遵循<a href="http://semver.org/">语义版本</a>，每次创建新Realease时都把你的代码推送到 <code>master</code>。</p>
<h3 id="travis-ci-和-travisyml"><a class="header" href="#travis-ci-和-travisyml">Travis CI 和 <code>.travis.yml</code></a></h3>
<p>如果你没有准备好，就先去 <a href="https://travis-ci.org/">注册 Travis CI 账号</a>。</p>
<p>在你README.md 的description 下方加入 build badge:
(记得对应地修改 <code>&lt;YOUR-GITHUB-USERNAME&gt;</code>和 <code>&lt;YOUR-REPOSITORY-NAME&gt;</code>)</p>
<pre><code class="language-Markdown">[![Build Status](https://travis-ci.org/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.svg?branch=master)](https://travis-ci.org/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;) 
</code></pre>
<p>Build badges 可以简洁地告诉人们你的代码是否通过了 Travis CI 编译。</p>
<p>把这些加入你的 <code>.travis.yml</code>：</p>
<pre><code class="language-YAML">script:
  - crystal spec
</code></pre>
<p>这会让 Travis CI运行你的测试样例。 
根据命令的结果， Travis CI 会返回一个 <a href="https://docs.travis-ci.com/user/customizing-the-build/#Breaking-the-Build">构建状态</a> ，它是 &quot;passed&quot;, &quot;errored&quot;, &quot;failed&quot; 或 &quot;canceled&quot; 的一种。</p>
<p>如果你希望所有的代码都以 <code>crystal tool format</code>格式化，增加一行 <code>crystal tool format --check</code>。如果代码没有正确格式化，这就会 <a href="https://docs.travis-ci.com/user/for-beginners/#Breaking-the-Build">破坏构建状态</a> ，就像测试失败了一样。</p>
<p>例如</p>
<pre><code class="language-YAML">script:
  - crystal spec
  - crystal tool format --check
</code></pre>
<p>Commit ，然后 push 到 GitHub。</p>
<p>按照<a href="https://docs.travis-ci.com/user/getting-started/">如下指示</a> 建立 repo &amp; 运行 Travis CI。</p>
<p>一旦你运行起来，编译通过，你README中的 build badge就会被更新。</p>
<h4 id="把-docs-绑定到-github-pages"><a class="header" href="#把-docs-绑定到-github-pages">把 <code>docs</code> 绑定到 GitHub-Pages</a></h4>
<p>把这些 <code>script</code> 加入你的 <code>.travis.yml</code>:</p>
<pre><code class="language-YAML">  - crystal docs
</code></pre>
<p>这会让 Travis CI 创建你的文档。</p>
<p>然后，把这些部分加入你的 <code>.travis.yml</code>：
(记得对应地更改 <code>&lt;YOUR-GITHUB-REPOSITORY-NAME&gt;</code>)</p>
<pre><code class="language-YAML">deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN
  project_name: &lt;YOUR-GITHUB-REPOSITORY-NAME&gt;
  on:
    branch: master
  local_dir: docs
</code></pre>
<p>用你的<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">personal access token</a>和 <code>GITHUB_TOKEN</code>来<a href="https://docs.travis-ci.com/user/environment-variables#Defining-Variables-in-Repository-Settings">设置环境变量</a>。</p>
<p>一路下来 <code>.travis.yml</code>应当看着像这样：</p>
<pre><code class="language-YAML">language: crystal
script:
  - crystal spec
  - crystal docs
deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN
  project_name: &lt;YOUR-GITHUB-REPOSITORY-NAME&gt;
  on:
    branch: master
  local_dir: docs
</code></pre>
<p><a href="https://docs.travis-ci.com/user/deployment/pages/">这里</a> 有用 Travis CI 部署 GitHub-Pages 的官方文档。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
